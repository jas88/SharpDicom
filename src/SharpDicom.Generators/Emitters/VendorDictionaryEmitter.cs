using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace SharpDicom.Generators.Emitters
{
    /// <summary>
    /// Generates C# source code for vendor private dictionary lookups.
    /// </summary>
    internal static class VendorDictionaryEmitter
    {
        /// <summary>
        /// Emits C# source code for VendorDictionary.Generated.cs containing lookup tables.
        /// </summary>
        /// <param name="tags">The private tag definitions.</param>
        /// <returns>Generated C# source code.</returns>
        public static string Emit(ImmutableArray<Parsing.PrivateTagDefinition> tags)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Linq;");
            sb.AppendLine("#if NET8_0_OR_GREATER");
            sb.AppendLine("using System.Collections.Frozen;");
            sb.AppendLine("#endif");
            sb.AppendLine();
            sb.AppendLine("namespace SharpDicom.Data");
            sb.AppendLine("{");
            sb.AppendLine("    public static partial class VendorDictionary");
            sb.AppendLine("    {");

            // Generate tag lookup entries
            // Key: (normalized creator, element offset)
            // Deduplicate by taking first occurrence
            var entries = tags
                .GroupBy(t => (NormalizeCreator(t.Creator), t.ElementOffset))
                .Select(g => g.First())
                .OrderBy(t => t.Creator)
                .ThenBy(t => t.ElementOffset)
                .ToList();

            sb.AppendLine("        private static readonly (string Creator, byte Offset, string VR, string Keyword, string Name)[] s_privateTagEntries = new[]");
            sb.AppendLine("        {");

            foreach (var tag in entries)
            {
                sb.Append("            (\"");
                sb.Append(EscapeString(tag.Creator));
                sb.Append("\", (byte)0x");
                sb.Append(tag.ElementOffset.ToString("X2"));
                sb.Append(", \"");
                sb.Append(tag.VR);
                sb.Append("\", \"");
                sb.Append(EscapeString(tag.Keyword ?? tag.Name));
                sb.Append("\", \"");
                sb.Append(EscapeString(tag.Name));
                sb.AppendLine("\"),");
            }

            sb.AppendLine("        };");
            sb.AppendLine();

            // Generate creator info
            var creators = tags
                .GroupBy(t => NormalizeCreator(t.Creator))
                .Select(g => new { Creator = g.First().Creator, Count = g.Count() })
                .OrderBy(c => c.Creator)
                .ToList();

            sb.AppendLine("        private static readonly (string Creator, int TagCount)[] s_creatorEntries = new[]");
            sb.AppendLine("        {");

            foreach (var creator in creators)
            {
                sb.Append("            (\"");
                sb.Append(EscapeString(creator.Creator));
                sb.Append("\", ");
                sb.Append(creator.Count);
                sb.AppendLine("),");
            }

            sb.AppendLine("        };");
            sb.AppendLine();

            // Generate lookup dictionaries
            sb.AppendLine("#if NET8_0_OR_GREATER");
            sb.AppendLine("        private static readonly FrozenDictionary<(string, byte), (string VR, string Keyword, string Name)> s_tagLookup =");
            sb.AppendLine("            s_privateTagEntries.ToFrozenDictionary(");
            sb.AppendLine("                e => (NormalizeCreatorInternal(e.Creator), e.Offset),");
            sb.AppendLine("                e => (e.VR, e.Keyword, e.Name));");
            sb.AppendLine();
            sb.AppendLine("        private static readonly FrozenSet<string> s_knownCreators =");
            sb.AppendLine("            s_creatorEntries.Select(e => NormalizeCreatorInternal(e.Creator)).ToFrozenSet(StringComparer.OrdinalIgnoreCase);");
            sb.AppendLine("#else");
            sb.AppendLine("        private static readonly Dictionary<(string, byte), (string VR, string Keyword, string Name)> s_tagLookup =");
            sb.AppendLine("            s_privateTagEntries.ToDictionary(");
            sb.AppendLine("                e => (NormalizeCreatorInternal(e.Creator), e.Offset),");
            sb.AppendLine("                e => (e.VR, e.Keyword, e.Name));");
            sb.AppendLine();
            sb.AppendLine("        private static readonly HashSet<string> s_knownCreators =");
            sb.AppendLine("            new HashSet<string>(s_creatorEntries.Select(e => NormalizeCreatorInternal(e.Creator)), StringComparer.OrdinalIgnoreCase);");
            sb.AppendLine("#endif");
            sb.AppendLine();

            // Normalization helper (duplicated in generated code for self-containment)
            sb.AppendLine("        private static string NormalizeCreatorInternal(string creator)");
            sb.AppendLine("        {");
            sb.AppendLine("            return creator.Trim().ToUpperInvariant();");
            sb.AppendLine("        }");

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string NormalizeCreator(string creator)
        {
            return creator.Trim().ToUpperInvariant();
        }

        private static string EscapeString(string text)
        {
            if (string.IsNullOrEmpty(text))
            {
                return text;
            }

            return text
                .Replace("\\", "\\\\")
                .Replace("\"", "\\\"")
                .Replace("\r", "\\r")
                .Replace("\n", "\\n");
        }
    }
}
