---
phase: 04-character-encoding
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/SharpDicom/Data/DicomDataset.cs
  - src/SharpDicom/Data/DicomStringElement.cs
  - src/SharpDicom/IO/DicomFileReader.cs
  - tests/SharpDicom.Tests/Data/DicomDatasetEncodingTests.cs
  - tests/SharpDicom.Tests/IO/DicomFileReaderEncodingTests.cs
autonomous: true

must_haves:
  truths:
    - "DicomDataset.Encoding property reflects Specific Character Set (0008,0005)"
    - "DicomStringElement.GetString uses dataset encoding when none provided"
    - "Sequence items inherit encoding from parent dataset"
    - "Sequence items with local Specific Character Set override parent encoding"
    - "UTF-8 files decode patient names correctly"
    - "Latin-1 files decode extended characters correctly"
    # Note: GB18030 backslash safety is implicit in the GetStrings implementation
    # (splits decoded string, not raw bytes). No explicit GB18030 test bytes planned
    # for this phase - would require real GB18030 test data.
  artifacts:
    - path: "src/SharpDicom/Data/DicomDataset.cs"
      provides: "Encoding property with inheritance support"
      exports: ["Encoding"]
    - path: "src/SharpDicom/Data/DicomStringElement.cs"
      provides: "Encoding-aware string decoding"
      min_lines: 300
    - path: "tests/SharpDicom.Tests/Data/DicomDatasetEncodingTests.cs"
      provides: "Encoding property and inheritance tests"
      min_lines: 80
    - path: "tests/SharpDicom.Tests/IO/DicomFileReaderEncodingTests.cs"
      provides: "File reading with encoding tests"
      min_lines: 50
  key_links:
    - from: "DicomDataset.Add"
      to: "DicomEncoding.FromSpecificCharacterSet"
      via: "update encoding on (0008,0005)"
      pattern: "SpecificCharacterSet"
    - from: "DicomDataset.Encoding"
      to: "Parent?.Encoding"
      via: "inheritance fallback"
      pattern: "Parent\\?\\.Encoding"
    - from: "DicomStringElement.GetString"
      to: "DicomEncoding.Primary.GetString"
      via: "encoding parameter"
      pattern: "encoding\\.Primary\\.GetString"
---

<objective>
Integrate character encoding into DicomDataset and DicomStringElement, enabling proper text decoding based on Specific Character Set with sequence item inheritance.

Purpose: Enable correct decoding of international DICOM text by automatically applying the dataset's encoding to string elements.

Output:
- DicomDataset.Encoding property tracking encoding from Specific Character Set (0008,0005)
- Sequence item encoding inheritance via Parent property (established in Phase 3)
- DicomStringElement methods using dataset encoding by default
- GB18030-safe multi-value string splitting
- Integration tests with UTF-8 and Latin-1 test files
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-character-encoding/04-CONTEXT.md
@.planning/phases/04-character-encoding/04-RESEARCH.md
@.planning/phases/04-character-encoding/04-01-SUMMARY.md
@src/SharpDicom/Data/DicomDataset.cs
@src/SharpDicom/Data/DicomStringElement.cs
@src/SharpDicom/Data/DicomTag.WellKnown.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Encoding property to DicomDataset with inheritance</name>
  <files>
    - src/SharpDicom/Data/DicomDataset.cs
    - src/SharpDicom/Data/DicomTag.WellKnown.cs
  </files>
  <action>
1. Add SpecificCharacterSet tag to DicomTag.WellKnown.cs if not present:
   ```csharp
   public static readonly DicomTag SpecificCharacterSet = new(0x0008, 0x0005);
   ```

2. Add to DicomDataset class:

   Private field for local encoding:
   ```csharp
   private DicomEncoding _localEncoding = DicomEncoding.Default;
   ```

   Public property with inheritance:
   ```csharp
   /// <summary>
   /// Gets the character encoding for this dataset.
   /// </summary>
   /// <remarks>
   /// Determined from Specific Character Set (0008,0005).
   /// If not present, inherits from parent dataset (for sequence items).
   /// Returns Default (ASCII) if no encoding is specified at any level.
   /// </remarks>
   public DicomEncoding Encoding =>
       Contains(DicomTag.SpecificCharacterSet)
           ? _localEncoding
           : (Parent?.Encoding ?? DicomEncoding.Default);
   ```

3. Update Add() method to cache encoding when SpecificCharacterSet is added:
   After the existing CacheContextValue call, add:
   ```csharp
   // Cache encoding when Specific Character Set changes
   if (element.Tag == DicomTag.SpecificCharacterSet)
   {
       UpdateEncoding(element);
   }
   ```

4. Add private UpdateEncoding method:
   ```csharp
   private void UpdateEncoding(IDicomElement element)
   {
       if (element is DicomStringElement se)
       {
           var values = se.GetStrings(DicomEncoding.Default);
           _localEncoding = values != null && values.Length > 0
               ? DicomEncoding.FromSpecificCharacterSet(values)
               : DicomEncoding.Default;
       }
   }
   ```

5. Update Clear() method to reset encoding:
   ```csharp
   _localEncoding = DicomEncoding.Default;
   ```

6. Update ToOwned() to copy encoding:
   ```csharp
   copy._localEncoding = _localEncoding;
   ```
  </action>
  <verify>
    - `dotnet build src/SharpDicom` compiles without errors
    - DicomTag.SpecificCharacterSet exists
    - DicomDataset.Encoding property exists
  </verify>
  <done>
    - DicomDataset.Encoding property returns encoding based on Specific Character Set
    - Encoding inheritance from Parent works for sequence items
    - Encoding is cached when (0008,0005) element is added
    - Clear() resets encoding to Default
    - ToOwned() preserves encoding
  </done>
</task>

<task type="auto">
  <name>Task 2: Update DicomStringElement to use dataset encoding</name>
  <files>
    - src/SharpDicom/Data/DicomStringElement.cs
  </files>
  <action>
Update DicomStringElement methods to properly use encoding:

1. Update the existing GetString method to use encoding.Primary.GetString:
   ```csharp
   public string? GetString(DicomEncoding? encoding = null)
   {
       if (IsEmpty) return null;

       var enc = encoding ?? DicomEncoding.Default;
   #if NETSTANDARD2_0 || NETFRAMEWORK
       return enc.Primary.GetString(RawValue.ToArray()).TrimEnd(TrimChars);
   #else
       return enc.Primary.GetString(RawValue.Span).TrimEnd(TrimChars);
   #endif
   }
   ```
   Verify that the method signature accepts `DicomEncoding?` parameter and delegates to `enc.Primary.GetString()`. This ensures ISO 2022 escape sequences are handled by .NET's internal ISO2022Encoding class.

2. GetStrings method is already safe for GB18030 because it splits the decoded string (not raw bytes). Verify this is the case - the current implementation does:
   ```csharp
   var str = GetString(encoding);
   return str.Split('\\');
   ```
   This is correct because backslash splitting happens AFTER decoding to .NET string, avoiding the GB18030 0x5C ambiguity.

2. Add GetStringValue method returning ref struct for zero-copy scenarios (optional, for advanced use):
   ```csharp
   /// <summary>
   /// Get a string value wrapper that supports zero-copy UTF-8 access.
   /// </summary>
   /// <remarks>
   /// For UTF-8 or ASCII encoding, TryGetUtf8 on the result returns the raw bytes
   /// without allocation. For other encodings, AsString() allocates a string.
   /// </remarks>
   public DicomStringValue GetStringValue(DicomEncoding? encoding = null)
   {
       return new DicomStringValue(RawValue, encoding ?? DicomEncoding.Default);
   }
   ```

3. Add DicomStringValue ref struct (in same file or new file):
   ```csharp
   /// <summary>
   /// Wrapper for string element value supporting zero-copy UTF-8 access.
   /// </summary>
   public readonly ref struct DicomStringValue
   {
       private readonly ReadOnlySpan<byte> _bytes;
       private readonly DicomEncoding _encoding;

       internal DicomStringValue(ReadOnlyMemory<byte> bytes, DicomEncoding encoding)
       {
           _bytes = bytes.Span;
           _encoding = encoding;
       }

       /// <summary>Raw bytes of the string value.</summary>
       public ReadOnlySpan<byte> RawBytes => _bytes;

       /// <summary>True if encoding is UTF-8 compatible (zero-copy possible).</summary>
       public bool IsUtf8 => _encoding.IsUtf8Compatible;

       /// <summary>
       /// Try to get UTF-8 bytes without allocation.
       /// Returns true if encoding is UTF-8/ASCII compatible.
       /// </summary>
       public bool TryGetUtf8(out ReadOnlySpan<byte> utf8)
           => _encoding.TryGetUtf8(_bytes, out utf8);

       /// <summary>
       /// Get the string value (allocates for non-UTF-8 encodings).
       /// </summary>
       public string AsString()
       {
           if (_bytes.IsEmpty) return string.Empty;
           return _encoding.GetString(_bytes).TrimEnd(' ', '\0');
       }
   }
   ```

4. Update the existing TrimChars to be internal or move trimming into the ref struct.

Note: The main GetString() method remains unchanged - it already works correctly. The new GetStringValue() is an optional performance API for advanced scenarios.
  </action>
  <verify>
    - `dotnet build src/SharpDicom` compiles without errors
    - DicomStringValue ref struct is defined
    - GetStringValue method returns DicomStringValue
  </verify>
  <done>
    - DicomStringValue ref struct enables zero-copy UTF-8 access
    - GetStringValue method provides zero-copy API
    - Existing GetString/GetStrings methods continue to work
    - Multi-value splitting is GB18030-safe (splits decoded string)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add encoding tests for DicomDataset and file reading</name>
  <files>
    - tests/SharpDicom.Tests/Data/DicomDatasetEncodingTests.cs
    - tests/SharpDicom.Tests/IO/DicomFileReaderEncodingTests.cs
  </files>
  <action>
1. Create DicomDatasetEncodingTests.cs with NUnit tests:

   **Encoding property tests:**
   - Empty dataset has Default encoding
   - Adding SpecificCharacterSet updates Encoding property
   - Removing SpecificCharacterSet returns to inherited/Default encoding
   - Multiple SpecificCharacterSet values create encoding with extensions

   **Inheritance tests:**
   - Child dataset without SpecificCharacterSet inherits parent encoding
   - Child dataset WITH SpecificCharacterSet overrides parent encoding
   - Grandchild inherits from parent (not grandparent) when parent has encoding
   - Grandchild inherits from grandparent when parent has no encoding

   **GetString with encoding tests:**
   - GetString uses dataset Encoding when no encoding parameter provided
   - GetString with explicit encoding overrides dataset encoding

   **ToOwned tests:**
   - ToOwned preserves encoding
   - ToOwned copy is independent (no Parent reference)

2. Create DicomFileReaderEncodingTests.cs with NUnit tests:

   **UTF-8 file reading:**
   - Create test file bytes with UTF-8 encoded patient name
   - Read file and verify PatientName decodes correctly
   - Verify dataset.Encoding.IsUtf8Compatible is true

   **Latin-1 file reading:**
   - Create test file bytes with ISO_IR 100 and Latin-1 patient name (e.g., "MÃ¼ller")
   - Read file and verify PatientName decodes correctly
   - Verify dataset.Encoding.Primary.CodePage is 28591

   **Sequence item encoding inheritance:**
   - Create test file with sequence containing items without SpecificCharacterSet
   - Verify sequence items inherit parent encoding

   **Multi-value string splitting:**
   - Test string with multiple values splits correctly
   - (Note: GB18030 backslash testing requires actual GB18030 bytes)

Use MemoryStream with manually constructed DICOM bytes for tests (as established in Phase 2/3 tests).
  </action>
  <verify>
    - `dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomDatasetEncoding"` passes
    - `dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomFileReaderEncoding"` passes
    - Test count > 10 new tests
  </verify>
  <done>
    - DicomDataset encoding property tests pass
    - Encoding inheritance tests pass
    - UTF-8 and Latin-1 file reading tests pass
    - Sequence item encoding inheritance verified
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build all targets:
   ```bash
   dotnet build
   ```

2. Run new encoding tests:
   ```bash
   dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~Encoding"
   ```

3. Run all tests to ensure no regressions:
   ```bash
   dotnet test
   ```

4. Verify Phase 4 success criteria from ROADMAP.md:
   - [ ] UTF-8 files decode correctly
   - [ ] Latin-1 files decode correctly
   - [ ] Multi-encoding datasets handled (via inheritance)
   - [ ] Japanese/Chinese test files (stretch - ISO 2022 terms registered)

5. Verify requirements coverage:
   - FR-04.1: ASCII default encoding works
   - FR-04.2: UTF-8 zero-copy via DicomStringValue.TryGetUtf8
   - FR-04.3: Latin-1 decoding works
   - FR-04.4: Specific Character Set parsing integrated
   - FR-04.5: ISO 2022 terms registered and usable
</verification>

<success_criteria>
- [ ] DicomDataset.Encoding property reflects Specific Character Set
- [ ] Sequence items inherit encoding from parent
- [ ] Local SpecificCharacterSet overrides inherited encoding
- [ ] DicomStringValue ref struct enables zero-copy UTF-8 access
- [ ] UTF-8 file reading decodes international characters correctly
- [ ] Latin-1 file reading decodes extended characters correctly
- [ ] Multi-value strings split correctly (uses decoded string, not raw bytes)
- [ ] All new tests pass
- [ ] All existing tests continue to pass (460+ tests)
- [ ] Solution builds on all target frameworks
</success_criteria>

<output>
After completion, create `.planning/phases/04-character-encoding/04-02-SUMMARY.md`
</output>
