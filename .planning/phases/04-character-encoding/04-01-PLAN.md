---
phase: 04-character-encoding
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SharpDicom/Data/DicomEncoding.cs
  - src/SharpDicom/Data/DicomCharacterSets.cs
  - src/SharpDicom/SharpDicom.csproj
  - Directory.Packages.props
  - tests/SharpDicom.Tests/Data/DicomEncodingTests.cs
autonomous: true

must_haves:
  truths:
    - "UTF-8 character set term 'ISO_IR 192' maps to correct .NET Encoding"
    - "Latin-1 character set term 'ISO_IR 100' maps to correct .NET Encoding"
    - "Default encoding (absent or empty Specific Character Set) is ASCII"
    - "Multi-valued Specific Character Set creates encoding with extensions"
    - "UTF-8/ASCII detected as zero-copy compatible"
    - "ISO 2022 terms map to correct .NET code pages"
  artifacts:
    - path: "src/SharpDicom/Data/DicomEncoding.cs"
      provides: "Full DicomEncoding class with FromSpecificCharacterSet parsing"
      exports: ["DicomEncoding", "Primary", "Extensions", "IsUtf8Compatible", "FromSpecificCharacterSet"]
    - path: "src/SharpDicom/Data/DicomCharacterSets.cs"
      provides: "Character set registry mapping DICOM terms to .NET code pages"
      exports: ["DicomCharacterSets", "GetEncoding", "Register"]
    - path: "tests/SharpDicom.Tests/Data/DicomEncodingTests.cs"
      provides: "Unit tests for character set parsing"
      min_lines: 100
  key_links:
    - from: "DicomEncoding.FromSpecificCharacterSet"
      to: "DicomCharacterSets.GetEncoding"
      via: "term lookup"
      pattern: "DicomCharacterSets\\.GetEncoding"
    - from: "DicomCharacterSets"
      to: "System.Text.Encoding"
      via: "GetEncoding call"
      pattern: "Encoding\\.GetEncoding"
    - from: "DicomEncoding.GetString"
      to: "Primary.GetString"
      via: "encoding delegation"
      pattern: "Primary\\.GetString"
---

<objective>
Implement the DicomEncoding core class with Specific Character Set parsing, character set registry, and UTF-8 zero-copy detection.

Purpose: Provide foundation for correct text decoding of international DICOM data by mapping DICOM character set terms to .NET Encoding instances.

Output:
- Enhanced DicomEncoding class with Primary/Extensions properties
- DicomCharacterSets registry mapping ~40 DICOM terms to .NET code pages
- UTF-8 compatibility detection for zero-copy fast path
- Unit tests for single and multi-valued character set parsing
- System.Text.Encoding.CodePages package added for full encoding support
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-character-encoding/04-CONTEXT.md
@.planning/phases/04-character-encoding/04-RESEARCH.md
@src/SharpDicom/Data/DicomEncoding.cs
@Directory.Packages.props
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add System.Text.Encoding.CodePages package and create DicomCharacterSets registry</name>
  <files>
    - Directory.Packages.props
    - src/SharpDicom/SharpDicom.csproj
    - src/SharpDicom/Data/DicomCharacterSets.cs
  </files>
  <action>
1. Add to Directory.Packages.props:
   ```xml
   <PackageVersion Include="System.Text.Encoding.CodePages" Version="9.0.2" />
   ```

2. Add to src/SharpDicom/SharpDicom.csproj under relevant ItemGroup (all TFMs):
   ```xml
   <PackageReference Include="System.Text.Encoding.CodePages" />
   ```

3. Create DicomCharacterSets.cs static class with:
   - Private static FrozenDictionary/Dictionary for term-to-codepage mapping
   - Static constructor that calls Encoding.RegisterProvider(CodePagesEncodingProvider.Instance)
   - GetEncoding(string dicomTerm) method with normalization (replace "ISO IR" variants with "ISO_IR")
   - Register(string dicomTerm, int codePage) method for vendor extensions
   - GetDicomTerm(Encoding encoding) reverse lookup (nullable)

Character set mappings (from RESEARCH.md Section 4.2):
- "" (empty) -> 20127 (ASCII)
- "ISO_IR 6" -> 20127 (ASCII)
- "ISO_IR 100" -> 28591 (Latin-1)
- "ISO_IR 101" -> 28592 (Latin-2)
- "ISO_IR 109" -> 28593 (Latin-3)
- "ISO_IR 110" -> 28594 (Latin-4)
- "ISO_IR 144" -> 28595 (Cyrillic)
- "ISO_IR 127" -> 28596 (Arabic)
- "ISO_IR 126" -> 28597 (Greek)
- "ISO_IR 138" -> 28598 (Hebrew)
- "ISO_IR 148" -> 28599 (Latin-5/Turkish)
- "ISO_IR 166" -> 874 (Thai)
- "ISO_IR 192" -> 65001 (UTF-8)
- "GB18030" -> 54936
- "GBK" -> 936
- "ISO 2022 IR 6" -> 20127 (ASCII with ISO 2022)
- "ISO 2022 IR 87" -> 50220 (Japanese Kanji)
- "ISO 2022 IR 159" -> 50220 (Japanese Supplementary)
- "ISO 2022 IR 13" -> 50222 (Japanese Katakana)
- "ISO 2022 IR 149" -> 50225 (Korean)
- "ISO 2022 IR 58" -> 50227 (Simplified Chinese)
- "ISO 2022 IR 100" -> 28591 (Latin-1 with ISO 2022)
- "ISO 2022 IR 101" -> 28592 (Latin-2 with ISO 2022)
- "ISO 2022 IR 109" -> 28593 (Latin-3 with ISO 2022)
- "ISO 2022 IR 110" -> 28594 (Latin-4 with ISO 2022)
- "ISO 2022 IR 144" -> 28595 (Cyrillic with ISO 2022)
- "ISO 2022 IR 127" -> 28596 (Arabic with ISO 2022)
- "ISO 2022 IR 126" -> 28597 (Greek with ISO 2022)
- "ISO 2022 IR 138" -> 28598 (Hebrew with ISO 2022)
- "ISO 2022 IR 148" -> 28599 (Turkish with ISO 2022)
- "ISO 2022 IR 166" -> 874 (Thai with ISO 2022)

Use #if NET8_0_OR_GREATER for FrozenDictionary, else Dictionary.

Normalization rules:
- Trim whitespace
- Replace "ISO IR " with "ISO_IR "
- Replace "ISO-IR " with "ISO_IR "
- Handle case-insensitively for lookup
  </action>
  <verify>
    - `dotnet build src/SharpDicom` compiles without errors
    - DicomCharacterSets.GetEncoding("ISO_IR 100") returns Latin-1 encoding
    - DicomCharacterSets.GetEncoding("ISO_IR 192") returns UTF-8 encoding
  </verify>
  <done>
    - System.Text.Encoding.CodePages package added and referenced
    - DicomCharacterSets class maps all standard DICOM character sets to .NET code pages
    - Normalization handles common term variations
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance DicomEncoding class with parsing and zero-copy detection</name>
  <files>
    - src/SharpDicom/Data/DicomEncoding.cs
  </files>
  <action>
Replace the placeholder DicomEncoding with full implementation:

1. Properties:
   - `public Encoding Primary { get; }` - primary encoding (always present)
   - `public IReadOnlyList<Encoding>? Extensions { get; }` - extension encodings for ISO 2022 (null for non-ISO 2022)
   - `public bool IsUtf8Compatible => Primary.CodePage is 65001 or 20127;`
   - `public bool HasExtensions => Extensions is { Count: > 0 };`

2. Static well-known instances:
   - `public static readonly DicomEncoding Default` - ASCII (code page 20127)
   - `public static readonly DicomEncoding Utf8` - UTF-8 (code page 65001)
   - `public static readonly DicomEncoding Latin1` - ISO-8859-1 (code page 28591)

3. Factory methods:
   ```csharp
   public static DicomEncoding FromSpecificCharacterSet(string? value)
   ```
   - If null/empty/whitespace, return Default
   - Parse single term via DicomCharacterSets.GetEncoding
   - Return new DicomEncoding with that encoding

   ```csharp
   public static DicomEncoding FromSpecificCharacterSet(string[]? values)
   ```
   - If null/empty, return Default
   - First value -> Primary encoding
   - Remaining values -> Extensions list (if ISO 2022)
   - For UTF-8/GB18030/GBK, only single value allowed (per DICOM spec)

   ```csharp
   public static DicomEncoding FromEncoding(Encoding encoding)
   ```
   - Wrap a .NET Encoding in DicomEncoding

4. Zero-copy methods:
   ```csharp
   public bool TryGetUtf8(ReadOnlySpan<byte> bytes, out ReadOnlySpan<byte> utf8)
   ```
   - If IsUtf8Compatible, set utf8 = bytes and return true
   - Otherwise return false

5. Decoding method:
   ```csharp
   public string GetString(ReadOnlySpan<byte> bytes)
   ```
   - Use Primary.GetString(bytes) on .NET 6+
   - Use Primary.GetString(bytes.ToArray()) on netstandard2.0
   - NOTE: .NET's ISO 2022 code pages (50220-50227) handle escape sequences internally via the ISO2022Encoding class. No custom DecodeWithExtensions needed - the .NET Encoding classes parse escape sequences during GetString().

Private constructor taking Primary and optional Extensions list.

Add XML documentation for all public members.
  </action>
  <verify>
    - `dotnet build src/SharpDicom` compiles on all TFMs
    - DicomEncoding.Default.IsUtf8Compatible is true (ASCII is UTF-8 compatible)
    - DicomEncoding.Utf8.IsUtf8Compatible is true
    - DicomEncoding.Latin1.IsUtf8Compatible is false
    - DicomEncoding.FromSpecificCharacterSet("ISO_IR 192").Primary.CodePage is 65001
  </verify>
  <done>
    - DicomEncoding class has Primary, Extensions, IsUtf8Compatible properties
    - FromSpecificCharacterSet handles single and multi-valued inputs
    - TryGetUtf8 enables zero-copy for UTF-8/ASCII content
    - Static Default, Utf8, Latin1 instances available
  </done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive unit tests for character encoding</name>
  <files>
    - tests/SharpDicom.Tests/Data/DicomEncodingTests.cs
  </files>
  <action>
Create DicomEncodingTests.cs with NUnit tests covering:

1. **Single-valued character set parsing:**
   - Empty string returns Default (ASCII)
   - Null returns Default
   - "ISO_IR 100" returns Latin-1 (code page 28591)
   - "ISO_IR 192" returns UTF-8 (code page 65001)
   - "ISO_IR 6" returns ASCII (code page 20127)
   - "GB18030" returns GB18030 (code page 54936)

2. **Multi-valued character set parsing:**
   - ["ISO 2022 IR 87"] returns JIS X 0208 as Primary
   - ["ISO 2022 IR 87", "ISO 2022 IR 13"] returns Primary + Extensions
   - Extensions count is correct

3. **Normalization tests:**
   - "ISO IR 100" (space) normalizes to "ISO_IR 100"
   - "ISO-IR 100" (hyphen) normalizes to "ISO_IR 100"
   - "  ISO_IR 100  " (whitespace) works
   - Case insensitivity (if implemented)

4. **UTF-8 compatibility detection:**
   - Default.IsUtf8Compatible is true
   - Utf8.IsUtf8Compatible is true
   - Latin1.IsUtf8Compatible is false
   - FromSpecificCharacterSet("ISO_IR 192").IsUtf8Compatible is true

5. **TryGetUtf8 tests:**
   - UTF-8 encoding returns true and same bytes
   - ASCII encoding returns true and same bytes
   - Latin-1 encoding returns false

6. **GetString tests:**
   - ASCII bytes decode correctly
   - UTF-8 bytes with non-ASCII decode correctly
   - Latin-1 bytes with extended characters decode correctly

7. **Extensions property tests:**
   - Single-valued has null Extensions
   - Multi-valued has Extensions list
   - HasExtensions returns correct value

8. **DicomCharacterSets registry tests:**
   - All standard terms return valid encodings
   - Unknown term throws appropriate exception
   - Register method adds custom term
  </action>
  <verify>
    - `dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomEncodingTests"` passes all tests
    - Test count > 15 tests
  </verify>
  <done>
    - Comprehensive unit tests for DicomEncoding and DicomCharacterSets
    - All standard character set terms tested
    - Multi-valued parsing tested
    - UTF-8 compatibility detection tested
    - Zero-copy TryGetUtf8 tested
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build all targets:
   ```bash
   dotnet build src/SharpDicom
   ```

2. Run character encoding tests:
   ```bash
   dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomEncoding"
   ```

3. Run all tests to ensure no regressions:
   ```bash
   dotnet test
   ```

4. Verify requirements coverage:
   - FR-04.1 (ASCII default): DicomEncoding.Default
   - FR-04.2 (UTF-8 zero-copy): IsUtf8Compatible, TryGetUtf8
   - FR-04.3 (Latin-1): DicomCharacterSets mapping
   - FR-04.4 (Specific Character Set parsing): FromSpecificCharacterSet
   - FR-04.5 (ISO 2022 escape sequences): Handled by .NET's ISO2022Encoding class internally via code pages 50220-50227. DicomCharacterSets maps ISO 2022 IR terms to these code pages, and .NET handles the escape sequence parsing during GetString(). No custom DecodeWithExtensions implementation needed.
</verification>

<success_criteria>
- [ ] System.Text.Encoding.CodePages package added to Directory.Packages.props
- [ ] DicomCharacterSets maps all standard DICOM character sets (~25+ terms)
- [ ] DicomEncoding.FromSpecificCharacterSet parses single and multi-valued inputs
- [ ] IsUtf8Compatible correctly identifies UTF-8 and ASCII encodings
- [ ] TryGetUtf8 enables zero-copy for compatible encodings
- [ ] All new tests pass
- [ ] All existing tests continue to pass
- [ ] Solution builds on all target frameworks
</success_criteria>

<output>
After completion, create `.planning/phases/04-character-encoding/04-01-SUMMARY.md`
</output>
