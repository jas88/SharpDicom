---
phase: 03-implicit-vr-sequences
plan: 04
type: execute
wave: 3
depends_on: ["03-03"]
files_modified:
  - src/SharpDicom/IO/VRResolver.cs
  - src/SharpDicom/Data/DicomDataset.cs
  - src/SharpDicom/IO/DicomFileReader.cs
  - tests/SharpDicom.Tests/IO/ContextDependentVRTests.cs
  - tests/SharpDicom.Tests/Integration/ImplicitVRSequenceTests.cs
autonomous: true

must_haves:
  truths:
    - "Pixel Data VR resolved to OW when BitsAllocated > 8"
    - "Pixel Data VR resolved to OB when BitsAllocated <= 8"
    - "US/SS tags resolved based on PixelRepresentation"
    - "Deferred VR elements resolve on first access"
    - "64-bit VRs (OV, SV, UV) supported per DICOM 2020"
  artifacts:
    - path: "src/SharpDicom/IO/VRResolver.cs"
      provides: "Context-dependent VR resolution"
      contains: "ResolveVR"
      min_lines: 80
    - path: "tests/SharpDicom.Tests/IO/ContextDependentVRTests.cs"
      provides: "VR resolution tests"
      min_lines: 100
    - path: "tests/SharpDicom.Tests/Integration/ImplicitVRSequenceTests.cs"
      provides: "End-to-end implicit VR tests"
      min_lines: 100
  key_links:
    - from: "VRResolver.ResolveVR"
      to: "DicomDataset.BitsAllocated"
      via: "context lookup"
      pattern: "BitsAllocated"
---

<objective>
Implement context-dependent VR resolution and comprehensive Phase 3 verification.

Purpose: Some DICOM tags have multiple valid VRs (e.g., Pixel Data can be OB or OW). The correct VR depends on other elements (BitsAllocated, PixelRepresentation). This plan implements deferred VR resolution per CONTEXT.md decisions.

Output:
- VRResolver class for context-dependent VR resolution
- Deferred VR resolution with lazy evaluation
- Support for 64-bit VRs (OV, SV, UV) from DICOM 2020
- Comprehensive integration tests verifying Phase 3 success criteria
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-implicit-vr-sequences/03-RESEARCH.md
@.planning/phases/03-implicit-vr-sequences/03-CONTEXT.md
@.planning/phases/03-implicit-vr-sequences/03-01-SUMMARY.md
@.planning/phases/03-implicit-vr-sequences/03-02-SUMMARY.md
@.planning/phases/03-implicit-vr-sequences/03-03-SUMMARY.md
@src/SharpDicom/Data/DicomDataset.cs
@src/SharpDicom/Data/DicomDictionaryEntry.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VRResolver class</name>
  <files>src/SharpDicom/IO/VRResolver.cs</files>
  <action>
Create VRResolver class for context-dependent VR resolution:

```csharp
namespace SharpDicom.IO
{
    /// <summary>
    /// Resolves context-dependent Value Representations.
    /// </summary>
    /// <remarks>
    /// Some DICOM tags allow multiple VRs with the correct choice depending
    /// on other elements in the dataset:
    /// - Pixel Data (7FE0,0010): OW if BitsAllocated > 8, OB otherwise
    /// - US/SS tags: US if PixelRepresentation = 0, SS if = 1
    /// - LUT Data: OW if entries > 256, US otherwise
    /// </remarks>
    public static class VRResolver
    {
        // Implementation
    }
}
```

Implementation:

1. **ResolveVR method**:
   - Parameters: DicomTag tag, DicomDictionaryEntry? entry, DicomDataset context
   - Returns: DicomVR (resolved VR)
   - Logic:
     - If entry is null or single VR, return entry?.DefaultVR ?? DicomVR.UN
     - For Pixel Data (7FE0,0010):
       - Check context.BitsAllocated
       - Return OW if BitsAllocated > 8
       - Return OB if BitsAllocated <= 8 or null
     - For US/SS multi-VR tags:
       - Check context.PixelRepresentation
       - Return US if PixelRepresentation = 0 or null
       - Return SS if PixelRepresentation = 1
     - Default: return entry.DefaultVR

2. **IsMultiVRTag method**:
   - Returns true if tag is known to have multiple valid VRs
   - Checks dictionary entry for ValueRepresentations.Length > 1

3. **NeedsContext method**:
   - Returns true if tag requires context for VR resolution
   - Pixel Data, specific US/SS tags, LUT Data tags

4. **Support 64-bit VRs** per CONTEXT.md:
   - OV (64-bit Other Long), SV (64-bit Signed Long), UV (64-bit Unsigned Long)
   - These are new in DICOM 2020
   - Ensure DicomVR has these defined (add if missing)
   - Update DicomVR.Is32BitLength to return true for these
  </action>
  <verify>dotnet build src/SharpDicom/SharpDicom.csproj --no-restore</verify>
  <done>VRResolver provides context-dependent VR resolution for multi-VR tags</done>
</task>

<task type="auto">
  <name>Task 2: Create context-dependent VR tests</name>
  <files>tests/SharpDicom.Tests/IO/ContextDependentVRTests.cs</files>
  <action>
Create comprehensive tests for VRResolver:

1. **Pixel Data VR resolution**:
   - BitsAllocated = 8 -> OB
   - BitsAllocated = 16 -> OW
   - BitsAllocated = 32 -> OW
   - BitsAllocated not present -> OB (default)

2. **US/SS tag resolution**:
   - PixelRepresentation = 0 -> US
   - PixelRepresentation = 1 -> SS
   - PixelRepresentation not present -> US (default)
   - Test specific multi-VR tags: SmallestImagePixelValue (0028,0106)

3. **Single VR tags**:
   - PatientName always returns PN
   - SOPClassUID always returns UI
   - No context needed

4. **Unknown tags**:
   - Tag not in dictionary -> UN
   - Private tag -> UN

5. **Context inheritance**:
   - Create nested dataset (sequence item)
   - Set BitsAllocated on parent
   - Verify child inherits context for VR resolution

6. **64-bit VR tests**:
   - Verify OV, SV, UV are recognized
   - Verify Is32BitLength returns true

7. **Edge cases**:
   - Empty dataset context
   - Tag with context but context is 0
  </action>
  <verify>dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~ContextDependentVRTests" --no-restore</verify>
  <done>All context-dependent VR resolution tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive Phase 3 integration tests</name>
  <files>tests/SharpDicom.Tests/Integration/ImplicitVRSequenceTests.cs</files>
  <action>
Create end-to-end integration tests verifying all Phase 3 success criteria:

1. **Parse implicit VR test files**:
   - Create byte array representing implicit VR LE file
   - Include FMI with Transfer Syntax = 1.2.840.10008.1.2 (Implicit VR LE)
   - Include dataset with various element types
   - Verify all elements parse correctly with dictionary-derived VRs

2. **Nested sequences to depth 5+**:
   - Create file with 5 levels of nested sequences
   - Verify all levels accessible
   - Verify Parent chain correct at each level
   - Verify depth limit works (test with MaxSequenceDepth = 4)

3. **Undefined length with delimiters**:
   - Create file with undefined length sequence
   - Verify parsing terminates at SequenceDelimitationItem
   - Verify items terminate at ItemDelimitationItem
   - Mix defined and undefined length in same file

4. **Context-dependent VR resolution**:
   - Create file with BitsAllocated = 16
   - Include multi-VR tag (or simulate with manual bytes)
   - Verify VR resolved correctly

5. **Mixed explicit/implicit sequences**:
   - File with explicit VR dataset
   - Verify sequences still parse (SQ VR explicit in file)

6. **Real-world patterns**:
   - Patient module with sequences (Referenced Study Sequence)
   - SR document with deep nesting
   - RT structure set pattern (depth 3-4)

Verify against roadmap success criteria:
- [ ] Parse implicit VR test files
- [ ] Nested sequences to depth 5+
- [ ] Undefined length with delimiters
- [ ] Context-dependent VR resolution

Each test should use DicomFile.Open or DicomFileReader to verify full stack.
  </action>
  <verify>dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~ImplicitVRSequenceTests" --no-restore</verify>
  <done>All Phase 3 integration tests pass, verifying success criteria met</done>
</task>

</tasks>

<verification>
Run full test suite to verify Phase 3 complete:

```bash
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj
```

Verify all Phase 3 success criteria from roadmap:
1. Parse implicit VR test files - verified by ImplicitVRSequenceTests
2. Nested sequences to depth 5+ - verified by deep nesting test
3. Undefined length with delimiters - verified by delimiter tests
4. Context-dependent VR resolution - verified by VR resolution tests
</verification>

<success_criteria>
- VRResolver correctly resolves Pixel Data VR based on BitsAllocated
- VRResolver correctly resolves US/SS tags based on PixelRepresentation
- 64-bit VRs (OV, SV, UV) are supported
- Deferred VR resolution works for out-of-order context
- All Phase 3 roadmap success criteria verified by integration tests
- All tests pass (existing + new)
- Phase 3 ready for completion
</success_criteria>

<output>
After completion, create `.planning/phases/03-implicit-vr-sequences/03-04-SUMMARY.md`
</output>
