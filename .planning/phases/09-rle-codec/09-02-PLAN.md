---
phase: 09-rle-codec
plan: 02
type: execute
wave: 2
depends_on: [09-01]
files_modified:
  - src/SharpDicom/Codecs/Rle/RleSegmentHeader.cs
  - src/SharpDicom/Codecs/Rle/RleDecoder.cs
  - src/SharpDicom/Codecs/Rle/RleEncoder.cs
  - src/SharpDicom/Codecs/Rle/RleCodec.cs
  - src/SharpDicom/Codecs/Rle/RleCodecOptions.cs
  - tests/SharpDicom.Tests/Codecs/Rle/RleCodecTests.cs
  - tests/SharpDicom.Tests/Codecs/Rle/RleSegmentHeaderTests.cs
  - tests/SharpDicom.Tests/Codecs/Rle/RleEncoderDecoderTests.cs
autonomous: true

must_haves:
  truths:
    - "RleCodec decodes RLE-compressed pixel data to raw bytes"
    - "RleCodec encodes raw pixel data to RLE-compressed format"
    - "RleSegmentHeader parses 64-byte header correctly"
    - "Byte segments are ordered MSB-first (high bytes before low bytes)"
    - "SIMD acceleration improves run detection on .NET 8+"
    - "RleCodec registers automatically with CodecRegistry"
  artifacts:
    - path: "src/SharpDicom/Codecs/Rle/RleCodec.cs"
      provides: "IPixelDataCodec implementation for RLE"
      exports: ["RleCodec"]
    - path: "src/SharpDicom/Codecs/Rle/RleDecoder.cs"
      provides: "PackBits decompression"
      exports: ["RleDecoder"]
    - path: "src/SharpDicom/Codecs/Rle/RleEncoder.cs"
      provides: "PackBits compression with SIMD"
      exports: ["RleEncoder"]
    - path: "src/SharpDicom/Codecs/Rle/RleSegmentHeader.cs"
      provides: "64-byte header parsing"
      exports: ["RleSegmentHeader"]
  key_links:
    - from: "RleCodec"
      to: "CodecRegistry"
      via: "Static initializer or explicit registration"
      pattern: "CodecRegistry\\.Register.*RleCodec"
    - from: "RleCodec.Decode"
      to: "RleDecoder.DecodeSegment"
      via: "Per-segment decompression"
      pattern: "RleDecoder\\.DecodeSegment"
    - from: "RleCodec.Encode"
      to: "RleEncoder.EncodeSegment"
      via: "Per-segment compression"
      pattern: "RleEncoder\\.EncodeSegment"
---

<objective>
Implement the RLE (Run-Length Encoding) codec as the first concrete IPixelDataCodec implementation.

Purpose: Provide lossless compression/decompression for DICOM pixel data without external dependencies, validating the codec interface design and serving as a reference implementation.

Output: RleCodec implementing IPixelDataCodec, with RleDecoder (SIMD-optimized), RleEncoder, RleSegmentHeader, and comprehensive tests.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-rle-codec/09-CONTEXT.md
@.planning/phases/09-rle-codec/09-RESEARCH.md

# Prior plan artifacts
@.planning/phases/09-rle-codec/09-01-SUMMARY.md

# Existing types
@src/SharpDicom/Codecs/IPixelDataCodec.cs
@src/SharpDicom/Codecs/CodecRegistry.cs
@src/SharpDicom/Data/DicomFragmentSequence.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: RLE segment header and decoder</name>
  <files>
    src/SharpDicom/Codecs/Rle/RleSegmentHeader.cs
    src/SharpDicom/Codecs/Rle/RleDecoder.cs
  </files>
  <action>
Create `src/SharpDicom/Codecs/Rle/` directory and implement:

**1. RleSegmentHeader (readonly struct)**

The 64-byte header precedes each RLE-compressed frame:
- Bytes 0-3: Number of segments (uint32 LE, 1-15)
- Bytes 4-7: Offset to segment 1 (always 64)
- Bytes 8-11: Offset to segment 2 (or 0)
- ... up to 15 segments

```csharp
public readonly struct RleSegmentHeader
{
    public const int HeaderSize = 64;
    public const int MaxSegments = 15;

    private readonly int _numberOfSegments;
    private readonly uint _offset0, _offset1, _offset2, _offset3, _offset4;
    private readonly uint _offset5, _offset6, _offset7, _offset8, _offset9;
    private readonly uint _offset10, _offset11, _offset12, _offset13, _offset14;

    public int NumberOfSegments => _numberOfSegments;

    public uint GetSegmentOffset(int index)
    {
        // Return appropriate offset field based on index (0-14)
        // Throw ArgumentOutOfRangeException if index >= NumberOfSegments
    }

    public static RleSegmentHeader Parse(ReadOnlySpan<byte> data)
    {
        if (data.Length < HeaderSize)
            throw new DicomCodecException("RLE header too short") { BytePosition = 0 };

        var numSegments = BinaryPrimitives.ReadUInt32LittleEndian(data);
        if (numSegments == 0 || numSegments > MaxSegments)
            throw new DicomCodecException($"Invalid RLE segment count: {numSegments}") { BytePosition = 0 };

        // Read all 15 offset slots, validate first offset is 64
        // Return new RleSegmentHeader with parsed values
    }

    public static bool TryParse(ReadOnlySpan<byte> data, out RleSegmentHeader header, out string? error)
    {
        // Lenient parsing - returns false with error message instead of throwing
    }
}
```

**2. RleDecoder (static class)**

Implements TIFF PackBits decompression:

```csharp
public static class RleDecoder
{
    /// <summary>
    /// Decodes a single RLE segment (PackBits algorithm).
    /// </summary>
    /// <returns>Number of bytes written to output.</returns>
    public static int DecodeSegment(ReadOnlySpan<byte> compressed, Span<byte> output)
    {
        int srcPos = 0;
        int dstPos = 0;

        while (srcPos < compressed.Length && dstPos < output.Length)
        {
            sbyte header = (sbyte)compressed[srcPos++];

            if (header >= 0)
            {
                // Literal run: copy next (header + 1) bytes
                int count = header + 1;
                if (srcPos + count > compressed.Length || dstPos + count > output.Length)
                    break;
                compressed.Slice(srcPos, count).CopyTo(output.Slice(dstPos));
                srcPos += count;
                dstPos += count;
            }
            else if (header != -128)
            {
                // Replicate run: repeat next byte (-header + 1) times
                int count = -header + 1;
                if (srcPos >= compressed.Length || dstPos + count > output.Length)
                    break;
                output.Slice(dstPos, count).Fill(compressed[srcPos++]);
                dstPos += count;
            }
            // header == -128: no-op, skip
        }

        return dstPos;
    }

    /// <summary>
    /// Decodes a complete RLE frame (all segments).
    /// </summary>
    public static DecodeResult DecodeFrame(
        ReadOnlySpan<byte> compressedFrame,
        PixelDataInfo info,
        Span<byte> output,
        int frameIndex)
    {
        // 1. Parse header
        // 2. Validate segment count matches expected
        // 3. Decode each segment to temp buffer (ArrayPool)
        // 4. Interleave segments back to output (MSB-first order)
        // 5. Return DecodeResult.Ok or DecodeResult.Fail
    }
}
```

**Interleaving Logic (CRITICAL - MSB first):**

For 16-bit grayscale:
- Segment 0: High bytes of all pixels
- Segment 1: Low bytes of all pixels

Output reconstruction (little-endian storage):
```csharp
for (int i = 0; i < pixelCount; i++)
{
    output[i * 2] = lowByteSegment[i];     // Low byte first in memory
    output[i * 2 + 1] = highByteSegment[i]; // High byte second
}
```

For RGB (8-bit):
- Segment 0: Red, Segment 1: Green, Segment 2: Blue

For RGB (16-bit):
- Segments 0,1: Red (high, low)
- Segments 2,3: Green (high, low)
- Segments 4,5: Blue (high, low)

Number of segments formula: `(BitsAllocated / 8) * SamplesPerPixel`

Use `ArrayPool<byte>.Shared` for temporary segment buffers.
  </action>
  <verify>
    `dotnet build src/SharpDicom --nologo -v q` succeeds.
  </verify>
  <done>
    RleSegmentHeader parses 64-byte headers with validation.
    RleDecoder.DecodeSegment implements PackBits decompression.
    RleDecoder.DecodeFrame handles multi-segment interleaving (MSB-first).
  </done>
</task>

<task type="auto">
  <name>Task 2: RLE encoder with SIMD optimization</name>
  <files>
    src/SharpDicom/Codecs/Rle/RleEncoder.cs
    src/SharpDicom/Codecs/Rle/RleCodecOptions.cs
  </files>
  <action>
**1. RleCodecOptions (sealed class)**

```csharp
public sealed class RleCodecOptions
{
    public bool GenerateBasicOffsetTable { get; init; } = true;
    public bool GenerateExtendedOffsetTable { get; init; } = false;
    public int MaxDegreeOfParallelism { get; init; } = Environment.ProcessorCount;
}
```

**2. RleEncoder (static class)**

Implements TIFF PackBits compression with SIMD run detection:

```csharp
public static class RleEncoder
{
    /// <summary>
    /// Encodes a single segment using PackBits algorithm.
    /// </summary>
    public static int EncodeSegment(ReadOnlySpan<byte> input, Span<byte> output)
    {
        int srcPos = 0;
        int dstPos = 0;

        while (srcPos < input.Length)
        {
            // Find run length (SIMD on .NET 8+, scalar fallback)
            int runLength = FindRunLength(input, srcPos);

            if (runLength >= 3)
            {
                // Replicate run
                output[dstPos++] = (byte)(-(runLength - 1));
                output[dstPos++] = input[srcPos];
                srcPos += runLength;
            }
            else
            {
                // Literal run - find extent
                int literalStart = srcPos;
                int literalLength = FindLiteralLength(input, srcPos);

                output[dstPos++] = (byte)(literalLength - 1);
                input.Slice(literalStart, literalLength).CopyTo(output.Slice(dstPos));
                dstPos += literalLength;
                srcPos += literalLength;
            }
        }

        // Pad to even length
        if (dstPos % 2 != 0)
            output[dstPos++] = 0;

        return dstPos;
    }

    /// <summary>
    /// SIMD-accelerated run length detection (NET 8+).
    /// </summary>
    private static int FindRunLength(ReadOnlySpan<byte> data, int startIndex)
    {
#if NET8_0_OR_GREATER
        if (Vector128.IsHardwareAccelerated && data.Length - startIndex >= Vector128<byte>.Count)
        {
            return FindRunLengthSimd(data, startIndex);
        }
#endif
        return FindRunLengthScalar(data, startIndex);
    }

#if NET8_0_OR_GREATER
    private static int FindRunLengthSimd(ReadOnlySpan<byte> data, int startIndex)
    {
        byte target = data[startIndex];
        var targetVector = Vector128.Create(target);
        int pos = startIndex;

        while (pos + Vector128<byte>.Count <= data.Length && pos - startIndex < 128)
        {
            var chunk = Vector128.Create(data.Slice(pos, Vector128<byte>.Count));
            var comparison = Vector128.Equals(chunk, targetVector);

            if (comparison != Vector128<byte>.AllBitsSet)
            {
                var mask = ~comparison.ExtractMostSignificantBits();
                int firstDiff = BitOperations.TrailingZeroCount(mask);
                return Math.Min(pos + firstDiff - startIndex, 128);
            }

            pos += Vector128<byte>.Count;
        }

        // Handle tail
        while (pos < data.Length && pos - startIndex < 128 && data[pos] == target)
            pos++;

        return Math.Min(pos - startIndex, 128);
    }
#endif

    private static int FindRunLengthScalar(ReadOnlySpan<byte> data, int startIndex)
    {
        byte target = data[startIndex];
        int length = 1;
        while (startIndex + length < data.Length && length < 128 && data[startIndex + length] == target)
            length++;
        return length;
    }

    private static int FindLiteralLength(ReadOnlySpan<byte> data, int startIndex)
    {
        int pos = startIndex;
        while (pos < data.Length && pos - startIndex < 128)
        {
            // Check if starting a run of 3+
            if (pos + 2 < data.Length &&
                data[pos] == data[pos + 1] &&
                data[pos] == data[pos + 2])
                break;
            pos++;
        }
        return Math.Max(1, pos - startIndex);
    }

    /// <summary>
    /// Encodes a complete frame to RLE.
    /// </summary>
    public static ReadOnlyMemory<byte> EncodeFrame(
        ReadOnlySpan<byte> pixelData,
        PixelDataInfo info)
    {
        // 1. Deinterleave pixels into byte segments (MSB-first)
        // 2. Encode each segment
        // 3. Build header with offsets
        // 4. Concatenate header + encoded segments
        // 5. Return as ReadOnlyMemory<byte>
    }
}
```

**Deinterleaving (opposite of interleaving):**

For 16-bit grayscale (little-endian storage):
```csharp
for (int i = 0; i < pixelCount; i++)
{
    highByteSegment[i] = pixelData[i * 2 + 1]; // High byte from offset 1
    lowByteSegment[i] = pixelData[i * 2];      // Low byte from offset 0
}
```

Use `ArrayPool<byte>.Shared` for buffers. Add using for `System.Runtime.Intrinsics` on .NET 8+.
  </action>
  <verify>
    `dotnet build src/SharpDicom --nologo -v q` succeeds.
    SIMD code compiles on .NET 8+ only (no compile errors on older TFMs).
  </verify>
  <done>
    RleEncoder.EncodeSegment implements PackBits compression.
    SIMD run detection on .NET 8+ via Vector128.
    Scalar fallback on older frameworks.
    RleCodecOptions defines encoding configuration.
  </done>
</task>

<task type="auto">
  <name>Task 3: RleCodec implementation and tests</name>
  <files>
    src/SharpDicom/Codecs/Rle/RleCodec.cs
    tests/SharpDicom.Tests/Codecs/Rle/RleCodecTests.cs
    tests/SharpDicom.Tests/Codecs/Rle/RleSegmentHeaderTests.cs
    tests/SharpDicom.Tests/Codecs/Rle/RleEncoderDecoderTests.cs
  </files>
  <action>
**1. RleCodec (sealed class implementing IPixelDataCodec)**

```csharp
public sealed class RleCodec : IPixelDataCodec
{
    public TransferSyntax TransferSyntax => TransferSyntax.RLELossless;
    public string Name => "RLE Lossless";

    public CodecCapabilities Capabilities => new(
        CanEncode: true,
        CanDecode: true,
        IsLossy: false,
        SupportsMultiFrame: true,
        SupportsParallelEncode: true,
        SupportedBitDepths: new[] { 8, 16 },
        SupportedSamplesPerPixel: new[] { 1, 3 }
    );

    public DecodeResult Decode(
        DicomFragmentSequence fragments,
        PixelDataInfo info,
        int frameIndex,
        Memory<byte> destination)
    {
        if (frameIndex < 0 || frameIndex >= fragments.Fragments.Count)
            return DecodeResult.Fail(frameIndex, 0, "Frame index out of range");

        var fragment = fragments.Fragments[frameIndex];
        return RleDecoder.DecodeFrame(fragment.Span, info, destination.Span, frameIndex);
    }

    public ValueTask<DecodeResult> DecodeAsync(
        DicomFragmentSequence fragments,
        PixelDataInfo info,
        int frameIndex,
        Memory<byte> destination,
        CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();
        return new ValueTask<DecodeResult>(Decode(fragments, info, frameIndex, destination));
    }

    public DicomFragmentSequence Encode(
        ReadOnlySpan<byte> pixelData,
        PixelDataInfo info,
        object? options = null)
    {
        var rleOptions = options as RleCodecOptions ?? new RleCodecOptions();

        int frameSize = info.FrameSize;
        int frameCount = pixelData.Length / frameSize;
        var fragments = new List<ReadOnlyMemory<byte>>(frameCount);

        for (int i = 0; i < frameCount; i++)
        {
            var frameData = pixelData.Slice(i * frameSize, frameSize);
            var encoded = RleEncoder.EncodeFrame(frameData, info);
            fragments.Add(encoded);
        }

        // Build offset table if requested
        var offsetTable = rleOptions.GenerateBasicOffsetTable
            ? BuildOffsetTable(fragments)
            : ReadOnlyMemory<byte>.Empty;

        return new DicomFragmentSequence(
            DicomTag.PixelData,
            DicomVR.OB,
            offsetTable,
            fragments);
    }

    public ValueTask<DicomFragmentSequence> EncodeAsync(
        ReadOnlyMemory<byte> pixelData,
        PixelDataInfo info,
        object? options = null,
        CancellationToken ct = default)
    {
        ct.ThrowIfCancellationRequested();
        return new ValueTask<DicomFragmentSequence>(Encode(pixelData.Span, info, options));
    }

    public ValidationResult ValidateCompressedData(DicomFragmentSequence fragments, PixelDataInfo info)
    {
        var issues = new List<CodecDiagnostic>();
        int expectedSegments = (info.BitsAllocated / 8) * info.SamplesPerPixel;

        for (int i = 0; i < fragments.Fragments.Count; i++)
        {
            var fragment = fragments.Fragments[i];
            if (!RleSegmentHeader.TryParse(fragment.Span, out var header, out var error))
            {
                issues.Add(new CodecDiagnostic(i, 0, error ?? "Invalid header", null, null));
                continue;
            }

            if (header.NumberOfSegments != expectedSegments)
            {
                issues.Add(new CodecDiagnostic(
                    i, 0,
                    "Wrong segment count",
                    expectedSegments.ToString(),
                    header.NumberOfSegments.ToString()));
            }
        }

        return issues.Count == 0 ? ValidationResult.Valid() : ValidationResult.Invalid(issues);
    }

    private static ReadOnlyMemory<byte> BuildOffsetTable(List<ReadOnlyMemory<byte>> fragments)
    {
        if (fragments.Count <= 1)
            return ReadOnlyMemory<byte>.Empty;

        var offsets = new byte[fragments.Count * 4];
        uint offset = 0;
        for (int i = 0; i < fragments.Count; i++)
        {
            BinaryPrimitives.WriteUInt32LittleEndian(offsets.AsSpan(i * 4), offset);
            offset += (uint)fragments[i].Length;
        }
        return offsets;
    }
}
```

**2. RleSegmentHeaderTests**

```csharp
[TestFixture]
public class RleSegmentHeaderTests
{
    [Test]
    public void Parse_ValidHeader_ReturnsCorrectSegmentCount()
    [Test]
    public void Parse_HeaderTooShort_Throws()
    [Test]
    public void Parse_SegmentCountZero_Throws()
    [Test]
    public void Parse_SegmentCountTooHigh_Throws()
    [Test]
    public void GetSegmentOffset_ReturnsCorrectOffset()
    [Test]
    public void TryParse_InvalidHeader_ReturnsFalseWithError()
}
```

**3. RleEncoderDecoderTests**

```csharp
[TestFixture]
public class RleEncoderDecoderTests
{
    [Test]
    public void DecodeSegment_LiteralRun_DecodesCorrectly()
    [Test]
    public void DecodeSegment_ReplicateRun_DecodesCorrectly()
    [Test]
    public void DecodeSegment_MixedRuns_DecodesCorrectly()
    [Test]
    public void EncodeSegment_AllSameBytes_CreatesReplicateRun()
    [Test]
    public void EncodeSegment_AllDifferentBytes_CreatesLiteralRun()
    [Test]
    public void EncodeSegment_MixedPattern_OptimalEncoding()
    [Test]
    public void Roundtrip_8BitGrayscale_MatchesOriginal()
    [Test]
    public void Roundtrip_16BitGrayscale_MatchesOriginal()
    [Test]
    public void Roundtrip_8BitRgb_MatchesOriginal()
}
```

**4. RleCodecTests**

```csharp
[TestFixture]
public class RleCodecTests
{
    [SetUp]
    public void Setup() => CodecRegistry.Reset();

    [Test]
    public void TransferSyntax_IsRleLossless()
    [Test]
    public void Capabilities_CorrectValues()
    [Test]
    public void Decode_ValidFragment_ReturnsSuccess()
    [Test]
    public void Decode_InvalidFrameIndex_ReturnsFail()
    [Test]
    public void Encode_SingleFrame_CreatesValidFragment()
    [Test]
    public void Encode_MultiFrame_CreatesMultipleFragments()
    [Test]
    public void Roundtrip_8BitGrayscale_Lossless()
    [Test]
    public void Roundtrip_16BitGrayscale_Lossless()
    [Test]
    public void ValidateCompressedData_ValidData_ReturnsValid()
    [Test]
    public void ValidateCompressedData_WrongSegmentCount_ReturnsInvalid()
    [Test]
    public void RegisteredInCodecRegistry()
    {
        CodecRegistry.Register<RleCodec>();
        var codec = CodecRegistry.GetCodec(TransferSyntax.RLELossless);
        Assert.That(codec, Is.Not.Null);
        Assert.That(codec, Is.TypeOf<RleCodec>());
    }
}
```

Use helper methods to create test data (pixel buffers, expected encoded data).
  </action>
  <verify>
    `dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~Rle" --nologo` passes all tests.
  </verify>
  <done>
    RleCodec implements IPixelDataCodec for TransferSyntax.RLELossless.
    20+ tests verify RLE encoding/decoding correctness.
    Roundtrip tests prove lossless compression.
    RleCodec registers successfully with CodecRegistry.
  </done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
dotnet build --nologo -v q
dotnet test tests/SharpDicom.Tests --nologo
```

Expected outcome:
- Build succeeds on all target frameworks
- All RLE tests pass
- All existing tests continue to pass
- Roundtrip tests verify lossless encode/decode
</verification>

<success_criteria>
- [ ] RleSegmentHeader parses 64-byte headers with validation
- [ ] RleDecoder implements PackBits decompression correctly
- [ ] RleEncoder implements PackBits compression with even-length padding
- [ ] SIMD run detection active on .NET 8+ (Vector128)
- [ ] Byte segment ordering is MSB-first (high bytes before low)
- [ ] RleCodec implements IPixelDataCodec with Decode/Encode/Validate
- [ ] Roundtrip tests verify 8-bit and 16-bit grayscale lossless
- [ ] RleCodec registers with CodecRegistry successfully
- [ ] 20+ tests cover header parsing, encoding, decoding, roundtrip
- [ ] Solution builds warning-free on all TFMs
</success_criteria>

<output>
After completion, create `.planning/phases/09-rle-codec/09-02-SUMMARY.md`
</output>
