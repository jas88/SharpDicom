---
phase: 09-rle-codec
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SharpDicom/Codecs/IPixelDataCodec.cs
  - src/SharpDicom/Codecs/CodecCapabilities.cs
  - src/SharpDicom/Codecs/DecodeResult.cs
  - src/SharpDicom/Codecs/CodecDiagnostic.cs
  - src/SharpDicom/Codecs/ValidationResult.cs
  - src/SharpDicom/Codecs/CodecRegistry.cs
  - src/SharpDicom/Codecs/PixelDataInfo.cs
  - src/SharpDicom/Data/Exceptions/DicomCodecException.cs
  - tests/SharpDicom.Tests/Codecs/CodecRegistryTests.cs
autonomous: true

must_haves:
  truths:
    - "IPixelDataCodec interface defines decode/encode/validate contracts"
    - "CodecRegistry allows codec lookup by TransferSyntax"
    - "CodecCapabilities describes what a codec can do"
    - "DecodeResult reports success/failure with diagnostics"
    - "DicomCodecException provides codec-specific error context"
  artifacts:
    - path: "src/SharpDicom/Codecs/IPixelDataCodec.cs"
      provides: "Core codec interface"
      exports: ["IPixelDataCodec"]
    - path: "src/SharpDicom/Codecs/CodecRegistry.cs"
      provides: "Static codec lookup"
      exports: ["CodecRegistry"]
    - path: "src/SharpDicom/Codecs/CodecCapabilities.cs"
      provides: "Codec capability metadata"
      exports: ["CodecCapabilities"]
    - path: "src/SharpDicom/Codecs/DecodeResult.cs"
      provides: "Decode operation result"
      exports: ["DecodeResult"]
  key_links:
    - from: "CodecRegistry"
      to: "IPixelDataCodec"
      via: "Register() and GetCodec()"
      pattern: "Register.*IPixelDataCodec|GetCodec.*TransferSyntax"
    - from: "IPixelDataCodec"
      to: "DecodeResult"
      via: "Decode returns DecodeResult"
      pattern: "DecodeResult.*Decode"
---

<objective>
Define the extensible codec interface and registry infrastructure for pixel data compression/decompression.

Purpose: Establish contracts that external codec packages can implement, enabling extensible compression support without external dependencies in the core library.

Output: IPixelDataCodec interface, CodecRegistry for lookup, supporting types (CodecCapabilities, DecodeResult, CodecDiagnostic, PixelDataInfo), and DicomCodecException.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-rle-codec/09-CONTEXT.md
@.planning/phases/09-rle-codec/09-RESEARCH.md

# Existing types to reference
@src/SharpDicom/Data/TransferSyntax.cs
@src/SharpDicom/Data/DicomFragmentSequence.cs
@src/SharpDicom/Data/Exceptions/DicomException.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Core codec types and interface</name>
  <files>
    src/SharpDicom/Codecs/IPixelDataCodec.cs
    src/SharpDicom/Codecs/CodecCapabilities.cs
    src/SharpDicom/Codecs/DecodeResult.cs
    src/SharpDicom/Codecs/CodecDiagnostic.cs
    src/SharpDicom/Codecs/ValidationResult.cs
    src/SharpDicom/Codecs/PixelDataInfo.cs
    src/SharpDicom/Data/Exceptions/DicomCodecException.cs
  </files>
  <action>
Create the `src/SharpDicom/Codecs/` directory and implement:

**1. CodecCapabilities (readonly record struct)**
```csharp
public readonly record struct CodecCapabilities(
    bool CanEncode,
    bool CanDecode,
    bool IsLossy,
    bool SupportsMultiFrame,
    bool SupportsParallelEncode,
    int[] SupportedBitDepths,
    int[] SupportedSamplesPerPixel);
```

**2. CodecDiagnostic (readonly record struct)**
```csharp
public readonly record struct CodecDiagnostic(
    int FrameIndex,
    long BytePosition,
    string Message,
    string? Expected,
    string? Actual);
```

**3. DecodeResult (readonly record struct)**
```csharp
public readonly record struct DecodeResult(
    bool Success,
    int BytesWritten,
    CodecDiagnostic? Diagnostic)
{
    public static DecodeResult Ok(int bytesWritten) => new(true, bytesWritten, null);
    public static DecodeResult Fail(int frameIndex, long position, string message, string? expected = null, string? actual = null) =>
        new(false, 0, new CodecDiagnostic(frameIndex, position, message, expected, actual));
}
```

**4. ValidationResult (readonly record struct)**
```csharp
public readonly record struct ValidationResult(
    bool IsValid,
    IReadOnlyList<CodecDiagnostic> Issues)
{
    public static ValidationResult Valid() => new(true, Array.Empty<CodecDiagnostic>());
    public static ValidationResult Invalid(IEnumerable<CodecDiagnostic> issues) => new(false, issues.ToList());
    public static ValidationResult Invalid(CodecDiagnostic issue) => new(false, new[] { issue });
}
```

**5. PixelDataInfo (readonly record struct)**
```csharp
public readonly record struct PixelDataInfo(
    ushort Rows,
    ushort Columns,
    ushort BitsAllocated,
    ushort BitsStored,
    ushort HighBit,
    ushort SamplesPerPixel,
    ushort PixelRepresentation,
    ushort PlanarConfiguration,
    int NumberOfFrames)
{
    public int BytesPerPixel => (BitsAllocated / 8) * SamplesPerPixel;
    public int FrameSize => Rows * Columns * BytesPerPixel;
    public bool IsSigned => PixelRepresentation == 1;
}
```

**6. DicomCodecException (in Data/Exceptions/)**
```csharp
public class DicomCodecException : DicomException
{
    public TransferSyntax TransferSyntax { get; init; }
    public int? FrameIndex { get; init; }
    public long? BytePosition { get; init; }

    public DicomCodecException(string message) : base(message) { }
    public DicomCodecException(string message, Exception inner) : base(message, inner) { }
}
```

**7. IPixelDataCodec (interface)**
```csharp
public interface IPixelDataCodec
{
    TransferSyntax TransferSyntax { get; }
    string Name { get; }
    CodecCapabilities Capabilities { get; }

    DecodeResult Decode(
        DicomFragmentSequence fragments,
        PixelDataInfo info,
        int frameIndex,
        Memory<byte> destination);

    ValueTask<DecodeResult> DecodeAsync(
        DicomFragmentSequence fragments,
        PixelDataInfo info,
        int frameIndex,
        Memory<byte> destination,
        CancellationToken ct = default);

    DicomFragmentSequence Encode(
        ReadOnlySpan<byte> pixelData,
        PixelDataInfo info,
        object? options = null);

    ValueTask<DicomFragmentSequence> EncodeAsync(
        ReadOnlyMemory<byte> pixelData,
        PixelDataInfo info,
        object? options = null,
        CancellationToken ct = default);

    ValidationResult ValidateCompressedData(DicomFragmentSequence fragments, PixelDataInfo info);
}
```

Add appropriate XML documentation and namespace `SharpDicom.Codecs`. Ensure all types compile on netstandard2.0 through net9.0.

Note: Use `IReadOnlyList<CodecDiagnostic>` instead of `CodecDiagnostic[]` in ValidationResult for better encapsulation.
  </action>
  <verify>
    `dotnet build src/SharpDicom --nologo -v q` succeeds with no warnings.
    All new types are accessible from tests project.
  </verify>
  <done>
    IPixelDataCodec interface exists with Decode, DecodeAsync, Encode, EncodeAsync, ValidateCompressedData methods.
    Supporting types (CodecCapabilities, DecodeResult, CodecDiagnostic, ValidationResult, PixelDataInfo) compile and are usable.
    DicomCodecException inherits from DicomException with codec-specific context properties.
  </done>
</task>

<task type="auto">
  <name>Task 2: CodecRegistry with FrozenDictionary</name>
  <files>
    src/SharpDicom/Codecs/CodecRegistry.cs
  </files>
  <action>
Implement CodecRegistry as a static class with:

**Registration Methods:**
- `Register(IPixelDataCodec codec)` - adds codec to mutable registry
- `Register<TCodec>() where TCodec : IPixelDataCodec, new()` - generic registration
- `RegisterFromAssembly(Assembly assembly)` - scans assembly for codecs with parameterless constructors

**Lookup Methods:**
- `GetCodec(TransferSyntax syntax)` - returns codec or null
- `CanDecode(TransferSyntax syntax)` - checks if decoder available
- `CanEncode(TransferSyntax syntax)` - checks if encoder available
- `GetRegisteredTransferSyntaxes()` - returns all registered syntaxes

**Freeze Mechanism:**
- Use mutable `Dictionary<TransferSyntax, IPixelDataCodec>` during registration
- Auto-freeze to `FrozenDictionary` on first lookup (lazy)
- Explicit `Freeze()` method available
- Registration after freeze invalidates frozen cache

**Multi-TFM Support:**
- Use `FrozenDictionary<TransferSyntax, IPixelDataCodec>` on .NET 8+
- Fall back to regular `Dictionary` with `AsReadOnly()` on older TFMs
- Use `#if NET8_0_OR_GREATER` preprocessor directive

**Thread Safety:**
- Lock during registration
- Lock-free reads after freeze (via FrozenDictionary)
- `EnsureFrozen()` private method handles lazy freeze with locking

**Implementation Pattern (from RESEARCH.md):**
```csharp
public static class CodecRegistry
{
    private static readonly object _lock = new();
    private static Dictionary<TransferSyntax, IPixelDataCodec> _mutableRegistry = new();
#if NET8_0_OR_GREATER
    private static FrozenDictionary<TransferSyntax, IPixelDataCodec>? _frozenRegistry;
#else
    private static IReadOnlyDictionary<TransferSyntax, IPixelDataCodec>? _frozenRegistry;
#endif

    public static void Register(IPixelDataCodec codec) { ... }
    public static IPixelDataCodec? GetCodec(TransferSyntax syntax) { ... }
    // ... other methods
}
```

Add `Reset()` method for testing purposes (clears all registrations).

Add using directive for `System.Collections.Frozen` on .NET 8+.
  </action>
  <verify>
    `dotnet build src/SharpDicom --nologo -v q` succeeds on all TFMs.
    CodecRegistry compiles with FrozenDictionary on .NET 8+ and Dictionary fallback on older TFMs.
  </verify>
  <done>
    CodecRegistry.Register() adds codecs to registry.
    CodecRegistry.GetCodec() returns registered codec by TransferSyntax.
    CodecRegistry uses FrozenDictionary on .NET 8+ for thread-safe reads.
    Registration thread-safe via locking.
  </done>
</task>

<task type="auto">
  <name>Task 3: CodecRegistry tests</name>
  <files>
    tests/SharpDicom.Tests/Codecs/CodecRegistryTests.cs
  </files>
  <action>
Create test file with a mock codec implementation and tests:

**Mock Codec for Testing:**
```csharp
internal class MockCodec : IPixelDataCodec
{
    public TransferSyntax TransferSyntax { get; }
    public string Name => "Mock Codec";
    public CodecCapabilities Capabilities => new(true, true, false, true, true, new[] { 8, 16 }, new[] { 1, 3 });

    public MockCodec(TransferSyntax transferSyntax)
    {
        TransferSyntax = transferSyntax;
    }

    public MockCodec() : this(TransferSyntax.RLELossless) { }

    public DecodeResult Decode(...) => DecodeResult.Ok(0);
    public ValueTask<DecodeResult> DecodeAsync(...) => new(DecodeResult.Ok(0));
    public DicomFragmentSequence Encode(...) => throw new NotImplementedException();
    public ValueTask<DicomFragmentSequence> EncodeAsync(...) => throw new NotImplementedException();
    public ValidationResult ValidateCompressedData(...) => ValidationResult.Valid();
}
```

**Test Cases:**
1. `Register_AddsCodecToRegistry` - Register codec, GetCodec returns it
2. `GetCodec_ReturnsNull_WhenNotRegistered` - GetCodec for unregistered syntax returns null
3. `CanDecode_ReturnsTrue_WhenCodecRegistered` - CanDecode for registered syntax
4. `CanDecode_ReturnsFalse_WhenNotRegistered` - CanDecode for unregistered syntax
5. `CanEncode_ReturnsTrue_WhenCodecCanEncode` - CanEncode checks codec capabilities
6. `CanEncode_ReturnsFalse_WhenCodecCannotEncode` - Codec with CanEncode=false
7. `Register_Generic_CreatesInstanceAndRegisters` - Register<MockCodec>() works
8. `GetRegisteredTransferSyntaxes_ReturnsAllRegistered` - Returns collection of registered syntaxes
9. `Freeze_PreventsNewRegistrations_UntilReset` - After Freeze(), GetCodec works but subsequent Register invalidates cache
10. `Reset_ClearsAllRegistrations` - Reset() removes all codecs

**Setup/Teardown:**
- Call `CodecRegistry.Reset()` in [SetUp] to ensure clean state for each test

Use NUnit `[TestFixture]` and `[Test]` attributes.
  </action>
  <verify>
    `dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~CodecRegistry" --nologo -v q` passes all tests.
  </verify>
  <done>
    10 tests verify CodecRegistry behavior.
    Mock codec demonstrates IPixelDataCodec contract.
    Tests pass on all target frameworks.
  </done>
</task>

</tasks>

<verification>
Run full build and test suite:
```bash
dotnet build --nologo -v q
dotnet test tests/SharpDicom.Tests --nologo
```

Expected outcome:
- Build succeeds on all target frameworks (netstandard2.0, net6.0, net8.0, net9.0)
- All new tests pass
- All existing tests continue to pass (529+)
</verification>

<success_criteria>
- [ ] IPixelDataCodec interface defined with Decode/Encode/Validate contracts
- [ ] CodecCapabilities readonly record struct describes codec abilities
- [ ] DecodeResult provides success/failure with optional diagnostic
- [ ] PixelDataInfo captures pixel data metadata
- [ ] DicomCodecException extends DicomException with codec context
- [ ] CodecRegistry supports Register/GetCodec/CanDecode/CanEncode
- [ ] CodecRegistry uses FrozenDictionary on .NET 8+
- [ ] 10+ tests verify CodecRegistry behavior
- [ ] Solution builds warning-free on all TFMs
</success_criteria>

<output>
After completion, create `.planning/phases/09-rle-codec/09-01-SUMMARY.md`
</output>
