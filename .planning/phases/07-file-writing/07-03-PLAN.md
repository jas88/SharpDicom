---
phase: 07-file-writing
plan: 03
type: execute
wave: 3
depends_on: ["07-01", "07-02"]
files_modified:
  - src/SharpDicom/IO/DicomStreamWriter.cs
  - src/SharpDicom/IO/SequenceLengthCalculator.cs
  - tests/SharpDicom.Tests/IO/SequenceWritingTests.cs
  - tests/SharpDicom.Tests/Integration/RoundtripTests.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Sequences can be written with undefined length and delimiters"
    - "Sequences can be written with defined (calculated) length"
    - "Nested sequences are written correctly"
    - "Item and sequence delimitation items are correct"
    - "Roundtrip read-write-read produces identical datasets"
    - "Written files are readable by DicomFileReader"
  artifacts:
    - path: "src/SharpDicom/IO/SequenceLengthCalculator.cs"
      provides: "Two-pass length calculation for defined-length sequences"
      exports: ["SequenceLengthCalculator"]
    - path: "tests/SharpDicom.Tests/IO/SequenceWritingTests.cs"
      provides: "Sequence writing verification tests"
      min_lines: 200
    - path: "tests/SharpDicom.Tests/Integration/RoundtripTests.cs"
      provides: "Read-write-read verification tests"
      min_lines: 200
  key_links:
    - from: "src/SharpDicom/IO/DicomStreamWriter.cs"
      to: "src/SharpDicom/IO/SequenceLengthCalculator.cs"
      via: "Calls Calculate for defined length mode"
      pattern: "SequenceLengthCalculator\\.Calculate"
    - from: "src/SharpDicom/IO/DicomStreamWriter.cs"
      to: "src/SharpDicom/Data/DicomSequence.cs"
      via: "Iterates sequence items for writing"
      pattern: "sequence\\.Items"
---

<objective>
Complete DicomStreamWriter with sequence writing support and verify full read-write-read roundtrip functionality.

Purpose: Enables writing nested DICOM data structures (sequences) and validates that written files can be read back identically.

Output: Sequence writing in DicomStreamWriter, SequenceLengthCalculator for defined-length mode, roundtrip integration tests.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-file-writing/07-CONTEXT.md
@.planning/phases/07-file-writing/07-RESEARCH.md
@.planning/phases/07-file-writing/07-01-SUMMARY.md
@.planning/phases/07-file-writing/07-02-SUMMARY.md
@src/SharpDicom/IO/DicomStreamWriter.cs
@src/SharpDicom/IO/DicomWriterOptions.cs
@src/SharpDicom/Data/DicomSequence.cs
@src/SharpDicom/IO/SequenceParser.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SequenceLengthCalculator</name>
  <files>src/SharpDicom/IO/SequenceLengthCalculator.cs</files>
  <action>
Create SequenceLengthCalculator for two-pass defined-length calculation:

```csharp
public static class SequenceLengthCalculator
{
    // Calculate total byte length of a sequence (excluding sequence header)
    public static uint CalculateSequenceLength(DicomSequence sequence, bool explicitVR);

    // Calculate total byte length of a dataset
    public static uint CalculateDatasetLength(DicomDataset dataset, bool explicitVR);

    // Calculate total byte length of a single element (including header)
    public static uint CalculateElementLength(IDicomElement element, bool explicitVR);
}
```

**Calculation rules:**

For sequence length (sum of items, no sequence header):
```
foreach item in sequence.Items:
    total += 8  // Item tag (FFFE,E000) + item length (4 bytes)
    total += CalculateDatasetLength(item, explicitVR)
    // No ItemDelimitationItem for defined length
// No SequenceDelimitationItem for defined length
```

For dataset length (sum of elements):
```
foreach element in dataset:
    total += CalculateElementLength(element, explicitVR)
```

For element length:
- Explicit VR, 16-bit length VRs: 8 bytes header + value length
- Explicit VR, 32-bit length VRs: 12 bytes header + value length (or nested for SQ)
- Implicit VR: 8 bytes header + value length
- Sequences: header + CalculateSequenceLength(recursively)
- Value length must be even (include padding byte if odd)

**Overflow protection:** Return uint.MaxValue if calculation would overflow, which signals "use undefined length instead".
  </action>
  <verify>Build succeeds with `dotnet build src/SharpDicom --nologo -v q`</verify>
  <done>SequenceLengthCalculator can calculate byte lengths for datasets, sequences, and elements recursively.</done>
</task>

<task type="auto">
  <name>Task 2: Add sequence writing to DicomStreamWriter</name>
  <files>src/SharpDicom/IO/DicomStreamWriter.cs</files>
  <action>
Extend DicomStreamWriter with sequence writing methods:

```csharp
public sealed class DicomStreamWriter
{
    // ... existing code ...

    // Write a complete dataset (all elements including sequences)
    public void WriteDataset(DicomDataset dataset);

    // Write sequence with current length mode
    public void WriteSequence(DicomSequence sequence);

    // Internal: Write sequence with undefined length (delimiters)
    private void WriteSequenceUndefined(DicomSequence sequence);

    // Internal: Write sequence with defined length
    private void WriteSequenceDefined(DicomSequence sequence);
}
```

**Undefined length writing (default):**
1. Write sequence header with length = 0xFFFFFFFF
2. For each item:
   - Write Item tag (FFFE,E000) with length = 0xFFFFFFFF
   - Write item dataset elements
   - Write ItemDelimitationItem (FFFE,E00D) with length = 0
3. Write SequenceDelimitationItem (FFFE,E0DD) with length = 0

**Defined length writing:**
1. Calculate sequence length using SequenceLengthCalculator
2. If overflow (uint.MaxValue), fall back to undefined length
3. Write sequence header with calculated length
4. For each item:
   - Calculate item length
   - Write Item tag (FFFE,E000) with calculated length
   - Write item dataset elements
   - (No ItemDelimitationItem)
5. (No SequenceDelimitationItem)

**Delimiter tag format:**
- Group (2 bytes) + Element (2 bytes) + Length (4 bytes)
- Item: FFFE E000
- ItemDelimitationItem: FFFE E00D
- SequenceDelimitationItem: FFFE E0DD
- Delimiter tags use implicit VR format even in explicit VR files (no VR field)

**Recursion:** Nested sequences call WriteSequence recursively.

Update WriteElement to detect DicomSequence and call WriteSequence.
  </action>
  <verify>Build succeeds with `dotnet build src/SharpDicom --nologo -v q`</verify>
  <done>DicomStreamWriter can write sequences with both undefined (delimiters) and defined (calculated) length encoding.</done>
</task>

<task type="auto">
  <name>Task 3: Create sequence writing and roundtrip tests</name>
  <files>tests/SharpDicom.Tests/IO/SequenceWritingTests.cs, tests/SharpDicom.Tests/Integration/RoundtripTests.cs</files>
  <action>
Create SequenceWritingTests:

1. **Undefined Length Tests:**
   - Single item sequence with undefined length
   - Multiple items with undefined length
   - Empty sequence (no items)
   - Verify Item and SequenceDelimitationItem present
   - Verify lengths are 0xFFFFFFFF

2. **Defined Length Tests:**
   - Single item sequence with defined length
   - Multiple items with defined length
   - Verify no delimitation items present
   - Verify calculated lengths are correct

3. **Nested Sequence Tests:**
   - Sequence containing sequence (depth 2)
   - Deeply nested (depth 3+)
   - Mixed content (sequences + regular elements)

4. **Length Calculation Tests:**
   - CalculateElementLength for various VRs
   - CalculateDatasetLength for mixed elements
   - CalculateSequenceLength matches written bytes

5. **Edge Cases:**
   - Sequence with empty item
   - Item with single element
   - Very long sequence (many items)

Create RoundtripTests:

1. **Basic Roundtrip:**
   - Create dataset with elements
   - Write to MemoryStream
   - Read back with DicomFile.Open
   - Verify all elements match

2. **Sequence Roundtrip:**
   - Create dataset with sequences
   - Write and read back
   - Verify sequence structure intact
   - Verify all item elements match

3. **Nested Sequence Roundtrip:**
   - Create deeply nested structure
   - Write and read back
   - Verify nesting preserved

4. **Transfer Syntax Roundtrip:**
   - Write as Explicit VR LE, read back
   - Write as Implicit VR LE, read back
   - Write as Explicit VR BE, read back

5. **Character Encoding Roundtrip:**
   - Write UTF-8 patient name
   - Read back and verify encoding
   - Verify SpecificCharacterSet preserved

6. **Full File Roundtrip:**
   - Write complete DicomFile (FMI + dataset)
   - Read back as DicomFile
   - Verify FMI preserved
   - Verify dataset identical

**Comparison helper:** Create method to compare two DicomDatasets for equality:
- Same number of elements
- Same tags in same order
- Same VRs
- Same values (byte-level comparison)
- Recursive comparison for sequences
  </action>
  <verify>All tests pass with `dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~SequenceWritingTests|RoundtripTests" --nologo -v q`</verify>
  <done>Sequence writing tests verify correct delimiter/defined length output. Roundtrip tests confirm read-write-read identity.</done>
</task>

</tasks>

<verification>
1. `dotnet build --nologo -v q` succeeds with no errors
2. `dotnet test tests/SharpDicom.Tests --nologo -v q` passes all tests
3. Roundtrip tests confirm written files can be read back identically
4. Sequence tests verify both undefined and defined length modes
</verification>

<success_criteria>
- SequenceLengthCalculator calculates byte lengths for datasets/sequences/elements
- DicomStreamWriter.WriteSequence supports both length modes
- Undefined length mode writes correct delimiter items
- Defined length mode calculates and writes correct lengths
- Nested sequences work to arbitrary depth
- Roundtrip read-write-read produces identical datasets
- All transfer syntaxes roundtrip correctly
- Character encoding preserved through roundtrip
- FMI preserved through roundtrip
- All new tests pass
- All existing tests continue to pass
- Phase 7 success criteria from roadmap met:
  - Written files validate with dcmtk (manual verification)
  - Roundtrip read-write-read identical
  - Streaming write to network (architecture supports it)
  - Both length modes work
</success_criteria>

<output>
After completion, create `.planning/phases/07-file-writing/07-03-SUMMARY.md`
</output>
