---
phase: 07-file-writing
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/SharpDicom/IO/DicomFileWriter.cs
  - src/SharpDicom/IO/FileMetaInfoGenerator.cs
  - src/SharpDicom/IO/DicomWriterOptions.cs
  - src/SharpDicom/Data/SharpDicomInfo.cs
  - src/SharpDicom/DicomFile.cs
  - tests/SharpDicom.Tests/IO/DicomFileWriterTests.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "DicomFileWriter writes valid Part 10 files with preamble and DICM prefix"
    - "File Meta Information is auto-generated with correct required tags"
    - "FMI Group Length (0002,0000) is calculated correctly"
    - "Transfer Syntax UID in FMI matches actual dataset encoding"
    - "FMI is always written as Explicit VR Little Endian"
    - "Dataset is written using specified transfer syntax"
  artifacts:
    - path: "src/SharpDicom/IO/DicomFileWriter.cs"
      provides: "High-level file writing with Part 10 structure"
      exports: ["DicomFileWriter"]
    - path: "src/SharpDicom/IO/FileMetaInfoGenerator.cs"
      provides: "Automatic FMI generation with group length calculation"
      exports: ["FileMetaInfoGenerator"]
    - path: "src/SharpDicom/Data/SharpDicomInfo.cs"
      provides: "SharpDicom implementation UID and version"
      exports: ["SharpDicomInfo"]
    - path: "tests/SharpDicom.Tests/IO/DicomFileWriterTests.cs"
      provides: "File writing verification tests"
      min_lines: 250
  key_links:
    - from: "src/SharpDicom/IO/DicomFileWriter.cs"
      to: "src/SharpDicom/IO/DicomStreamWriter.cs"
      via: "Uses DicomStreamWriter for element output"
      pattern: "DicomStreamWriter"
    - from: "src/SharpDicom/IO/FileMetaInfoGenerator.cs"
      to: "src/SharpDicom/Data/DicomDataset.cs"
      via: "Extracts SOPClassUID/SOPInstanceUID from dataset"
      pattern: "GetString.*SOPClassUID|SOPInstanceUID"
    - from: "src/SharpDicom/IO/DicomFileWriter.cs"
      to: "src/SharpDicom/IO/FileMetaInfoGenerator.cs"
      via: "Calls Generate to create FMI"
      pattern: "FileMetaInfoGenerator\\.Generate"
---

<objective>
Implement DicomFileWriter for writing DICOM Part 10 files with automatic File Meta Information generation.

Purpose: Enables writing complete DICOM files with proper structure (preamble, DICM, FMI, dataset) and auto-generated File Meta Information.

Output: DicomFileWriter class, FileMetaInfoGenerator class, SharpDicomInfo constants, DicomFile.Save methods.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-file-writing/07-CONTEXT.md
@.planning/phases/07-file-writing/07-RESEARCH.md
@.planning/phases/07-file-writing/07-01-SUMMARY.md
@src/SharpDicom/IO/DicomStreamWriter.cs
@src/SharpDicom/IO/DicomWriterOptions.cs
@src/SharpDicom/Data/DicomDataset.cs
@src/SharpDicom/DicomFile.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SharpDicomInfo and FileMetaInfoGenerator</name>
  <files>src/SharpDicom/Data/SharpDicomInfo.cs, src/SharpDicom/IO/FileMetaInfoGenerator.cs, src/SharpDicom/IO/DicomWriterOptions.cs</files>
  <action>
Create SharpDicomInfo with implementation identifiers:

```csharp
namespace SharpDicom.Data
{
    public static class SharpDicomInfo
    {
        // Root: Using 2.25 prefix (UUID-derived) for simplicity
        // Format: 2.25.{UUID as decimal}
        public static readonly DicomUID ImplementationClassUID =
            new("2.25.336851275958757810911461898545210578371");

        public const string ImplementationVersionName = "SHARPDICOM_1_0";
    }
}
```

Update DicomWriterOptions to include FMI settings:

```csharp
public class DicomWriterOptions
{
    // ... existing properties ...

    // File Meta Information
    public bool AutoGenerateFmi { get; init; } = true;
    public DicomUID? ImplementationClassUID { get; init; }  // null = SharpDicom default
    public string? ImplementationVersionName { get; init; } = SharpDicomInfo.ImplementationVersionName;

    // Preamble
    public ReadOnlyMemory<byte>? Preamble { get; init; }  // null = 128 zeros

    // Validation
    public bool ValidateFmiUids { get; init; } = true;  // Require SOPClassUID/SOPInstanceUID in dataset
}
```

Create FileMetaInfoGenerator:

```csharp
public static class FileMetaInfoGenerator
{
    public static DicomDataset Generate(
        DicomDataset dataset,
        TransferSyntax transferSyntax,
        DicomWriterOptions options);
}
```

FMI generation requires these elements:
1. **(0002,0000) FileMetaInformationGroupLength** - UL - calculated total bytes of remaining Group 0002 elements
2. **(0002,0001) FileMetaInformationVersion** - OB - {0x00, 0x01}
3. **(0002,0002) MediaStorageSOPClassUID** - UI - from dataset (0008,0016)
4. **(0002,0003) MediaStorageSOPInstanceUID** - UI - from dataset (0008,0018)
5. **(0002,0010) TransferSyntaxUID** - UI - target transfer syntax
6. **(0002,0012) ImplementationClassUID** - UI - from options or SharpDicomInfo
7. **(0002,0013) ImplementationVersionName** - SH - from options (optional)

**Group Length Calculation:**
- Build FMI dataset with elements (0002,0001) through (0002,0013)
- Calculate serialized length of each element (Explicit VR LE format)
- Sum all lengths to get group length value
- Insert (0002,0000) with calculated length at front

**UID Padding:**
- UI VR uses 0x00 padding for odd lengths (not 0x20)
- Trim existing padding before adding new padding
  </action>
  <verify>Build succeeds with `dotnet build src/SharpDicom --nologo -v q`</verify>
  <done>SharpDicomInfo contains implementation UID and version. FileMetaInfoGenerator creates valid FMI with correct group length calculation.</done>
</task>

<task type="auto">
  <name>Task 2: Implement DicomFileWriter and DicomFile.Save</name>
  <files>src/SharpDicom/IO/DicomFileWriter.cs, src/SharpDicom/DicomFile.cs</files>
  <action>
Create DicomFileWriter class:

```csharp
public sealed class DicomFileWriter : IAsyncDisposable, IDisposable
{
    private readonly Stream _stream;
    private readonly DicomWriterOptions _options;
    private readonly bool _leaveOpen;
    private bool _disposed;

    public DicomFileWriter(Stream stream, DicomWriterOptions? options = null, bool leaveOpen = false);

    // Sync write
    public void Write(DicomFile file);
    public void Write(DicomDataset dataset, TransferSyntax? transferSyntax = null);

    // Async write
    public ValueTask WriteAsync(DicomFile file, CancellationToken ct = default);
    public ValueTask WriteAsync(DicomDataset dataset, TransferSyntax? transferSyntax = null, CancellationToken ct = default);

    // Dispose
    public void Dispose();
    public ValueTask DisposeAsync();
}
```

**Write sequence:**
1. Write 128-byte preamble (from options or zeros)
2. Write "DICM" prefix (4 bytes)
3. Generate or use provided FMI
4. Write FMI elements (always Explicit VR Little Endian)
5. Write dataset elements (using target transfer syntax)

**Stream adapter for IBufferWriter:**
Create internal StreamBufferWriter class that wraps Stream and implements IBufferWriter<byte>:

```csharp
internal sealed class StreamBufferWriter : IBufferWriter<byte>
{
    private readonly Stream _stream;
    private byte[] _buffer;
    private int _written;

    public StreamBufferWriter(Stream stream, int bufferSize = 81920);
    public Span<byte> GetSpan(int sizeHint = 0);
    public Memory<byte> GetMemory(int sizeHint = 0);
    public void Advance(int count);
    public void Flush();
    public async ValueTask FlushAsync(CancellationToken ct = default);
}
```

Add Save methods to DicomFile:

```csharp
public sealed class DicomFile
{
    // Existing properties...

    // Sync save
    public void Save(string path, DicomWriterOptions? options = null);
    public void Save(Stream stream, DicomWriterOptions? options = null);

    // Async save
    public ValueTask SaveAsync(string path, DicomWriterOptions? options = null, CancellationToken ct = default);
    public ValueTask SaveAsync(Stream stream, DicomWriterOptions? options = null, CancellationToken ct = default);
}
```
  </action>
  <verify>Build succeeds with `dotnet build src/SharpDicom --nologo -v q`</verify>
  <done>DicomFileWriter writes Part 10 files. DicomFile.Save methods enable convenient file output. StreamBufferWriter adapts Stream to IBufferWriter.</done>
</task>

<task type="auto">
  <name>Task 3: Create DicomFileWriter tests</name>
  <files>tests/SharpDicom.Tests/IO/DicomFileWriterTests.cs</files>
  <action>
Create comprehensive tests for DicomFileWriter and FileMetaInfoGenerator:

**File Structure Tests:**
1. Written file starts with 128-byte preamble
2. DICM prefix present at offset 128
3. Custom preamble is written correctly
4. FMI elements are present after DICM

**FMI Generation Tests:**
1. FileMetaInformationVersion is {0x00, 0x01}
2. MediaStorageSOPClassUID matches dataset SOPClassUID
3. MediaStorageSOPInstanceUID matches dataset SOPInstanceUID
4. TransferSyntaxUID matches options.TransferSyntax
5. ImplementationClassUID uses SharpDicomInfo default
6. ImplementationVersionName uses default version string
7. Custom ImplementationClassUID is used when provided

**Group Length Tests:**
1. FileMetaInformationGroupLength (0002,0000) is present
2. Group length value equals sum of following element lengths
3. Group length is accurate after adding optional elements

**Transfer Syntax Tests:**
1. FMI is always Explicit VR Little Endian regardless of dataset TS
2. Dataset is written with specified transfer syntax
3. Implicit VR Little Endian dataset written correctly

**Validation Tests:**
1. Throws when dataset missing SOPClassUID (if validation enabled)
2. Throws when dataset missing SOPInstanceUID (if validation enabled)
3. Succeeds when validation disabled and UIDs missing

**Roundtrip Preparation:**
1. Write dataset to MemoryStream
2. Verify output starts with expected bytes
3. Verify FMI elements are in correct order (sorted by tag)

Use MemoryStream for all tests. Create test datasets with minimal elements (SOPClassUID, SOPInstanceUID, PatientName).
  </action>
  <verify>All tests pass with `dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomFileWriterTests" --nologo -v q`</verify>
  <done>DicomFileWriter tests verify correct Part 10 structure, FMI generation, group length calculation, and transfer syntax handling.</done>
</task>

</tasks>

<verification>
1. `dotnet build --nologo -v q` succeeds with no errors
2. `dotnet test tests/SharpDicom.Tests --nologo -v q` passes all tests
3. Written files have correct Part 10 structure (preamble + DICM + FMI + dataset)
4. FMI group length is calculated correctly
</verification>

<success_criteria>
- SharpDicomInfo provides implementation UID and version name
- FileMetaInfoGenerator creates valid FMI with all required elements
- FMI Group Length is calculated correctly
- DicomFileWriter writes Part 10 files with preamble, DICM, FMI, dataset
- FMI is always Explicit VR LE regardless of dataset transfer syntax
- DicomFile.Save methods work for both path and stream
- Custom preamble can be specified
- Custom implementation UID/version can be specified
- Validation catches missing SOPClassUID/SOPInstanceUID
- All new tests pass
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-file-writing/07-02-SUMMARY.md`
</output>
