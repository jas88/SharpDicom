---
phase: 13-native-codecs-package
plan: 09
type: execute
wave: 5
depends_on: ["13-07"]
files_modified:
  - tests/SharpDicom.Codecs.Tests/SharpDicom.Codecs.Tests.csproj
  - tests/SharpDicom.Codecs.Tests/NativeCodecsTests.cs
  - tests/SharpDicom.Codecs.Tests/NativeJpegCodecTests.cs
  - tests/SharpDicom.Codecs.Tests/NativeJpeg2000CodecTests.cs
  - tests/SharpDicom.Codecs.Tests/CodecRegistryPriorityTests.cs
autonomous: true

must_haves:
  truths:
    - "Native codec initialization is tested"
    - "Decode produces correct pixel data from test files"
    - "Priority-based codec registration works correctly"
  artifacts:
    - path: "tests/SharpDicom.Codecs.Tests/NativeCodecsTests.cs"
      provides: "Tests for NativeCodecs initialization"
      min_lines: 50
    - path: "tests/SharpDicom.Codecs.Tests/NativeJpegCodecTests.cs"
      provides: "Tests for JPEG codec decode/encode"
      min_lines: 80
  key_links:
    - from: "tests/SharpDicom.Codecs.Tests/NativeJpegCodecTests.cs"
      to: "src/SharpDicom.Codecs/Codecs/NativeJpegCodec.cs"
      via: "test coverage"
      pattern: "NativeJpegCodec"
---

<objective>
Create test suite for native codecs package

Purpose: Validate native codec initialization, decode/encode operations, priority registration, and error handling work correctly on systems with native libraries available.

Output: Comprehensive test coverage for SharpDicom.Codecs functionality
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-native-codecs-package/13-CONTEXT.md
@.planning/phases/13-native-codecs-package/13-07-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test project and initialization tests</name>
  <files>
    tests/SharpDicom.Codecs.Tests/SharpDicom.Codecs.Tests.csproj
    tests/SharpDicom.Codecs.Tests/NativeCodecsTests.cs
    tests/SharpDicom.Codecs.Tests/CodecRegistryPriorityTests.cs
  </files>
  <action>
1. Create `tests/SharpDicom.Codecs.Tests/SharpDicom.Codecs.Tests.csproj`:
   ```xml
   <Project Sdk="Microsoft.NET.Sdk">
     <PropertyGroup>
       <TargetFrameworks>net8.0;net9.0</TargetFrameworks>
       <Nullable>enable</Nullable>
       <IsPackable>false</IsPackable>
       <IsTestProject>true</IsTestProject>
     </PropertyGroup>

     <ItemGroup>
       <PackageReference Include="NUnit" />
       <PackageReference Include="NUnit3TestAdapter" />
       <PackageReference Include="Microsoft.NET.Test.Sdk" />
       <PackageReference Include="Coverlet.Collector" />
     </ItemGroup>

     <ItemGroup>
       <ProjectReference Include="..\..\src\SharpDicom\SharpDicom.csproj" />
       <ProjectReference Include="..\..\src\SharpDicom.Codecs\SharpDicom.Codecs.csproj" />
     </ItemGroup>

     <!-- Test data files -->
     <ItemGroup>
       <None Include="TestData\**\*" CopyToOutputDirectory="PreserveNewest" />
     </ItemGroup>
   </Project>
   ```

2. Create `tests/SharpDicom.Codecs.Tests/NativeCodecsTests.cs`:
   ```csharp
   using NUnit.Framework;
   using SharpDicom.Codecs.Native;
   using System;

   namespace SharpDicom.Codecs.Tests
   {
       [TestFixture]
       public class NativeCodecsTests
       {
           [OneTimeSetUp]
           public void Setup()
           {
               // Reset codec registry before tests
               CodecRegistry.Reset();
           }

           [Test]
           [Category("Native")]
           public void IsAvailable_AfterInitialize_ReturnsTrue()
           {
               // Skip if native library not present
               try
               {
                   NativeCodecs.Initialize();
               }
               catch (NativeCodecException ex) when (ex.InnerException is DllNotFoundException)
               {
                   Assert.Ignore("Native library not available");
               }

               Assert.That(NativeCodecs.IsAvailable, Is.True);
           }

           [Test]
           [Category("Native")]
           public void SimdFeatures_WhenAvailable_ReturnsNonZero()
           {
               try
               {
                   NativeCodecs.Initialize();
               }
               catch (NativeCodecException)
               {
                   Assert.Ignore("Native library not available");
               }

               // At minimum, SSE2 or NEON should be detected
               Assert.That(NativeCodecs.ActiveSimdFeatures, Is.Not.EqualTo(SimdFeatures.None));
           }

           [Test]
           [Category("Native")]
           public void Initialize_CalledTwice_DoesNotThrow()
           {
               try
               {
                   NativeCodecs.Initialize();
                   Assert.DoesNotThrow(() => NativeCodecs.Initialize());
               }
               catch (NativeCodecException ex) when (ex.InnerException is DllNotFoundException)
               {
                   Assert.Ignore("Native library not available");
               }
           }

           [Test]
           public void Initialize_WhenLibraryMissing_ThrowsNativeCodecException()
           {
               // This test verifies error handling - may pass or fail depending on native availability
               // If it throws, verify it's the right exception type
               CodecRegistry.Reset();

               try
               {
                   NativeCodecs.Initialize();
               }
               catch (NativeCodecException ex)
               {
                   Assert.That(ex.Message, Does.Contain("Native library"));
                   Assert.That(ex.InnerException, Is.InstanceOf<DllNotFoundException>());
               }
           }

           [Test]
           [Category("Native")]
           public void DisableAutoInit_AppContextSwitch_PreventsAutoInit()
           {
               AppContext.SetSwitch("SharpDicom.Codecs.DisableAutoInit", true);
               try
               {
                   // After setting switch, module initializer should not auto-init
                   // This is more of a documentation test
                   Assert.Pass("AppContext switch set successfully");
               }
               finally
               {
                   AppContext.SetSwitch("SharpDicom.Codecs.DisableAutoInit", false);
               }
           }
       }
   }
   ```

3. Create `tests/SharpDicom.Codecs.Tests/CodecRegistryPriorityTests.cs`:
   ```csharp
   using NUnit.Framework;
   using SharpDicom.Codecs;
   using SharpDicom.Codecs.Native;
   using SharpDicom.Data;
   using System;

   namespace SharpDicom.Codecs.Tests
   {
       [TestFixture]
       public class CodecRegistryPriorityTests
       {
           [SetUp]
           public void Setup()
           {
               CodecRegistry.Reset();
           }

           [Test]
           public void Register_HigherPriority_OverridesLowerPriority()
           {
               var lowPriority = new MockCodec("Low");
               var highPriority = new MockCodec("High");

               CodecRegistry.Register(lowPriority, 50);
               CodecRegistry.Register(highPriority, 100);

               var result = CodecRegistry.GetCodec(TransferSyntax.JpegBaselineProcess1);
               Assert.That(result, Is.SameAs(highPriority));
           }

           [Test]
           public void Register_LowerPriority_DoesNotOverride()
           {
               var highPriority = new MockCodec("High");
               var lowPriority = new MockCodec("Low");

               CodecRegistry.Register(highPriority, 100);
               CodecRegistry.Register(lowPriority, 50);

               var result = CodecRegistry.GetCodec(TransferSyntax.JpegBaselineProcess1);
               Assert.That(result, Is.SameAs(highPriority));
           }

           [Test]
           public void Register_DefaultPriority_Is50()
           {
               var defaultCodec = new MockCodec("Default");
               var lowPriority = new MockCodec("Low");

               CodecRegistry.Register(defaultCodec);  // Default = 50
               CodecRegistry.Register(lowPriority, 40);

               var result = CodecRegistry.GetCodec(TransferSyntax.JpegBaselineProcess1);
               Assert.That(result, Is.SameAs(defaultCodec));
           }

           [Test]
           public void GetCodecInfo_ReturnsCorrectPriority()
           {
               var codec = new MockCodec("Test");
               CodecRegistry.Register(codec, 75);

               var info = CodecRegistry.GetCodecInfo(TransferSyntax.JpegBaselineProcess1);

               Assert.That(info, Is.Not.Null);
               Assert.That(info.Value.Priority, Is.EqualTo(75));
               Assert.That(info.Value.Name, Is.EqualTo("Test"));
           }

           [Test]
           [Category("Native")]
           public void NativeCodecs_RegisterWithPriority100()
           {
               try
               {
                   NativeCodecs.Initialize();
               }
               catch (NativeCodecException)
               {
                   Assert.Ignore("Native library not available");
               }

               var info = CodecRegistry.GetCodecInfo(TransferSyntax.JpegBaselineProcess1);

               Assert.That(info, Is.Not.Null);
               Assert.That(info.Value.Priority, Is.EqualTo(100));
               Assert.That(info.Value.Name, Does.Contain("Native"));
           }

           private class MockCodec : IPixelDataCodec
           {
               public TransferSyntax TransferSyntax => TransferSyntax.JpegBaselineProcess1;
               public string Name { get; }
               public CodecCapabilities Capabilities => new(true, true, true, false);

               public MockCodec(string name) => Name = name;

               public DecodeResult Decode(DicomFragmentSequence fragments, Codecs.PixelDataInfo info,
                   int frameIndex, Memory<byte> destination) => DecodeResult.Success;

               public ValueTask<DecodeResult> DecodeAsync(DicomFragmentSequence fragments,
                   Codecs.PixelDataInfo info, int frameIndex, Memory<byte> destination,
                   CancellationToken ct) => new(DecodeResult.Success);

               public DicomFragmentSequence Encode(ReadOnlySpan<byte> pixelData,
                   Codecs.PixelDataInfo info, object? options) => throw new NotImplementedException();

               public ValueTask<DicomFragmentSequence> EncodeAsync(ReadOnlyMemory<byte> pixelData,
                   Codecs.PixelDataInfo info, object? options, CancellationToken ct) => throw new NotImplementedException();

               public ValidationResult ValidateCompressedData(DicomFragmentSequence fragments,
                   Codecs.PixelDataInfo info) => ValidationResult.Valid;
           }
       }
   }
   ```
  </action>
  <verify>
```bash
dotnet build /Users/jas88/Developer/Github/SharpDicom/tests/SharpDicom.Codecs.Tests/SharpDicom.Codecs.Tests.csproj
```
Test project builds successfully
  </verify>
  <done>
Test project created with initialization and priority registration tests
  </done>
</task>

<task type="auto">
  <name>Task 2: Create codec-specific decode/encode tests</name>
  <files>
    tests/SharpDicom.Codecs.Tests/NativeJpegCodecTests.cs
    tests/SharpDicom.Codecs.Tests/NativeJpeg2000CodecTests.cs
    tests/SharpDicom.Codecs.Tests/TestData/README.md
  </files>
  <action>
1. Create `tests/SharpDicom.Codecs.Tests/TestData/README.md`:
   ```markdown
   # Test Data

   Test files should be placed here. Use NEMA WG-04 conformance test files.

   ## Required Files

   - jpeg_baseline_8bit.dcm - JPEG Baseline 8-bit test file
   - jpeg_lossless_14sv1.dcm - JPEG Lossless Process 14 SV1
   - j2k_lossless.dcm - JPEG 2000 Lossless
   - j2k_lossy.dcm - JPEG 2000 Lossy
   - jpegls_lossless.dcm - JPEG-LS Lossless

   ## Obtaining Test Files

   Download from NEMA WG-04:
   https://www.dclunie.com/images/compressed/

   Or use dcmtk to create test files from uncompressed sources.
   ```

2. Create `tests/SharpDicom.Codecs.Tests/NativeJpegCodecTests.cs`:
   ```csharp
   using NUnit.Framework;
   using SharpDicom.Codecs;
   using SharpDicom.Codecs.Native;
   using SharpDicom.Data;
   using SharpDicom.IO;
   using System;
   using System.IO;

   namespace SharpDicom.Codecs.Tests
   {
       [TestFixture]
       [Category("Native")]
       public class NativeJpegCodecTests
       {
           private NativeJpegCodec _codec = null!;

           [OneTimeSetUp]
           public void Setup()
           {
               try
               {
                   NativeCodecs.Initialize();
                   _codec = new NativeJpegCodec();
               }
               catch (NativeCodecException)
               {
                   Assert.Ignore("Native library not available");
               }
           }

           [Test]
           public void Decode_ValidJpeg_ProducesCorrectDimensions()
           {
               var testFile = Path.Combine(TestContext.CurrentContext.TestDirectory, "TestData", "jpeg_baseline_8bit.dcm");
               if (!File.Exists(testFile))
               {
                   Assert.Ignore("Test file not available");
               }

               var dicomFile = DicomFile.Open(testFile);
               var pixelData = dicomFile.Dataset.GetPixelData();
               var fragments = pixelData as DicomFragmentSequence;

               Assert.That(fragments, Is.Not.Null);

               var info = Codecs.PixelDataInfo.FromDataset(dicomFile.Dataset);
               var destination = new byte[info.UncompressedFrameSize];

               var result = _codec.Decode(fragments!, info, 0, destination);

               Assert.That(result.Success, Is.True);
           }

           [Test]
           public void Decode_InvalidFrameIndex_ThrowsArgumentOutOfRange()
           {
               var fragments = new DicomFragmentSequence(new[] { new DicomFragment(new byte[100]) });
               var info = new Codecs.PixelDataInfo(512, 512, 1, 8, 1, false, "MONOCHROME2");

               Assert.Throws<ArgumentOutOfRangeException>(() =>
                   _codec.Decode(fragments, info, 5, new byte[512 * 512]));
           }

           [Test]
           public void Encode_ValidPixels_ProducesValidJpeg()
           {
               var width = 256;
               var height = 256;
               var pixels = new byte[width * height];

               // Create gradient test pattern
               for (int y = 0; y < height; y++)
                   for (int x = 0; x < width; x++)
                       pixels[y * width + x] = (byte)((x + y) / 2);

               var info = new Codecs.PixelDataInfo(width, height, 1, 8, 1, false, "MONOCHROME2");

               var fragments = _codec.Encode(pixels, info, new JpegEncodeOptions { Quality = 90 });

               Assert.That(fragments.Fragments.Count, Is.GreaterThan(0));

               // Verify JPEG header
               var jpeg = fragments.Fragments[0].Data.Span;
               Assert.That(jpeg[0], Is.EqualTo(0xFF));  // SOI
               Assert.That(jpeg[1], Is.EqualTo(0xD8));
           }

           [Test]
           public void Roundtrip_EncodeDecodeEncode_MaintainsData()
           {
               var width = 128;
               var height = 128;
               var original = new byte[width * height];
               var random = new Random(42);
               random.NextBytes(original);

               var info = new Codecs.PixelDataInfo(width, height, 1, 8, 1, false, "MONOCHROME2");

               // Encode
               var fragments = _codec.Encode(original, info);

               // Decode
               var decoded = new byte[width * height];
               var result = _codec.Decode(fragments, info, 0, decoded);

               Assert.That(result.Success, Is.True);

               // JPEG is lossy, so we can't expect exact match
               // But PSNR should be reasonable (> 30dB for Q90)
               double mse = 0;
               for (int i = 0; i < original.Length; i++)
               {
                   var diff = original[i] - decoded[i];
                   mse += diff * diff;
               }
               mse /= original.Length;
               var psnr = 10 * Math.Log10(255 * 255 / mse);

               Assert.That(psnr, Is.GreaterThan(30.0), "PSNR should be > 30dB for Q90 JPEG");
           }
       }
   }
   ```

3. Create `tests/SharpDicom.Codecs.Tests/NativeJpeg2000CodecTests.cs`:
   ```csharp
   using NUnit.Framework;
   using SharpDicom.Codecs;
   using SharpDicom.Codecs.Native;
   using SharpDicom.Data;
   using System;

   namespace SharpDicom.Codecs.Tests
   {
       [TestFixture]
       [Category("Native")]
       public class NativeJpeg2000CodecTests
       {
           private NativeJpeg2000Codec _losslessCodec = null!;
           private NativeJpeg2000Codec _lossyCodec = null!;

           [OneTimeSetUp]
           public void Setup()
           {
               try
               {
                   NativeCodecs.Initialize();
                   _losslessCodec = new NativeJpeg2000Codec(TransferSyntax.Jpeg2000Lossless);
                   _lossyCodec = new NativeJpeg2000Codec(TransferSyntax.Jpeg2000Lossy);
               }
               catch (NativeCodecException)
               {
                   Assert.Ignore("Native library not available");
               }
           }

           [Test]
           public void LosslessEncode_ThenDecode_ExactMatch()
           {
               var width = 64;
               var height = 64;
               var original = new byte[width * height * 2];  // 16-bit
               var random = new Random(42);
               random.NextBytes(original);

               var info = new Codecs.PixelDataInfo(width, height, 1, 16, 1, false, "MONOCHROME2");

               // Encode lossless
               var fragments = _losslessCodec.Encode(original, info);

               // Decode
               var decoded = new byte[original.Length];
               var result = _losslessCodec.Decode(fragments, info, 0, decoded);

               Assert.That(result.Success, Is.True);

               // Lossless should be exact match
               Assert.That(decoded, Is.EqualTo(original));
           }

           [Test]
           public void ResolutionLevelDecode_ProducesSmaller()
           {
               var width = 256;
               var height = 256;
               var original = new byte[width * height];

               var info = new Codecs.PixelDataInfo(width, height, 1, 8, 1, false, "MONOCHROME2");
               var fragments = _losslessCodec.Encode(original, info);

               // Decode at resolution level 1 (half size)
               var options = new Jpeg2000DecodeOptions { ResolutionLevel = 1 };
               var halfSize = new byte[128 * 128];

               // Note: Full implementation would return actual decoded dimensions
               // This is a placeholder test structure
               Assert.Pass("Resolution level decode structure in place");
           }

           [Test]
           public void GpuDecode_WhenAvailable_UsesGpu()
           {
               if (!NativeCodecs.GpuAvailable)
               {
                   Assert.Ignore("GPU not available");
               }

               var width = 512;
               var height = 512;
               var original = new byte[width * height * 2];

               var info = new Codecs.PixelDataInfo(width, height, 1, 16, 1, false, "MONOCHROME2");
               var fragments = _losslessCodec.Encode(original, info);

               // GPU decode
               var decoded = new byte[original.Length];
               var result = _losslessCodec.Decode(fragments, info, 0, decoded);

               Assert.That(result.Success, Is.True);
           }
       }
   }
   ```

4. Add test project to solution:
   ```bash
   dotnet sln SharpDicom.sln add tests/SharpDicom.Codecs.Tests/SharpDicom.Codecs.Tests.csproj
   ```
  </action>
  <verify>
```bash
dotnet test /Users/jas88/Developer/Github/SharpDicom/tests/SharpDicom.Codecs.Tests/SharpDicom.Codecs.Tests.csproj --filter "Category!=Native" --no-build
```
Non-native tests pass (native tests skipped if library unavailable)
  </verify>
  <done>
Codec-specific tests cover decode, encode, roundtrip, and GPU acceleration
  </done>
</task>

</tasks>

<verification>
- [ ] tests/SharpDicom.Codecs.Tests/SharpDicom.Codecs.Tests.csproj builds
- [ ] NativeCodecsTests validates initialization and feature detection
- [ ] CodecRegistryPriorityTests validates priority-based registration
- [ ] NativeJpegCodecTests validates JPEG decode/encode
- [ ] NativeJpeg2000CodecTests validates J2K lossless/lossy
- [ ] Tests gracefully skip when native library unavailable
- [ ] GPU tests skip when GPU unavailable
- [ ] TestData/README.md documents required test files
</verification>

<success_criteria>
- Test project compiles and runs
- Priority registration works correctly
- Codec decode/encode operations are tested
- Tests are properly categorized (Native vs non-Native)
- Tests skip gracefully when prerequisites unavailable
- Roundtrip tests verify data integrity
</success_criteria>

<output>
After completion, create `.planning/phases/13-native-codecs-package/13-09-SUMMARY.md`
</output>
