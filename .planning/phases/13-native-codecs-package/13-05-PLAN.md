---
phase: 13-native-codecs-package
plan: 05
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - native/cuda/nvjpeg2k_wrapper.h
  - native/cuda/nvjpeg2k_wrapper.c
  - native/src/gpu_wrapper.h
  - native/src/gpu_wrapper.c
  - native/src/sharpdicom_codecs.c
  - native/cuda/CMakeLists.txt
autonomous: true

must_haves:
  truths:
    - "GPU availability detection works on NVIDIA systems"
    - "nvJPEG2000 decode produces correct pixel data when available"
    - "Fallback to CPU works when GPU unavailable"
  artifacts:
    - path: "native/src/gpu_wrapper.c"
      provides: "GPU detection and dispatch implementation"
      exports: ["gpu_available", "gpu_j2k_decode"]
      min_lines: 100
    - path: "native/cuda/nvjpeg2k_wrapper.c"
      provides: "nvJPEG2000 wrapper (built separately with nvcc)"
      min_lines: 80
  key_links:
    - from: "native/src/gpu_wrapper.c"
      to: "native/cuda/nvjpeg2k_wrapper.c"
      via: "dynamic loading or static link"
      pattern: "nvjpeg2k"
---

<objective>
Implement GPU acceleration wrapper for JPEG 2000 using nvJPEG2000

Purpose: Provide NVIDIA GPU-accelerated JPEG 2000 decode that automatically falls back to CPU when GPU is unavailable. Enables significant speedup for batch decode operations.

Output: GPU wrapper with nvJPEG2000 integration and CPU fallback
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-native-codecs-package/13-CONTEXT.md
@.planning/phases/13-native-codecs-package/13-RESEARCH.md
@.planning/phases/13-native-codecs-package/13-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create nvJPEG2000 wrapper (CUDA)</name>
  <files>
    native/cuda/nvjpeg2k_wrapper.h
    native/cuda/nvjpeg2k_wrapper.c
    native/cuda/CMakeLists.txt
  </files>
  <action>
1. Create `native/cuda/nvjpeg2k_wrapper.h`:
   - Include guard and extern "C"
   - Function declarations for CUDA-specific wrapper:
     ```c
     // Initialize CUDA context and nvJPEG2000
     int nvj2k_init(void);

     // Check if CUDA/nvJPEG2000 is available
     int nvj2k_available(void);

     // Get CUDA device info
     int nvj2k_get_device_info(char* name, int nameLen, int* computeCapability);

     // Decode single frame
     int nvj2k_decode(
         const uint8_t* input, int inputLen,
         uint8_t* output, int outputLen,
         int* width, int* height, int* components, int* bitsPerSample);

     // Batch decode multiple frames (optimized for GPU)
     int nvj2k_decode_batch(
         const uint8_t** inputs, const int* inputLens, int count,
         uint8_t** outputs, const int* outputLens,
         int* widths, int* heights);

     // Cleanup
     void nvj2k_shutdown(void);
     ```

2. Create `native/cuda/nvjpeg2k_wrapper.c`:
   - Include nvjpeg2k.h, cuda_runtime.h
   - Static state:
     ```c
     static nvjpeg2kHandle_t g_handle = NULL;
     static nvjpeg2kDecodeState_t g_state = NULL;
     static cudaStream_t g_stream = NULL;
     static int g_initialized = 0;
     ```
   - nvj2k_init():
     - cudaGetDeviceCount() to verify CUDA devices
     - cudaSetDevice(0)
     - Check compute capability >= 5.0 (Maxwell+)
     - nvjpeg2kCreate(NVJPEG2K_BACKEND_DEFAULT, NULL, &g_handle)
     - nvjpeg2kDecodeStateCreate(g_handle, &g_state)
     - cudaStreamCreate(&g_stream)
   - nvj2k_available():
     - Return g_initialized
   - nvj2k_decode():
     - nvjpeg2kStreamCreate()
     - nvjpeg2kStreamParse() to parse input
     - Allocate device memory for output
     - nvjpeg2kDecode() to decode
     - cudaMemcpy() device -> host
     - nvjpeg2kStreamDestroy()
   - nvj2k_decode_batch():
     - Parse all streams first
     - Allocate batch output buffers
     - nvjpeg2kDecodeBatched() for efficient batch decode
     - Copy all results to host
   - nvj2k_shutdown():
     - nvjpeg2kDecodeStateDestroy()
     - nvjpeg2kDestroy()
     - cudaStreamDestroy()

3. Create `native/cuda/CMakeLists.txt`:
   - Require CUDA 11.0+
   - Find nvJPEG2000 library
   - Build shared library nvjpeg2k_wrapper.so
   ```cmake
   cmake_minimum_required(VERSION 3.18)
   project(nvjpeg2k_wrapper LANGUAGES C CUDA)

   find_package(CUDAToolkit REQUIRED)

   add_library(nvjpeg2k_wrapper SHARED nvjpeg2k_wrapper.c)
   target_link_libraries(nvjpeg2k_wrapper PRIVATE CUDA::cudart nvjpeg2k)
   target_include_directories(nvjpeg2k_wrapper PRIVATE ${CUDAToolkit_INCLUDE_DIRS})
   set_target_properties(nvjpeg2k_wrapper PROPERTIES
       CUDA_ARCHITECTURES "50;60;70;80;90"
       POSITION_INDEPENDENT_CODE ON)
   ```

4. Update `.github/workflows/native-build.yml` to add CUDA job:
   ```yaml
   build-cuda:
     runs-on: ubuntu-latest
     container:
       image: nvidia/cuda:12.4-devel-ubuntu22.04
     steps:
       - uses: actions/checkout@v4
       - name: Build CUDA wrapper
         run: |
           apt-get update && apt-get install -y cmake libnvjpeg2k0-dev
           cd native/cuda
           cmake -B build
           cmake --build build
       - uses: actions/upload-artifact@v4
         with:
           name: cuda-libs
           path: native/cuda/build/*.so
   ```
  </action>
  <verify>
```bash
ls /Users/jas88/Developer/Github/SharpDicom/native/cuda/nvjpeg2k_wrapper.c
ls /Users/jas88/Developer/Github/SharpDicom/native/cuda/CMakeLists.txt
```
CUDA wrapper and CMake build exist
  </verify>
  <done>
nvJPEG2000 wrapper provides GPU-accelerated JPEG 2000 decode with batch support
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GPU dispatch wrapper</name>
  <files>
    native/src/gpu_wrapper.h
    native/src/gpu_wrapper.c
    native/src/sharpdicom_codecs.c
  </files>
  <action>
1. Create `native/src/gpu_wrapper.h`:
   - Include guard and extern "C"
   - GPU type enum:
     ```c
     typedef enum {
         GPU_NONE = 0,
         GPU_NVIDIA = 1,
         GPU_OPENCL = 2
     } gpu_type_t;
     ```
   - Function declarations:
     ```c
     // Check GPU availability
     int gpu_available(void);
     gpu_type_t gpu_get_type(void);
     int gpu_get_device_name(char* name, int nameLen);

     // GPU-accelerated JPEG 2000 decode
     int gpu_j2k_decode(
         const uint8_t* input, int inputLen,
         uint8_t* output, int outputLen,
         int* width, int* height, int* components, int* bitsPerSample);

     // Batch decode for multi-frame
     int gpu_j2k_decode_batch(
         const uint8_t** inputs, const int* inputLens, int count,
         uint8_t** outputs, const int* outputLens,
         int* widths, int* heights);

     // Force CPU for this thread (useful for testing)
     void gpu_prefer_cpu(int prefer);
     ```

2. Create `native/src/gpu_wrapper.c`:
   - Lazy-load nvJPEG2000 wrapper at runtime:
     ```c
     static void* g_nvj2k_lib = NULL;
     static int (*p_nvj2k_init)(void) = NULL;
     static int (*p_nvj2k_decode)(...) = NULL;
     // etc.

     static int load_nvjpeg2k(void) {
         g_nvj2k_lib = dlopen("nvjpeg2k_wrapper.so", RTLD_LAZY);
         if (!g_nvj2k_lib) return 0;
         p_nvj2k_init = dlsym(g_nvj2k_lib, "nvj2k_init");
         // etc.
         return p_nvj2k_init();
     }
     ```
   - gpu_available():
     - Try load_nvjpeg2k() if not already loaded
     - If nvJPEG2000 available, return 1
     - TODO: Add OpenCL fallback detection
     - Return 0 if no GPU
   - gpu_j2k_decode():
     - If nvJPEG2000 available, call p_nvj2k_decode()
     - Else fall back to j2k_decode() (CPU)
   - Thread-local prefer_cpu flag for testing

3. Update `native/src/sharpdicom_codecs.c`:
   - Include gpu_wrapper.h
   - Export gpu_available() and gpu_j2k_decode() functions
   - Update sharpdicom_features() to set GPU bit if available

4. Update `native/build.zig`:
   - Add gpu_wrapper.c to source files
   - Add -ldl for dynamic loading on Linux
   - Note: CUDA wrapper is built separately, loaded at runtime
  </action>
  <verify>
```bash
grep "gpu_available" /Users/jas88/Developer/Github/SharpDicom/native/src/gpu_wrapper.c
grep "dlopen" /Users/jas88/Developer/Github/SharpDicom/native/src/gpu_wrapper.c
```
GPU wrapper implements availability check and dynamic loading
  </verify>
  <done>
GPU dispatch wrapper provides runtime detection of NVIDIA GPU and fallback to CPU
  </done>
</task>

</tasks>

<verification>
- [ ] native/cuda/nvjpeg2k_wrapper.h declares nvJPEG2000 functions
- [ ] native/cuda/nvjpeg2k_wrapper.c implements CUDA integration
- [ ] native/cuda/CMakeLists.txt builds CUDA wrapper
- [ ] native/src/gpu_wrapper.h declares GPU dispatch API
- [ ] native/src/gpu_wrapper.c dynamically loads nvJPEG2000
- [ ] Fallback to CPU j2k_decode() when GPU unavailable
- [ ] Batch decode API available for multi-frame throughput
- [ ] CI workflow includes CUDA build job
</verification>

<success_criteria>
- nvJPEG2000 wrapper builds with CUDA toolkit
- GPU availability correctly detected at runtime
- GPU decode produces same results as CPU decode
- Fallback chain (nvJPEG2000 -> CPU) works correctly
- Batch API enables efficient multi-frame processing
</success_criteria>

<output>
After completion, create `.planning/phases/13-native-codecs-package/13-05-SUMMARY.md`
</output>
