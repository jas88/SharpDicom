---
phase: 13-native-codecs-package
plan: 07
type: execute
wave: 4
depends_on: ["13-06"]
files_modified:
  - src/SharpDicom.Codecs/Codecs/NativeJpegCodec.cs
  - src/SharpDicom.Codecs/Codecs/NativeJpeg2000Codec.cs
  - src/SharpDicom.Codecs/Codecs/NativeJpegLsCodec.cs
  - src/SharpDicom.Codecs/NativeCodecs.cs
  - src/SharpDicom/Codecs/CodecRegistry.cs
autonomous: true

must_haves:
  truths:
    - "Native codecs register with higher priority than pure C#"
    - "Native JPEG decode produces correct pixel data"
    - "CodecRegistry.GetCodec returns native codec when available"
  artifacts:
    - path: "src/SharpDicom.Codecs/Codecs/NativeJpegCodec.cs"
      provides: "Native JPEG IPixelDataCodec implementation"
      min_lines: 100
    - path: "src/SharpDicom.Codecs/Codecs/NativeJpeg2000Codec.cs"
      provides: "Native JPEG 2000 IPixelDataCodec implementation"
      min_lines: 100
    - path: "src/SharpDicom.Codecs/Codecs/NativeJpegLsCodec.cs"
      provides: "Native JPEG-LS IPixelDataCodec implementation"
      min_lines: 80
  key_links:
    - from: "src/SharpDicom.Codecs/NativeCodecs.cs"
      to: "src/SharpDicom/Codecs/CodecRegistry.cs"
      via: "CodecRegistry.Register"
      pattern: "CodecRegistry\\.Register"
---

<objective>
Implement IPixelDataCodec wrappers for native codecs

Purpose: Create managed codec classes that implement IPixelDataCodec interface, wrapping the native P/Invoke calls and handling memory management, error translation, and codec registration.

Output: NativeJpegCodec, NativeJpeg2000Codec, NativeJpegLsCodec classes that integrate with CodecRegistry
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-native-codecs-package/13-CONTEXT.md
@.planning/phases/13-native-codecs-package/13-06-SUMMARY.md
@src/SharpDicom/Codecs/IPixelDataCodec.cs
@src/SharpDicom/Codecs/CodecRegistry.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance CodecRegistry with priority support</name>
  <files>
    src/SharpDicom/Codecs/CodecRegistry.cs
  </files>
  <action>
Update CodecRegistry to support priority-based registration:

1. Add priority tracking dictionary:
   ```csharp
   private static Dictionary<TransferSyntax, int> _priorities = new();
   ```

2. Add Register overload with priority:
   ```csharp
   /// <summary>
   /// Registers a codec with specified priority. Higher priority wins.
   /// </summary>
   /// <param name="codec">The codec to register.</param>
   /// <param name="priority">Priority level (0=fallback, 50=pure C#, 100=native, 200=user).</param>
   public static void Register(IPixelDataCodec codec, int priority)
   {
       ThrowHelpers.ThrowIfNull(codec, nameof(codec));

       lock (_lock)
       {
           var key = codec.TransferSyntax;
           if (_priorities.TryGetValue(key, out var existing) && existing >= priority)
           {
               // Higher or equal priority already registered, skip
               return;
           }

           _mutableRegistry[key] = codec;
           _priorities[key] = priority;

           if (_isFrozen)
           {
               _frozenRegistry = null;
               _isFrozen = false;
           }
       }
   }
   ```

3. Modify existing Register(codec) to use default priority 50:
   ```csharp
   public static void Register(IPixelDataCodec codec)
   {
       Register(codec, priority: 50);
   }
   ```

4. Add GetCodecInfo method for debugging:
   ```csharp
   /// <summary>
   /// Gets information about the registered codec for a transfer syntax.
   /// </summary>
   public static CodecInfo? GetCodecInfo(TransferSyntax syntax)
   {
       var codec = GetCodec(syntax);
       if (codec == null) return null;

       lock (_lock)
       {
           _priorities.TryGetValue(syntax, out var priority);
           return new CodecInfo(codec.Name, priority, codec.GetType().Assembly.GetName().Name);
       }
   }

   public readonly record struct CodecInfo(string Name, int Priority, string? Assembly);
   ```

5. Update Reset() to also clear priorities:
   ```csharp
   public static void Reset()
   {
       lock (_lock)
       {
           _mutableRegistry = new Dictionary<TransferSyntax, IPixelDataCodec>();
           _priorities = new Dictionary<TransferSyntax, int>();
           _frozenRegistry = null;
           _isFrozen = false;
       }
   }
   ```
  </action>
  <verify>
```bash
grep -A5 "Register.*priority" /Users/jas88/Developer/Github/SharpDicom/src/SharpDicom/Codecs/CodecRegistry.cs
```
Priority-based registration is implemented
  </verify>
  <done>
CodecRegistry supports priority-based registration, allowing native codecs to override pure C#
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement native codec wrappers</name>
  <files>
    src/SharpDicom.Codecs/Codecs/NativeJpegCodec.cs
    src/SharpDicom.Codecs/Codecs/NativeJpeg2000Codec.cs
    src/SharpDicom.Codecs/Codecs/NativeJpegLsCodec.cs
    src/SharpDicom.Codecs/NativeCodecs.cs
  </files>
  <action>
1. Create `src/SharpDicom.Codecs/Codecs/NativeJpegCodec.cs`:
   ```csharp
   using System;
   using System.Runtime.InteropServices;
   using System.Threading;
   using System.Threading.Tasks;
   using SharpDicom.Codecs;
   using SharpDicom.Codecs.Native.Interop;
   using SharpDicom.Data;

   namespace SharpDicom.Codecs.Native
   {
       /// <summary>
       /// Native JPEG codec using libjpeg-turbo.
       /// </summary>
       public sealed class NativeJpegCodec : IPixelDataCodec
       {
           public TransferSyntax TransferSyntax => TransferSyntax.JpegBaselineProcess1;

           public string Name => "Native JPEG (libjpeg-turbo)";

           public CodecCapabilities Capabilities => new(
               canDecode: true,
               canEncode: true,
               supportsMultiFrame: true,
               supportsAsync: true);

           public unsafe DecodeResult Decode(
               DicomFragmentSequence fragments,
               Codecs.PixelDataInfo info,
               int frameIndex,
               Memory<byte> destination)
           {
               if (frameIndex < 0 || frameIndex >= fragments.Fragments.Count)
                   throw new ArgumentOutOfRangeException(nameof(frameIndex));

               var fragment = fragments.Fragments[frameIndex];
               using var fragmentHandle = fragment.Data.Pin();
               using var destHandle = destination.Pin();

               int width, height, components;
               int colorspace = info.PhotometricInterpretation switch
               {
                   "RGB" => 0,
                   "YBR_FULL" or "YBR_FULL_422" => 1,
                   _ => 2  // GRAY
               };

               int result = NativeMethods.jpeg_decode(
                   (byte*)fragmentHandle.Pointer, fragment.Data.Length,
                   (byte*)destHandle.Pointer, destination.Length,
                   out width, out height, out components,
                   colorspace);

               if (result < 0)
               {
                   return new DecodeResult(
                       success: false,
                       message: NativeCodecs.GetLastError(),
                       errorCode: result);
               }

               return DecodeResult.Success;
           }

           public ValueTask<DecodeResult> DecodeAsync(
               DicomFragmentSequence fragments,
               Codecs.PixelDataInfo info,
               int frameIndex,
               Memory<byte> destination,
               CancellationToken cancellationToken = default)
           {
               // Native decode is synchronous, wrap in task
               return new ValueTask<DecodeResult>(
                   Task.Run(() => Decode(fragments, info, frameIndex, destination), cancellationToken));
           }

           public unsafe DicomFragmentSequence Encode(
               ReadOnlySpan<byte> pixelData,
               Codecs.PixelDataInfo info,
               object? options = null)
           {
               var opts = options as JpegEncodeOptions ?? JpegEncodeOptions.Default;

               fixed (byte* input = pixelData)
               {
                   byte* output;
                   int outputLen;

                   int result = NativeMethods.jpeg_encode(
                       input, info.Width, info.Height, info.SamplesPerPixel,
                       out output, out outputLen,
                       opts.Quality, (int)opts.Subsampling);

                   if (result < 0)
                   {
                       throw new NativeCodecException("JPEG encode failed", result, NativeCodecs.GetLastError());
                   }

                   try
                   {
                       var data = new byte[outputLen];
                       Marshal.Copy((IntPtr)output, data, 0, outputLen);
                       return new DicomFragmentSequence(new[] { new DicomFragment(data) });
                   }
                   finally
                   {
                       NativeMethods.jpeg_free(output);
                   }
               }
           }

           public ValueTask<DicomFragmentSequence> EncodeAsync(
               ReadOnlyMemory<byte> pixelData,
               Codecs.PixelDataInfo info,
               object? options = null,
               CancellationToken cancellationToken = default)
           {
               return new ValueTask<DicomFragmentSequence>(
                   Task.Run(() => Encode(pixelData.Span, info, options), cancellationToken));
           }

           public ValidationResult ValidateCompressedData(DicomFragmentSequence fragments, Codecs.PixelDataInfo info)
           {
               // Check for JPEG SOI/EOI markers
               foreach (var fragment in fragments.Fragments)
               {
                   if (fragment.Data.Length < 2) continue;
                   var span = fragment.Data.Span;
                   if (span[0] != 0xFF || span[1] != 0xD8)  // SOI
                       return new ValidationResult(isValid: false, message: "Missing JPEG SOI marker");
               }
               return ValidationResult.Valid;
           }
       }

       public sealed class JpegEncodeOptions
       {
           public static readonly JpegEncodeOptions Default = new();
           public int Quality { get; init; } = 90;
           public JpegSubsampling Subsampling { get; init; } = JpegSubsampling.Yuv422;
       }

       public enum JpegSubsampling { Yuv444 = 0, Yuv422 = 1, Yuv420 = 2 }
   }
   ```

2. Create `src/SharpDicom.Codecs/Codecs/NativeJpeg2000Codec.cs`:
   - Similar structure to NativeJpegCodec
   - Handle TransferSyntax.Jpeg2000Lossless and Jpeg2000Lossy
   - Support resolution level decode via options
   - Support GPU acceleration via gpu_j2k_decode when available

3. Create `src/SharpDicom.Codecs/Codecs/NativeJpegLsCodec.cs`:
   - Similar structure to NativeJpegCodec
   - Handle TransferSyntax.JpegLs
   - Support near-lossless encode via options

4. Update `src/SharpDicom.Codecs/NativeCodecs.cs` RegisterCodecs method:
   ```csharp
   private static void RegisterCodecs(int features)
   {
       const int NativePriority = 100;

       if (EnableJpeg && (features & 0x01) != 0)  // SHARPDICOM_HAS_JPEG
       {
           CodecRegistry.Register(new NativeJpegCodec(), NativePriority);
           // Also register for extended JPEG transfer syntaxes
       }

       if (EnableJpeg2000 && (features & 0x02) != 0)  // SHARPDICOM_HAS_J2K
       {
           CodecRegistry.Register(new NativeJpeg2000Codec(TransferSyntax.Jpeg2000Lossless), NativePriority);
           CodecRegistry.Register(new NativeJpeg2000Codec(TransferSyntax.Jpeg2000Lossy), NativePriority);
       }

       if (EnableJpegLs && (features & 0x04) != 0)  // SHARPDICOM_HAS_JLS
       {
           CodecRegistry.Register(new NativeJpegLsCodec(), NativePriority);
       }
   }
   ```
  </action>
  <verify>
```bash
dotnet build /Users/jas88/Developer/Github/SharpDicom/src/SharpDicom.Codecs/SharpDicom.Codecs.csproj
grep "IPixelDataCodec" /Users/jas88/Developer/Github/SharpDicom/src/SharpDicom.Codecs/Codecs/NativeJpegCodec.cs
```
Project builds, codec implements interface
  </verify>
  <done>
Native codec wrappers implement IPixelDataCodec, integrate with CodecRegistry at priority 100
  </done>
</task>

</tasks>

<verification>
- [ ] CodecRegistry.Register(codec, priority) works correctly
- [ ] Higher priority codecs override lower priority ones
- [ ] GetCodecInfo returns priority and assembly info
- [ ] NativeJpegCodec implements Decode/Encode with P/Invoke
- [ ] NativeJpeg2000Codec handles lossless and lossy transfer syntaxes
- [ ] NativeJpegLsCodec handles JPEG-LS transfer syntax
- [ ] GPU acceleration is used for J2K when available
- [ ] Error messages propagate from native to managed
- [ ] All codec classes compile without warnings
</verification>

<success_criteria>
- CodecRegistry supports priority-based override of codecs
- Native codecs register at priority 100 (above pure C# at 50)
- Decode operations produce correct pixel data via P/Invoke
- Encode operations produce valid compressed data
- GPU acceleration automatically used for J2K when available
- Error handling translates native errors to NativeCodecException
</success_criteria>

<output>
After completion, create `.planning/phases/13-native-codecs-package/13-07-SUMMARY.md`
</output>
