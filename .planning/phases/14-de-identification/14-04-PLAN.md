---
phase: 14-de-identification
plan: 04
type: execute
wave: 2
depends_on: ["14-02"]
files_modified:
  - src/SharpDicom/Deidentification/DateShifter.cs
  - src/SharpDicom/Deidentification/DateShiftConfig.cs
  - src/SharpDicom/Deidentification/DateShiftResult.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Dates are shifted by configurable offset"
    - "Temporal relationships preserved within study"
    - "DA, TM, DT VRs all handled correctly"
    - "Same offset applied across all dates for a patient/study"
  artifacts:
    - path: "src/SharpDicom/Deidentification/DateShifter.cs"
      provides: "Date/time shifting implementation"
      exports: ["DateShifter", "ShiftDates"]
    - path: "src/SharpDicom/Deidentification/DateShiftConfig.cs"
      provides: "Configuration for date shifting strategies"
      exports: ["DateShiftConfig", "DateShiftStrategy"]
  key_links:
    - from: "DateShifter.cs"
      to: "DicomVR"
      via: "VR-specific date parsing and formatting"
      pattern: "DicomVR\\.DA|DicomVR\\.TM|DicomVR\\.DT"
---

<objective>
Implement date/time shifting with configurable strategies and temporal relationship preservation.

Purpose: De-identify temporal data while maintaining clinical utility for longitudinal analysis
Output: DateShifter that applies consistent offsets across patient/study datasets
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-de-identification/14-RESEARCH.md
@src/SharpDicom/Data/DicomVR.cs
@src/SharpDicom/Data/DicomDataset.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create date shift configuration and strategy types</name>
  <files>
    src/SharpDicom/Deidentification/DateShiftConfig.cs
    src/SharpDicom/Deidentification/DateShiftStrategy.cs
  </files>
  <action>
Create DateShiftStrategy enum:
```csharp
namespace SharpDicom.Deidentification;

/// <summary>Strategy for date/time shifting.</summary>
public enum DateShiftStrategy
{
    /// <summary>Apply a fixed offset to all dates.</summary>
    FixedOffset,

    /// <summary>Apply a random offset within range, consistent per patient.</summary>
    RandomPerPatient,

    /// <summary>Remove time component, keep date only.</summary>
    RemoveTime,

    /// <summary>Remove date entirely (replace with dummy).</summary>
    Remove
}
```

Create DateShiftConfig:
```csharp
public sealed class DateShiftConfig
{
    /// <summary>The shifting strategy to use.</summary>
    public DateShiftStrategy Strategy { get; init; } = DateShiftStrategy.FixedOffset;

    /// <summary>Fixed offset to apply (for FixedOffset strategy).</summary>
    public TimeSpan FixedOffset { get; init; } = TimeSpan.FromDays(-100);

    /// <summary>Minimum offset for random strategy.</summary>
    public TimeSpan MinOffset { get; init; } = TimeSpan.FromDays(-365);

    /// <summary>Maximum offset for random strategy.</summary>
    public TimeSpan MaxOffset { get; init; } = TimeSpan.FromDays(365);

    /// <summary>Whether to preserve time-of-day when shifting dates.</summary>
    public bool PreserveTimeOfDay { get; init; } = true;

    /// <summary>Whether to shift DA (date) values.</summary>
    public bool ShiftDates { get; init; } = true;

    /// <summary>Whether to shift TM (time) values.</summary>
    public bool ShiftTimes { get; init; } = false;

    /// <summary>Whether to shift DT (datetime) values.</summary>
    public bool ShiftDateTimes { get; init; } = true;

    /// <summary>Seed for random offset generation (for reproducibility).</summary>
    public int? RandomSeed { get; init; }

    // Presets
    public static DateShiftConfig Default { get; } = new();

    public static DateShiftConfig Research { get; } = new()
    {
        Strategy = DateShiftStrategy.RandomPerPatient,
        MinOffset = TimeSpan.FromDays(-365),
        MaxOffset = TimeSpan.FromDays(365)
    };

    public static DateShiftConfig ClinicalTrial { get; } = new()
    {
        Strategy = DateShiftStrategy.FixedOffset,
        FixedOffset = TimeSpan.Zero,  // Keep dates, just clean time
        PreserveTimeOfDay = false
    };
}
```

Create IDateOffsetStore interface for persistent random offsets:
```csharp
public interface IDateOffsetStore
{
    /// <summary>Gets or creates a date offset for the given patient ID.</summary>
    TimeSpan GetOrCreateOffset(string patientId, TimeSpan minOffset, TimeSpan maxOffset, int? seed);

    /// <summary>Tries to get existing offset for patient.</summary>
    bool TryGetOffset(string patientId, out TimeSpan offset);
}

public sealed class InMemoryDateOffsetStore : IDateOffsetStore
{
    private readonly ConcurrentDictionary<string, TimeSpan> _offsets = new();
    private readonly Random _random;

    public InMemoryDateOffsetStore(int? seed = null)
    {
        _random = seed.HasValue ? new Random(seed.Value) : new Random();
    }

    public TimeSpan GetOrCreateOffset(string patientId, TimeSpan minOffset, TimeSpan maxOffset, int? seed)
    {
        return _offsets.GetOrAdd(patientId, _ =>
        {
            var range = (maxOffset - minOffset).TotalDays;
            var offsetDays = minOffset.TotalDays + (_random.NextDouble() * range);
            return TimeSpan.FromDays(offsetDays);
        });
    }

    public bool TryGetOffset(string patientId, out TimeSpan offset)
        => _offsets.TryGetValue(patientId, out offset);
}
```
  </action>
  <verify>
Build succeeds: `dotnet build src/SharpDicom`
  </verify>
  <done>
DateShiftStrategy enum with all strategies
DateShiftConfig with presets
IDateOffsetStore for persistent patient offsets
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DateShifter implementation</name>
  <files>
    src/SharpDicom/Deidentification/DateShifter.cs
    src/SharpDicom/Deidentification/DateShiftResult.cs
  </files>
  <action>
Create DateShifter:
```csharp
public sealed class DateShifter
{
    private readonly DateShiftConfig _config;
    private readonly IDateOffsetStore? _offsetStore;

    // Tags containing dates that should be shifted
    private static readonly HashSet<DicomTag> DateTags = new()
    {
        DicomTag.StudyDate,
        DicomTag.SeriesDate,
        DicomTag.AcquisitionDate,
        DicomTag.ContentDate,
        DicomTag.PatientBirthDate,
        // ... all DA VR tags from PS3.15
    };

    private static readonly HashSet<DicomTag> TimeTags = new()
    {
        DicomTag.StudyTime,
        DicomTag.SeriesTime,
        DicomTag.AcquisitionTime,
        DicomTag.ContentTime,
        // ... all TM VR tags from PS3.15
    };

    private static readonly HashSet<DicomTag> DateTimeTags = new()
    {
        DicomTag.AcquisitionDateTime,
        DicomTag.InstanceCreationDateTime,
        // ... all DT VR tags from PS3.15
    };

    public DateShifter(DateShiftConfig? config = null, IDateOffsetStore? offsetStore = null)
    {
        _config = config ?? DateShiftConfig.Default;
        _offsetStore = offsetStore ?? new InMemoryDateOffsetStore(_config.RandomSeed);
    }

    /// <summary>
    /// Shifts all dates in the dataset according to configuration.
    /// </summary>
    public DateShiftResult ShiftDates(DicomDataset dataset, string? patientId = null)
    {
        var result = new DateShiftResult();

        // Get the offset for this patient
        var offset = GetOffset(patientId ?? GetPatientId(dataset));
        result.AppliedOffset = offset;

        // Process top-level elements
        foreach (var element in dataset.ToList())
        {
            ProcessElement(dataset, element, offset, result);
        }

        return result;
    }

    private TimeSpan GetOffset(string patientId)
    {
        return _config.Strategy switch
        {
            DateShiftStrategy.FixedOffset => _config.FixedOffset,
            DateShiftStrategy.RandomPerPatient =>
                _offsetStore!.GetOrCreateOffset(patientId, _config.MinOffset, _config.MaxOffset, _config.RandomSeed),
            DateShiftStrategy.RemoveTime => TimeSpan.Zero,
            DateShiftStrategy.Remove => TimeSpan.Zero,
            _ => _config.FixedOffset
        };
    }

    private void ProcessElement(DicomDataset dataset, IDicomElement element, TimeSpan offset, DateShiftResult result)
    {
        // Handle DA (Date)
        if (_config.ShiftDates && element.VR == DicomVR.DA)
        {
            if (TryShiftDate(element, offset, out var newElement))
            {
                dataset[element.Tag] = newElement;
                result.DatesShifted++;
            }
        }

        // Handle TM (Time)
        if (_config.ShiftTimes && element.VR == DicomVR.TM)
        {
            if (TryShiftTime(element, offset, out var newElement))
            {
                dataset[element.Tag] = newElement;
                result.TimesShifted++;
            }
        }

        // Handle DT (DateTime)
        if (_config.ShiftDateTimes && element.VR == DicomVR.DT)
        {
            if (TryShiftDateTime(element, offset, out var newElement))
            {
                dataset[element.Tag] = newElement;
                result.DateTimesShifted++;
            }
        }

        // Handle sequences recursively
        if (element is DicomSequence seq)
        {
            foreach (var item in seq.Items)
            {
                ShiftDates(item);  // Recursive - same offset
            }
        }
    }

    private bool TryShiftDate(IDicomElement element, TimeSpan offset, out IDicomElement newElement)
    {
        newElement = element;

        if (element is not DicomStringElement strElem)
            return false;

        var dateStr = strElem.GetString()?.Trim();
        if (string.IsNullOrEmpty(dateStr))
            return false;

        // Handle RemoveTime strategy - just return dummy date
        if (_config.Strategy == DateShiftStrategy.Remove)
        {
            newElement = new DicomStringElement(element.Tag, DicomVR.DA, "19000101");
            return true;
        }

        // Parse YYYYMMDD format
        if (!TryParseDA(dateStr, out var date))
            return false;

        var shifted = date.Add(offset);
        var newDateStr = shifted.ToString("yyyyMMdd");

        newElement = new DicomStringElement(element.Tag, DicomVR.DA, newDateStr);
        return true;
    }

    private bool TryShiftTime(IDicomElement element, TimeSpan offset, out IDicomElement newElement)
    {
        // Similar implementation for TM (HHMMSS.FFFFFF)
        // ...
    }

    private bool TryShiftDateTime(IDicomElement element, TimeSpan offset, out IDicomElement newElement)
    {
        // Similar implementation for DT (YYYYMMDDHHMMSS.FFFFFF&ZZXX)
        // Preserve timezone offset
        // ...
    }

    private static bool TryParseDA(string value, out DateTime date)
    {
        date = default;
        if (value.Length < 8) return false;

        return DateTime.TryParseExact(
            value.Substring(0, 8),
            "yyyyMMdd",
            CultureInfo.InvariantCulture,
            DateTimeStyles.None,
            out date);
    }

    private static string? GetPatientId(DicomDataset dataset)
        => dataset.GetString(DicomTag.PatientID);
}
```

Create DateShiftResult:
```csharp
public sealed class DateShiftResult
{
    public TimeSpan AppliedOffset { get; set; }
    public int DatesShifted { get; set; }
    public int TimesShifted { get; set; }
    public int DateTimesShifted { get; set; }
    public List<string> Warnings { get; } = new();

    public int TotalShifted => DatesShifted + TimesShifted + DateTimesShifted;
}
```
  </action>
  <verify>
Build succeeds: `dotnet build src/SharpDicom`
  </verify>
  <done>
DateShifter applies offsets to DA, TM, DT VRs
Strategy selection works (fixed, random, remove)
Sequences handled recursively
DateShiftResult captures statistics
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests for date shifting</name>
  <files>
    tests/SharpDicom.Tests/Deidentification/DateShifterTests.cs
  </files>
  <action>
Create comprehensive DateShifter tests:

```csharp
[TestFixture]
public class DateShifterTests
{
    [Test]
    public void ShiftDates_FixedOffset_ShiftsAllDates()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.StudyDate, "20240115" },
            { DicomTag.SeriesDate, "20240115" },
            { DicomTag.PatientBirthDate, "19800520" }
        };

        var config = new DateShiftConfig
        {
            Strategy = DateShiftStrategy.FixedOffset,
            FixedOffset = TimeSpan.FromDays(-100)
        };
        var shifter = new DateShifter(config);

        var result = shifter.ShiftDates(dataset);

        Assert.That(dataset.GetString(DicomTag.StudyDate), Is.EqualTo("20231007"));
        Assert.That(result.DatesShifted, Is.EqualTo(3));
    }

    [Test]
    public void ShiftDates_RandomPerPatient_SamePatientSameOffset()
    {
        var config = new DateShiftConfig
        {
            Strategy = DateShiftStrategy.RandomPerPatient,
            RandomSeed = 12345
        };
        var offsetStore = new InMemoryDateOffsetStore(12345);
        var shifter = new DateShifter(config, offsetStore);

        var dataset1 = new DicomDataset
        {
            { DicomTag.PatientID, "PATIENT001" },
            { DicomTag.StudyDate, "20240115" }
        };
        var dataset2 = new DicomDataset
        {
            { DicomTag.PatientID, "PATIENT001" },
            { DicomTag.StudyDate, "20240215" }  // Different date
        };

        var result1 = shifter.ShiftDates(dataset1);
        var result2 = shifter.ShiftDates(dataset2);

        // Same patient should get same offset
        Assert.That(result1.AppliedOffset, Is.EqualTo(result2.AppliedOffset));
    }

    [Test]
    public void ShiftDates_PreservesTemporalOrder()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.PatientID, "PATIENT001" },
            { DicomTag.StudyDate, "20240101" },
            { DicomTag.SeriesDate, "20240102" },
            { DicomTag.AcquisitionDate, "20240103" }
        };

        var shifter = new DateShifter();
        shifter.ShiftDates(dataset);

        var studyDate = dataset.GetString(DicomTag.StudyDate);
        var seriesDate = dataset.GetString(DicomTag.SeriesDate);
        var acqDate = dataset.GetString(DicomTag.AcquisitionDate);

        // Order should be preserved
        Assert.That(string.Compare(studyDate, seriesDate) < 0);
        Assert.That(string.Compare(seriesDate, acqDate) < 0);
    }

    [Test]
    public void ShiftDates_HandlesSequences()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.StudyDate, "20240115" }
        };
        var seq = new DicomSequence(DicomTag.ReferencedStudySequence);
        seq.Items.Add(new DicomDataset
        {
            { DicomTag.StudyDate, "20230101" }
        });
        dataset.Add(seq);

        var shifter = new DateShifter();
        var result = shifter.ShiftDates(dataset);

        Assert.That(result.DatesShifted, Is.EqualTo(2));
    }

    [Test]
    public void ShiftDates_HandlesDT_PreservesTimezone()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.AcquisitionDateTime, "20240115120000.000000+0500" }
        };

        var config = new DateShiftConfig
        {
            FixedOffset = TimeSpan.FromDays(-10)
        };
        var shifter = new DateShifter(config);
        shifter.ShiftDates(dataset);

        var dt = dataset.GetString(DicomTag.AcquisitionDateTime);
        Assert.That(dt, Does.EndWith("+0500"));  // Timezone preserved
    }

    [Test]
    public void ShiftDates_RemoveStrategy_ReplacesWith19000101()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.PatientBirthDate, "19800520" }
        };

        var config = new DateShiftConfig { Strategy = DateShiftStrategy.Remove };
        var shifter = new DateShifter(config);
        shifter.ShiftDates(dataset);

        Assert.That(dataset.GetString(DicomTag.PatientBirthDate), Is.EqualTo("19000101"));
    }
}
```
  </action>
  <verify>
All tests pass: `dotnet test tests/SharpDicom.Tests --filter "DateShifter"`
  </verify>
  <done>
Fixed offset shifting works
Random per-patient strategy consistent
Temporal ordering preserved
Sequences handled recursively
DT timezone preservation works
All tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# Build
dotnet build src/SharpDicom

# Run date shifter tests
dotnet test tests/SharpDicom.Tests --filter "DateShifter"
```
</verification>

<success_criteria>
- DateShifter applies configurable offsets to DA, TM, DT VRs
- Fixed offset strategy shifts all dates uniformly
- Random per-patient strategy maintains consistency
- Temporal relationships preserved within study
- DT timezone offsets preserved
- Sequences processed recursively
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-de-identification/14-04-SUMMARY.md`
</output>
