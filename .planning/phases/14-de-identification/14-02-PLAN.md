---
phase: 14-de-identification
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SharpDicom/Deidentification/DeidentificationAction.cs
  - src/SharpDicom/Deidentification/DeidentificationOptions.cs
  - src/SharpDicom/Deidentification/ActionResolver.cs
  - src/SharpDicom/Deidentification/DummyValueGenerator.cs
  - src/SharpDicom/Deidentification/DeidentificationResult.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Action codes can be resolved to concrete operations"
    - "Compound actions resolve based on IOD type requirements"
    - "Dummy values are VR-appropriate"
    - "Options combine correctly with most-restrictive-wins semantics"
  artifacts:
    - path: "src/SharpDicom/Deidentification/DeidentificationAction.cs"
      provides: "Action code enum with metadata"
    - path: "src/SharpDicom/Deidentification/DeidentificationOptions.cs"
      provides: "Configuration for de-identification runs"
      exports: ["DeidentificationOptions"]
    - path: "src/SharpDicom/Deidentification/ActionResolver.cs"
      provides: "Resolves actions to concrete operations"
      exports: ["ResolveAction", "GetEffectiveAction"]
    - path: "src/SharpDicom/Deidentification/DummyValueGenerator.cs"
      provides: "Generates VR-appropriate dummy values"
      exports: ["GenerateDummy"]
  key_links:
    - from: "ActionResolver.cs"
      to: "DeidentificationOptions.cs"
      via: "options parameter determines action resolution"
      pattern: "DeidentificationOptions"
    - from: "DummyValueGenerator.cs"
      to: "DicomVR"
      via: "VR-specific value generation"
      pattern: "DicomVR\\."
---

<objective>
Create core de-identification types for action resolution, options configuration, and dummy value generation.

Purpose: Provide runtime infrastructure for applying de-identification actions to datasets
Output: Types that translate action codes into concrete dataset modifications
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-de-identification/14-RESEARCH.md
@src/SharpDicom/Data/DicomVR.cs
@src/SharpDicom/Data/DicomVRInfo.cs
@src/SharpDicom/Data/DicomDataset.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create action types and options</name>
  <files>
    src/SharpDicom/Deidentification/DeidentificationAction.cs
    src/SharpDicom/Deidentification/ResolvedAction.cs
    src/SharpDicom/Deidentification/DeidentificationOptions.cs
  </files>
  <action>
Create DeidentificationAction enum (if not already generated):
```csharp
namespace SharpDicom.Deidentification;

/// <summary>Action codes from PS3.15 Table E.1-1a.</summary>
public enum DeidentificationAction
{
    /// <summary>Keep unchanged (K).</summary>
    Keep,
    /// <summary>Remove attribute (X).</summary>
    Remove,
    /// <summary>Replace with zero-length or dummy (Z).</summary>
    ZeroOrDummy,
    /// <summary>Replace with non-zero dummy (D).</summary>
    Dummy,
    /// <summary>Clean - replace with safe similar meaning (C).</summary>
    Clean,
    /// <summary>Replace with consistent UID (U).</summary>
    RemapUid,
    /// <summary>Z unless D required for Type 2 vs Type 1 (Z/D).</summary>
    ZeroOrDummyConditional,
    /// <summary>X unless Z required for Type 3 vs Type 2 (X/Z).</summary>
    RemoveOrZeroConditional,
    /// <summary>X unless D required for Type 3 vs Type 1 (X/D).</summary>
    RemoveOrDummyConditional,
    /// <summary>X unless Z or D required (X/Z/D).</summary>
    RemoveOrZeroOrDummyConditional,
    /// <summary>X unless Z or U required for UID sequences (X/Z/U*).</summary>
    RemoveOrZeroOrUidConditional
}
```

Create ResolvedAction enum (concrete operations):
```csharp
public enum ResolvedAction
{
    Keep,
    Remove,
    ReplaceWithEmpty,
    ReplaceWithDummy,
    Clean,
    RemapUid
}
```

Create DeidentificationOptions:
```csharp
public sealed class DeidentificationOptions
{
    // Profile options (flags)
    public bool RetainSafePrivate { get; init; }
    public bool RetainUIDs { get; init; }
    public bool RetainDeviceIdentity { get; init; }
    public bool RetainInstitutionIdentity { get; init; }
    public bool RetainPatientCharacteristics { get; init; }
    public bool RetainLongitudinalFullDates { get; init; }
    public bool RetainLongitudinalModifiedDates { get; init; }
    public bool CleanDescriptors { get; init; }
    public bool CleanStructuredContent { get; init; }
    public bool CleanGraphics { get; init; }

    // Private tag handling
    public PrivateTagAction DefaultPrivateTagAction { get; init; } = PrivateTagAction.Remove;
    public IReadOnlySet<string>? SafePrivateCreators { get; init; }

    // Unknown tag handling
    public bool RemoveUnknownTags { get; init; } = true;

    // Tag overrides (user-specified actions)
    public IReadOnlyDictionary<DicomTag, DeidentificationAction>? Overrides { get; init; }

    // Presets
    public static DeidentificationOptions BasicProfile { get; } = new();
    public static DeidentificationOptions Research { get; } = new()
    {
        RetainPatientCharacteristics = true,
        CleanDescriptors = true
    };
    public static DeidentificationOptions ClinicalTrial { get; } = new()
    {
        RetainLongitudinalModifiedDates = true,
        CleanDescriptors = true
    };
}

public enum PrivateTagAction { Keep, Remove }
```
  </action>
  <verify>
Build succeeds: `dotnet build src/SharpDicom`
  </verify>
  <done>
DeidentificationAction enum defined with all PS3.15 action codes
ResolvedAction enum for concrete operations
DeidentificationOptions with all profile flags and presets
  </done>
</task>

<task type="auto">
  <name>Task 2: Create action resolver</name>
  <files>
    src/SharpDicom/Deidentification/ActionResolver.cs
  </files>
  <action>
Create ActionResolver static class:
```csharp
public static class ActionResolver
{
    /// <summary>
    /// Gets the effective action for a tag given options.
    /// Applies option overrides and resolves compound actions.
    /// </summary>
    public static DeidentificationAction GetEffectiveAction(
        DicomTag tag,
        DeidentificationOptions options)
    {
        // 1. Check user overrides first
        if (options.Overrides?.TryGetValue(tag, out var overrideAction) == true)
            return overrideAction;

        // 2. Get base action from generated profiles
        var baseAction = DeidentificationProfiles.GetAction(tag, options);

        // 3. Apply option overrides (retention options change X to K)
        return ApplyOptionOverrides(tag, baseAction, options);
    }

    /// <summary>
    /// Resolves a compound action to a concrete operation.
    /// </summary>
    public static ResolvedAction ResolveAction(
        DeidentificationAction action,
        DicomAttributeType attributeType = DicomAttributeType.Type3)
    {
        return action switch
        {
            DeidentificationAction.Keep => ResolvedAction.Keep,
            DeidentificationAction.Remove => ResolvedAction.Remove,
            DeidentificationAction.ZeroOrDummy => ResolvedAction.ReplaceWithEmpty,
            DeidentificationAction.Dummy => ResolvedAction.ReplaceWithDummy,
            DeidentificationAction.Clean => ResolvedAction.Clean,
            DeidentificationAction.RemapUid => ResolvedAction.RemapUid,

            // Compound actions - resolve based on attribute type
            DeidentificationAction.ZeroOrDummyConditional => attributeType switch
            {
                DicomAttributeType.Type1 => ResolvedAction.ReplaceWithDummy,
                _ => ResolvedAction.ReplaceWithEmpty
            },
            DeidentificationAction.RemoveOrZeroConditional => attributeType switch
            {
                DicomAttributeType.Type2 => ResolvedAction.ReplaceWithEmpty,
                _ => ResolvedAction.Remove
            },
            // ... etc for other compound actions
        };
    }

    private static DeidentificationAction ApplyOptionOverrides(
        DicomTag tag,
        DeidentificationAction baseAction,
        DeidentificationOptions options)
    {
        // RetainUIDs: U -> K for UID tags
        if (options.RetainUIDs && baseAction == DeidentificationAction.RemapUid)
            return DeidentificationAction.Keep;

        // RetainLongitudinalFullDates: date actions -> K
        if (options.RetainLongitudinalFullDates && IsDateTimeTag(tag))
            return DeidentificationAction.Keep;

        // ... other option logic
        return baseAction;
    }
}

public enum DicomAttributeType { Type1, Type1C, Type2, Type2C, Type3 }
```

Handle most-restrictive-wins for conflicting options:
- X (remove) is most restrictive
- Z (zero) is medium
- K (keep) is least restrictive
- When options conflict, apply the more restrictive action
  </action>
  <verify>
Build succeeds: `dotnet build src/SharpDicom`
  </verify>
  <done>
ActionResolver.GetEffectiveAction combines profile with options
ActionResolver.ResolveAction handles all compound actions
Option overrides apply correctly (RetainUIDs makes U become K)
  </done>
</task>

<task type="auto">
  <name>Task 3: Create dummy value generator and result type</name>
  <files>
    src/SharpDicom/Deidentification/DummyValueGenerator.cs
    src/SharpDicom/Deidentification/DeidentificationResult.cs
    tests/SharpDicom.Tests/Deidentification/ActionResolverTests.cs
    tests/SharpDicom.Tests/Deidentification/DummyValueGeneratorTests.cs
  </files>
  <action>
Create DummyValueGenerator:
```csharp
public static class DummyValueGenerator
{
    /// <summary>
    /// Generates a VR-appropriate dummy value.
    /// </summary>
    public static object GenerateDummy(DicomVR vr, DicomTag? tag = null)
    {
        return vr.Code switch
        {
            // String VRs
            "AE" => "ANONYMOUS",
            "AS" => "000Y",
            "CS" => "ANON",
            "DA" => "19000101",
            "DS" => "0",
            "DT" => "19000101000000",
            "IS" => "0",
            "LO" => "Anonymous",
            "LT" => "Anonymous",
            "PN" => "Anonymous",
            "SH" => "Anonymous",
            "ST" => "Anonymous",
            "TM" => "000000",
            "UC" => "Anonymous",
            "UI" => GenerateUid(),  // New UID
            "UR" => "https://example.com",
            "UT" => "Anonymous",

            // Numeric VRs
            "FL" or "FD" => 0.0,
            "SL" or "SS" => 0,
            "UL" or "US" => 0u,
            "SV" => 0L,
            "UV" => 0UL,

            // Binary VRs - empty
            "OB" or "OD" or "OF" or "OL" or "OV" or "OW" or "UN" => Array.Empty<byte>(),

            // Sequence - empty
            "SQ" => Array.Empty<DicomDataset>(),

            _ => string.Empty
        };
    }

    /// <summary>
    /// Gets default dummy values that can be overridden per-tag.
    /// </summary>
    public static IReadOnlyDictionary<DicomTag, object> DefaultOverrides { get; } =
        new Dictionary<DicomTag, object>
        {
            [DicomTag.PatientName] = "Anonymous",
            [DicomTag.PatientID] = "ANON000",
            [DicomTag.InstitutionName] = "Anonymous Institution",
            // ... other sensible defaults
        };

    private static string GenerateUid()
    {
        var uuid = Guid.NewGuid();
        var bytes = uuid.ToByteArray();
        Array.Reverse(bytes);  // Big-endian for consistent decimal
        var value = new System.Numerics.BigInteger(bytes, isUnsigned: true);
        return $"2.25.{value}";
    }
}
```

Create DeidentificationResult:
```csharp
public sealed class DeidentificationResult
{
    public DicomDataset Dataset { get; }
    public DeidentificationSummary Summary { get; }
    public IReadOnlyList<DeidentificationWarning> Warnings { get; }
}

public sealed class DeidentificationSummary
{
    public int AttributesRemoved { get; init; }
    public int AttributesReplaced { get; init; }
    public int UidsRemapped { get; init; }
    public int DatesShifted { get; init; }
    public int SequencesCleaned { get; init; }
}

public readonly record struct DeidentificationWarning(
    DicomTag Tag,
    string Message,
    DeidentificationWarningSeverity Severity
);

public enum DeidentificationWarningSeverity { Info, Warning, Error }
```

Create tests:
- Test ActionResolver.ResolveAction for each compound action type
- Test DummyValueGenerator produces valid values for each VR
- Test option combinations resolve correctly
  </action>
  <verify>
All tests pass: `dotnet test tests/SharpDicom.Tests --filter "ActionResolver|DummyValue"`
  </verify>
  <done>
DummyValueGenerator produces VR-appropriate values
DeidentificationResult captures summary and warnings
All tests pass for action resolution and dummy generation
  </done>
</task>

</tasks>

<verification>
```bash
# Build
dotnet build src/SharpDicom

# Run tests
dotnet test tests/SharpDicom.Tests --filter "Deidentification"
```
</verification>

<success_criteria>
- DeidentificationAction enum covers all PS3.15 action codes
- DeidentificationOptions supports all profile flags
- ActionResolver correctly resolves compound actions
- DummyValueGenerator produces valid values for all VRs
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-de-identification/14-02-SUMMARY.md`
</output>
