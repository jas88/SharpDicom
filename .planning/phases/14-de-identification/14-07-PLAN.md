---
phase: 14-de-identification
plan: 07
type: execute
wave: 4
depends_on: ["14-05"]
files_modified:
  - src/SharpDicom/Deidentification/PixelDataRedactor.cs
  - src/SharpDicom/Deidentification/RedactionRegion.cs
  - src/SharpDicom/Deidentification/BurnedInAnnotationDetector.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Rectangular regions can be blacked out in pixel data"
    - "Multi-frame images handled correctly"
    - "High-risk modalities generate warnings"
    - "Clean Pixel Data Option supported"
  artifacts:
    - path: "src/SharpDicom/Deidentification/PixelDataRedactor.cs"
      provides: "Pixel data region redaction"
      exports: ["PixelDataRedactor", "RedactRegions"]
    - path: "src/SharpDicom/Deidentification/RedactionRegion.cs"
      provides: "Region specification for redaction"
      exports: ["RedactionRegion"]
    - path: "src/SharpDicom/Deidentification/BurnedInAnnotationDetector.cs"
      provides: "High-risk modality detection"
      exports: ["BurnedInAnnotationDetector", "DetectRisk"]
  key_links:
    - from: "PixelDataRedactor.cs"
      to: "DicomPixelDataElement.cs"
      via: "pixel data access and modification"
      pattern: "DicomPixelDataElement"
    - from: "DicomDeidentifier.cs"
      to: "PixelDataRedactor.cs"
      via: "Clean Pixel Data integration"
      pattern: "PixelDataRedactor"
---

<objective>
Implement Clean Pixel Data Option with region-based redaction for burned-in annotation removal.

Purpose: Remove patient identifying information embedded in pixel data (common in US, ES, SC modalities)
Output: PixelDataRedactor with configurable regions and high-risk modality detection
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-de-identification/14-RESEARCH.md
@src/SharpDicom/Data/DicomPixelDataElement.cs
@src/SharpDicom/Data/PixelDataInfo.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create redaction region types</name>
  <files>
    src/SharpDicom/Deidentification/RedactionRegion.cs
    src/SharpDicom/Deidentification/RedactionOptions.cs
  </files>
  <action>
Create RedactionRegion:
```csharp
namespace SharpDicom.Deidentification;

/// <summary>
/// Defines a rectangular region for pixel data redaction.
/// </summary>
public readonly struct RedactionRegion : IEquatable<RedactionRegion>
{
    /// <summary>X coordinate of the top-left corner (0-based).</summary>
    public int X { get; init; }

    /// <summary>Y coordinate of the top-left corner (0-based).</summary>
    public int Y { get; init; }

    /// <summary>Width of the region in pixels.</summary>
    public int Width { get; init; }

    /// <summary>Height of the region in pixels.</summary>
    public int Height { get; init; }

    /// <summary>
    /// Frame number to apply to (0-based). Null means all frames.
    /// </summary>
    public int? Frame { get; init; }

    /// <summary>
    /// Creates a region covering the top of the image.
    /// </summary>
    public static RedactionRegion TopBar(int height, int imageWidth)
        => new() { X = 0, Y = 0, Width = imageWidth, Height = height };

    /// <summary>
    /// Creates a region covering the bottom of the image.
    /// </summary>
    public static RedactionRegion BottomBar(int height, int imageWidth, int imageHeight)
        => new() { X = 0, Y = imageHeight - height, Width = imageWidth, Height = height };

    /// <summary>
    /// Creates a region covering the left side of the image.
    /// </summary>
    public static RedactionRegion LeftBar(int width, int imageHeight)
        => new() { X = 0, Y = 0, Width = width, Height = imageHeight };

    /// <summary>
    /// Creates a region covering the right side of the image.
    /// </summary>
    public static RedactionRegion RightBar(int width, int imageWidth, int imageHeight)
        => new() { X = imageWidth - width, Y = 0, Width = width, Height = imageHeight };

    /// <summary>
    /// Creates a region from corner coordinates.
    /// </summary>
    public static RedactionRegion FromCorners(int x1, int y1, int x2, int y2, int? frame = null)
        => new()
        {
            X = Math.Min(x1, x2),
            Y = Math.Min(y1, y2),
            Width = Math.Abs(x2 - x1),
            Height = Math.Abs(y2 - y1),
            Frame = frame
        };

    public bool Equals(RedactionRegion other)
        => X == other.X && Y == other.Y && Width == other.Width &&
           Height == other.Height && Frame == other.Frame;

    public override bool Equals(object? obj) => obj is RedactionRegion r && Equals(r);
    public override int GetHashCode() => HashCode.Combine(X, Y, Width, Height, Frame);
}
```

Create RedactionOptions:
```csharp
public sealed class RedactionOptions
{
    /// <summary>Regions to redact.</summary>
    public IReadOnlyList<RedactionRegion> Regions { get; init; } = Array.Empty<RedactionRegion>();

    /// <summary>
    /// Fill value for redacted pixels.
    /// For grayscale, this is the pixel value.
    /// For RGB, this is interpreted as (R << 16 | G << 8 | B).
    /// </summary>
    public uint FillValue { get; init; } = 0;  // Black

    /// <summary>Whether to update BurnedInAnnotation (0028,0301) tag.</summary>
    public bool UpdateBurnedInAnnotationTag { get; init; } = true;

    /// <summary>
    /// Predefined regions for common modality patterns.
    /// </summary>
    public static RedactionOptions UltrasoundDefault(int width, int height) => new()
    {
        Regions = new[]
        {
            RedactionRegion.TopBar(50, width),      // Top info bar
            RedactionRegion.BottomBar(30, width, height)  // Bottom bar
        }
    };

    public static RedactionOptions SecondaryCapture(int width, int height) => new()
    {
        Regions = new[]
        {
            // Corners often contain patient info
            new RedactionRegion { X = 0, Y = 0, Width = 200, Height = 50 },
            new RedactionRegion { X = width - 200, Y = 0, Width = 200, Height = 50 }
        }
    };
}
```
  </action>
  <verify>
Build succeeds: `dotnet build src/SharpDicom`
  </verify>
  <done>
RedactionRegion supports rectangular regions
Frame-specific regions supported
Factory methods for common patterns
RedactionOptions with fill value and modality presets
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PixelDataRedactor</name>
  <files>
    src/SharpDicom/Deidentification/PixelDataRedactor.cs
  </files>
  <action>
Create PixelDataRedactor:
```csharp
namespace SharpDicom.Deidentification;

/// <summary>
/// Redacts rectangular regions in pixel data for burned-in annotation removal.
/// </summary>
public sealed class PixelDataRedactor
{
    /// <summary>
    /// Redacts specified regions in the dataset's pixel data.
    /// </summary>
    public RedactionResult RedactRegions(DicomDataset dataset, RedactionOptions options)
    {
        var result = new RedactionResult();

        // Get pixel data info
        if (!dataset.TryGetPixelDataInfo(out var info))
        {
            result.Warnings.Add("No pixel data found in dataset");
            return result;
        }

        // Get pixel data element
        var pixelDataElement = dataset[DicomTag.PixelData];
        if (pixelDataElement is not DicomPixelDataElement pixelData)
        {
            result.Warnings.Add("Pixel data element is not accessible");
            return result;
        }

        // Validate regions against image dimensions
        ValidateRegions(options.Regions, info, result);

        // Determine number of frames
        var numberOfFrames = info.NumberOfFrames ?? 1;

        // Process each frame
        for (int frame = 0; frame < numberOfFrames; frame++)
        {
            var frameData = pixelData.GetFrame(frame);
            var modified = RedactFrame(frameData, info, options, frame, result);

            if (modified)
            {
                // Update the frame data
                pixelData.SetFrame(frame, frameData);
                result.FramesModified++;
            }
        }

        // Update Burned In Annotation tag
        if (options.UpdateBurnedInAnnotationTag && result.FramesModified > 0)
        {
            dataset.AddOrUpdate(DicomTag.BurnedInAnnotation, "NO");
        }

        return result;
    }

    private void ValidateRegions(IReadOnlyList<RedactionRegion> regions, PixelDataInfo info, RedactionResult result)
    {
        foreach (var region in regions)
        {
            if (region.X < 0 || region.Y < 0)
            {
                result.Warnings.Add($"Region has negative coordinates: ({region.X}, {region.Y})");
            }

            if (info.Columns.HasValue && region.X + region.Width > info.Columns.Value)
            {
                result.Warnings.Add($"Region extends beyond image width: X={region.X}, Width={region.Width}");
            }

            if (info.Rows.HasValue && region.Y + region.Height > info.Rows.Value)
            {
                result.Warnings.Add($"Region extends beyond image height: Y={region.Y}, Height={region.Height}");
            }
        }
    }

    private bool RedactFrame(
        Span<byte> frameData,
        PixelDataInfo info,
        RedactionOptions options,
        int frameIndex,
        RedactionResult result)
    {
        var modified = false;
        var columns = info.Columns ?? 0;
        var rows = info.Rows ?? 0;
        var bitsAllocated = info.BitsAllocated ?? 8;
        var samplesPerPixel = info.SamplesPerPixel ?? 1;
        var bytesPerSample = (bitsAllocated + 7) / 8;
        var bytesPerPixel = bytesPerSample * samplesPerPixel;
        var rowStride = columns * bytesPerPixel;

        foreach (var region in options.Regions)
        {
            // Skip if region is for a different frame
            if (region.Frame.HasValue && region.Frame.Value != frameIndex)
                continue;

            // Clamp region to image bounds
            var x1 = Math.Max(0, region.X);
            var y1 = Math.Max(0, region.Y);
            var x2 = Math.Min(columns, region.X + region.Width);
            var y2 = Math.Min(rows, region.Y + region.Height);

            if (x2 <= x1 || y2 <= y1)
                continue;

            // Fill the region with the specified value
            for (int y = y1; y < y2; y++)
            {
                var rowOffset = y * rowStride;

                for (int x = x1; x < x2; x++)
                {
                    var pixelOffset = rowOffset + (x * bytesPerPixel);

                    FillPixel(frameData, pixelOffset, options.FillValue, bytesPerSample, samplesPerPixel);
                }
            }

            result.RegionsRedacted++;
            modified = true;
        }

        return modified;
    }

    private static void FillPixel(Span<byte> data, int offset, uint fillValue, int bytesPerSample, int samplesPerPixel)
    {
        // Handle different bit depths
        if (bytesPerSample == 1)
        {
            // 8-bit
            var value = (byte)(fillValue & 0xFF);
            for (int s = 0; s < samplesPerPixel; s++)
            {
                data[offset + s] = value;
            }
        }
        else if (bytesPerSample == 2)
        {
            // 16-bit (little-endian)
            var value = (ushort)(fillValue & 0xFFFF);
            for (int s = 0; s < samplesPerPixel; s++)
            {
                var sampleOffset = offset + (s * 2);
                data[sampleOffset] = (byte)(value & 0xFF);
                data[sampleOffset + 1] = (byte)(value >> 8);
            }
        }
        else if (bytesPerSample == 4)
        {
            // 32-bit
            for (int s = 0; s < samplesPerPixel; s++)
            {
                var sampleOffset = offset + (s * 4);
                data[sampleOffset] = (byte)(fillValue & 0xFF);
                data[sampleOffset + 1] = (byte)((fillValue >> 8) & 0xFF);
                data[sampleOffset + 2] = (byte)((fillValue >> 16) & 0xFF);
                data[sampleOffset + 3] = (byte)((fillValue >> 24) & 0xFF);
            }
        }
    }
}

public sealed class RedactionResult
{
    public int RegionsRedacted { get; set; }
    public int FramesModified { get; set; }
    public List<string> Warnings { get; } = new();
}
```
  </action>
  <verify>
Build succeeds: `dotnet build src/SharpDicom`
  </verify>
  <done>
PixelDataRedactor fills rectangular regions with specified value
Multi-frame images handled (per-frame or all-frames)
8-bit, 16-bit, and 32-bit pixel depths supported
RGB/grayscale both handled
BurnedInAnnotation tag updated
  </done>
</task>

<task type="auto">
  <name>Task 3: Create burned-in annotation detector and tests</name>
  <files>
    src/SharpDicom/Deidentification/BurnedInAnnotationDetector.cs
    tests/SharpDicom.Tests/Deidentification/PixelDataRedactorTests.cs
  </files>
  <action>
Create BurnedInAnnotationDetector:
```csharp
namespace SharpDicom.Deidentification;

/// <summary>
/// Detects modalities with high risk of burned-in patient information.
/// </summary>
public static class BurnedInAnnotationDetector
{
    // Modalities with high burned-in PHI risk
    private static readonly HashSet<string> HighRiskModalities = new(StringComparer.OrdinalIgnoreCase)
    {
        "US",   // Ultrasound - very common
        "ES",   // Endoscopy
        "SC",   // Secondary Capture (screenshots)
        "XC",   // External-camera Photography
        "GM",   // General Microscopy
        "SM"    // Slide Microscopy
    };

    // Modalities with moderate risk
    private static readonly HashSet<string> ModerateRiskModalities = new(StringComparer.OrdinalIgnoreCase)
    {
        "XA",   // X-Ray Angiography
        "RF",   // Radio Fluoroscopy
        "MG",   // Mammography
        "DX",   // Digital Radiography
        "CR"    // Computed Radiography
    };

    /// <summary>
    /// Detects the burned-in annotation risk level for a dataset.
    /// </summary>
    public static BurnedInAnnotationRisk DetectRisk(DicomDataset dataset)
    {
        // Check existing BurnedInAnnotation tag (0028,0301)
        var burnedInTag = dataset.GetString(DicomTag.BurnedInAnnotation);
        if (burnedInTag?.Equals("YES", StringComparison.OrdinalIgnoreCase) == true)
        {
            return BurnedInAnnotationRisk.Confirmed;
        }

        // Check modality
        var modality = dataset.GetString(DicomTag.Modality);
        if (string.IsNullOrEmpty(modality))
        {
            return BurnedInAnnotationRisk.Unknown;
        }

        if (HighRiskModalities.Contains(modality))
        {
            return BurnedInAnnotationRisk.High;
        }

        if (ModerateRiskModalities.Contains(modality))
        {
            return BurnedInAnnotationRisk.Moderate;
        }

        // Check for secondary capture in ImageType
        var imageType = dataset.GetString(DicomTag.ImageType);
        if (imageType?.Contains("SECONDARY", StringComparison.OrdinalIgnoreCase) == true)
        {
            return BurnedInAnnotationRisk.High;
        }

        // Check for manufacturer notes about overlays
        // (Some manufacturers embed patient info despite BurnedInAnnotation = NO)

        return BurnedInAnnotationRisk.Low;
    }

    /// <summary>
    /// Gets a warning message for the given risk level.
    /// </summary>
    public static string GetWarningMessage(BurnedInAnnotationRisk risk, DicomDataset dataset)
    {
        var modality = dataset.GetString(DicomTag.Modality) ?? "Unknown";

        return risk switch
        {
            BurnedInAnnotationRisk.Confirmed =>
                $"BurnedInAnnotation tag indicates pixel data contains patient information.",
            BurnedInAnnotationRisk.High =>
                $"Modality {modality} commonly contains burned-in patient information. " +
                "Consider manual review or applying Clean Pixel Data Option.",
            BurnedInAnnotationRisk.Moderate =>
                $"Modality {modality} may contain burned-in annotations. Review recommended.",
            _ => string.Empty
        };
    }
}

public enum BurnedInAnnotationRisk
{
    Low,
    Moderate,
    High,
    Confirmed,
    Unknown
}
```

Create comprehensive tests:
```csharp
[TestFixture]
public class PixelDataRedactorTests
{
    [Test]
    public void RedactRegions_SingleRegion_FillsWithBlack()
    {
        // Create a simple 10x10 8-bit grayscale image, all white
        var pixelData = new byte[100];
        Array.Fill<byte>(pixelData, 255);

        var dataset = CreateTestDataset(10, 10, 8, 1, pixelData);

        var redactor = new PixelDataRedactor();
        var options = new RedactionOptions
        {
            Regions = new[] { new RedactionRegion { X = 2, Y = 2, Width = 3, Height = 3 } },
            FillValue = 0
        };

        var result = redactor.RedactRegions(dataset, options);

        // Verify the region is blacked out
        var modified = GetPixelData(dataset);
        Assert.That(modified[2 * 10 + 2], Is.EqualTo(0));  // (2,2)
        Assert.That(modified[4 * 10 + 4], Is.EqualTo(0));  // (4,4)
        Assert.That(modified[0], Is.EqualTo(255));         // (0,0) unchanged

        Assert.That(result.RegionsRedacted, Is.EqualTo(1));
    }

    [Test]
    public void RedactRegions_16Bit_FillsCorrectly()
    {
        // 4x4 16-bit image
        var pixelData = new byte[32];  // 4*4*2 bytes
        Array.Fill<byte>(pixelData, 0xFF);  // All max value

        var dataset = CreateTestDataset(4, 4, 16, 1, pixelData);

        var redactor = new PixelDataRedactor();
        var options = new RedactionOptions
        {
            Regions = new[] { new RedactionRegion { X = 0, Y = 0, Width = 2, Height = 2 } },
            FillValue = 0
        };

        redactor.RedactRegions(dataset, options);

        var modified = GetPixelData(dataset);
        // First 2x2 should be zeroed (4 pixels * 2 bytes)
        Assert.That(modified[0], Is.EqualTo(0));
        Assert.That(modified[1], Is.EqualTo(0));
    }

    [Test]
    public void RedactRegions_MultiFrame_RedactsAllFrames()
    {
        // 4x4 image with 2 frames
        var pixelData = new byte[32];  // 4*4*2 frames
        Array.Fill<byte>(pixelData, 255);

        var dataset = CreateTestDataset(4, 4, 8, 1, pixelData, numberOfFrames: 2);

        var redactor = new PixelDataRedactor();
        var options = new RedactionOptions
        {
            Regions = new[] { new RedactionRegion { X = 0, Y = 0, Width = 2, Height = 2 } }
        };

        var result = redactor.RedactRegions(dataset, options);

        Assert.That(result.FramesModified, Is.EqualTo(2));
    }

    [Test]
    public void RedactRegions_SpecificFrame_OnlyRedactsThatFrame()
    {
        var pixelData = new byte[32];
        Array.Fill<byte>(pixelData, 255);

        var dataset = CreateTestDataset(4, 4, 8, 1, pixelData, numberOfFrames: 2);

        var redactor = new PixelDataRedactor();
        var options = new RedactionOptions
        {
            Regions = new[] { new RedactionRegion { X = 0, Y = 0, Width = 2, Height = 2, Frame = 0 } }
        };

        var result = redactor.RedactRegions(dataset, options);

        Assert.That(result.FramesModified, Is.EqualTo(1));
    }

    [Test]
    public void DetectRisk_UltrasoundModality_ReturnsHigh()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.Modality, "US" }
        };

        var risk = BurnedInAnnotationDetector.DetectRisk(dataset);

        Assert.That(risk, Is.EqualTo(BurnedInAnnotationRisk.High));
    }

    [Test]
    public void DetectRisk_BurnedInAnnotationYes_ReturnsConfirmed()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.BurnedInAnnotation, "YES" }
        };

        var risk = BurnedInAnnotationDetector.DetectRisk(dataset);

        Assert.That(risk, Is.EqualTo(BurnedInAnnotationRisk.Confirmed));
    }

    [Test]
    public void DetectRisk_CTModality_ReturnsLow()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.Modality, "CT" }
        };

        var risk = BurnedInAnnotationDetector.DetectRisk(dataset);

        Assert.That(risk, Is.EqualTo(BurnedInAnnotationRisk.Low));
    }

    private static DicomDataset CreateTestDataset(
        int columns, int rows, int bitsAllocated, int samplesPerPixel,
        byte[] pixelData, int numberOfFrames = 1)
    {
        // Create test dataset with pixel data
        // Implementation depends on DicomPixelDataElement API
        // ...
    }

    private static byte[] GetPixelData(DicomDataset dataset)
    {
        // Extract pixel data bytes
        // ...
    }
}
```
  </action>
  <verify>
All tests pass: `dotnet test tests/SharpDicom.Tests --filter "PixelDataRedactor|BurnedInAnnotation"`
  </verify>
  <done>
BurnedInAnnotationDetector identifies high-risk modalities
Warning messages generated for US, ES, SC modalities
PixelDataRedactor tests pass for 8-bit, 16-bit
Multi-frame redaction works
Frame-specific redaction works
  </done>
</task>

</tasks>

<verification>
```bash
# Build
dotnet build src/SharpDicom

# Run pixel data tests
dotnet test tests/SharpDicom.Tests --filter "PixelData|BurnedIn"
```
</verification>

<success_criteria>
- PixelDataRedactor fills specified regions with configurable value
- 8-bit, 16-bit, and 32-bit pixel depths handled
- Multi-frame images fully supported
- Frame-specific redaction available
- BurnedInAnnotationDetector identifies high-risk modalities
- BurnedInAnnotation tag updated after redaction
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-de-identification/14-07-SUMMARY.md`
</output>
