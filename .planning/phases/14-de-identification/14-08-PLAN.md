---
phase: 14-de-identification
plan: 08
type: execute
wave: 4
depends_on: ["14-05", "14-06", "14-07"]
files_modified:
  - src/SharpDicom/Deidentification/BatchDeidentifier.cs
  - tests/SharpDicom.Tests/Deidentification/IntegrationTests.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Batch processing works for directories"
    - "De-identified files validate with DICOM standard"
    - "Mapping file enables reversibility"
    - "End-to-end de-identification produces valid output"
  artifacts:
    - path: "src/SharpDicom/Deidentification/BatchDeidentifier.cs"
      provides: "Batch directory processing"
      exports: ["BatchDeidentifier", "ProcessDirectoryAsync"]
    - path: "tests/SharpDicom.Tests/Deidentification/IntegrationTests.cs"
      provides: "End-to-end verification"
  key_links:
    - from: "BatchDeidentifier.cs"
      to: "DicomDeidentifier.cs"
      via: "uses deidentifier for each file"
      pattern: "DicomDeidentifier"
    - from: "BatchDeidentifier.cs"
      to: "DeidentificationContext.cs"
      via: "context for consistent UID mapping"
      pattern: "DeidentificationContext"
---

<objective>
Create batch processing capability and comprehensive integration tests verifying end-to-end de-identification.

Purpose: Enable production use with directory processing and validate against DICOM standard
Output: BatchDeidentifier and integration tests proving standards compliance
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-de-identification/14-RESEARCH.md
@src/SharpDicom/IO/DicomFile.cs
@src/SharpDicom/IO/DicomFileWriter.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BatchDeidentifier for directory processing</name>
  <files>
    src/SharpDicom/Deidentification/BatchDeidentifier.cs
    src/SharpDicom/Deidentification/BatchDeidentificationOptions.cs
  </files>
  <action>
Create BatchDeidentificationOptions:
```csharp
namespace SharpDicom.Deidentification;

/// <summary>
/// Options for batch de-identification processing.
/// </summary>
public sealed class BatchDeidentificationOptions
{
    /// <summary>Search pattern for DICOM files.</summary>
    public string SearchPattern { get; init; } = "*.dcm";

    /// <summary>Whether to search subdirectories.</summary>
    public bool Recursive { get; init; } = true;

    /// <summary>Whether to preserve directory structure in output.</summary>
    public bool PreserveDirectoryStructure { get; init; } = true;

    /// <summary>Maximum degree of parallelism (0 = auto).</summary>
    public int MaxParallelism { get; init; } = 0;

    /// <summary>Whether to continue on individual file errors.</summary>
    public bool ContinueOnError { get; init; } = true;

    /// <summary>Progress callback.</summary>
    public IProgress<BatchProgress>? Progress { get; init; }

    /// <summary>Whether to export UID mappings after completion.</summary>
    public bool ExportMappings { get; init; } = true;

    /// <summary>Path for mappings export (relative to output dir).</summary>
    public string MappingsFileName { get; init; } = "uid-mappings.json";
}

public readonly struct BatchProgress
{
    public int ProcessedFiles { get; init; }
    public int TotalFiles { get; init; }
    public string? CurrentFile { get; init; }
    public int SuccessCount { get; init; }
    public int ErrorCount { get; init; }
}
```

Create BatchDeidentifier:
```csharp
namespace SharpDicom.Deidentification;

/// <summary>
/// Processes directories of DICOM files for batch de-identification.
/// </summary>
public sealed class BatchDeidentifier : IAsyncDisposable
{
    private readonly DeidentificationContext _context;
    private readonly DicomDeidentifier _deidentifier;
    private readonly BatchDeidentificationOptions _options;

    public BatchDeidentifier(
        string contextDbPath,
        DeidentificationConfig config,
        BatchDeidentificationOptions? options = null)
    {
        _context = new DeidentificationContext(contextDbPath);
        _deidentifier = DeidentificationConfigLoader.CreateBuilder(config)
            .WithUidStore(_context.UidStore)
            .Build();
        _options = options ?? new BatchDeidentificationOptions();
    }

    /// <summary>
    /// De-identifies all DICOM files in a directory.
    /// </summary>
    public async Task<BatchDeidentificationResult> ProcessDirectoryAsync(
        string inputDir,
        string outputDir,
        CancellationToken ct = default)
    {
        var result = new BatchDeidentificationResult();

        // Ensure output directory exists
        Directory.CreateDirectory(outputDir);

        // Find all files
        var searchOption = _options.Recursive ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly;
        var files = Directory.EnumerateFiles(inputDir, _options.SearchPattern, searchOption).ToList();
        result.TotalFiles = files.Count;

        // Determine parallelism
        var parallelism = _options.MaxParallelism > 0
            ? _options.MaxParallelism
            : Environment.ProcessorCount;

        // Process files
        var semaphore = new SemaphoreSlim(parallelism);
        var tasks = files.Select(async (file, index) =>
        {
            await semaphore.WaitAsync(ct);
            try
            {
                await ProcessFileAsync(file, inputDir, outputDir, result, ct);

                _options.Progress?.Report(new BatchProgress
                {
                    ProcessedFiles = Interlocked.Increment(ref result.ProcessedFiles),
                    TotalFiles = result.TotalFiles,
                    CurrentFile = Path.GetFileName(file),
                    SuccessCount = result.SuccessCount,
                    ErrorCount = result.ErrorCount
                });
            }
            finally
            {
                semaphore.Release();
            }
        });

        await Task.WhenAll(tasks);

        // Export mappings
        if (_options.ExportMappings)
        {
            var mappingsPath = Path.Combine(outputDir, _options.MappingsFileName);
            await _context.ExportMappingsAsync(mappingsPath, ct);
            result.MappingsExportPath = mappingsPath;
        }

        return result;
    }

    private async Task ProcessFileAsync(
        string inputPath,
        string inputDir,
        string outputDir,
        BatchDeidentificationResult result,
        CancellationToken ct)
    {
        try
        {
            // Load file
            var file = await DicomFile.OpenAsync(inputPath, ct: ct);

            // De-identify
            var deidentResult = _deidentifier.Deidentify(file.Dataset);

            // Determine output path
            var relativePath = Path.GetRelativePath(inputDir, inputPath);
            var outputPath = _options.PreserveDirectoryStructure
                ? Path.Combine(outputDir, relativePath)
                : Path.Combine(outputDir, Path.GetFileName(inputPath));

            // Ensure output subdirectory exists
            var outputSubDir = Path.GetDirectoryName(outputPath);
            if (!string.IsNullOrEmpty(outputSubDir))
            {
                Directory.CreateDirectory(outputSubDir);
            }

            // Save de-identified file
            await file.SaveAsync(outputPath, ct: ct);

            // Update stats
            Interlocked.Increment(ref result.SuccessCount);
            Interlocked.Add(ref result.TotalAttributesRemoved, deidentResult.Summary.AttributesRemoved);
            Interlocked.Add(ref result.TotalAttributesReplaced, deidentResult.Summary.AttributesReplaced);
            Interlocked.Add(ref result.TotalUidsRemapped, deidentResult.Summary.UidsRemapped);
        }
        catch (Exception ex)
        {
            Interlocked.Increment(ref result.ErrorCount);
            lock (result.Errors)
            {
                result.Errors.Add(new BatchError
                {
                    FilePath = inputPath,
                    Message = ex.Message,
                    Exception = ex
                });
            }

            if (!_options.ContinueOnError)
            {
                throw;
            }
        }
    }

    /// <summary>
    /// Processes a list of specific files.
    /// </summary>
    public async Task<BatchDeidentificationResult> ProcessFilesAsync(
        IEnumerable<string> inputFiles,
        string outputDir,
        CancellationToken ct = default)
    {
        var result = new BatchDeidentificationResult();
        var files = inputFiles.ToList();
        result.TotalFiles = files.Count;

        Directory.CreateDirectory(outputDir);

        foreach (var file in files)
        {
            await ProcessFileAsync(file, Path.GetDirectoryName(file) ?? "", outputDir, result, ct);
            result.ProcessedFiles++;

            _options.Progress?.Report(new BatchProgress
            {
                ProcessedFiles = result.ProcessedFiles,
                TotalFiles = result.TotalFiles,
                CurrentFile = Path.GetFileName(file),
                SuccessCount = result.SuccessCount,
                ErrorCount = result.ErrorCount
            });
        }

        if (_options.ExportMappings)
        {
            var mappingsPath = Path.Combine(outputDir, _options.MappingsFileName);
            await _context.ExportMappingsAsync(mappingsPath, ct);
            result.MappingsExportPath = mappingsPath;
        }

        return result;
    }

    public async ValueTask DisposeAsync()
    {
        await _context.DisposeAsync();
    }
}

public sealed class BatchDeidentificationResult
{
    public int TotalFiles { get; set; }
    public int ProcessedFiles;
    public int SuccessCount;
    public int ErrorCount;
    public int TotalAttributesRemoved;
    public int TotalAttributesReplaced;
    public int TotalUidsRemapped;
    public string? MappingsExportPath { get; set; }
    public List<BatchError> Errors { get; } = new();

    public double SuccessRate => TotalFiles > 0 ? (double)SuccessCount / TotalFiles * 100 : 0;
}

public sealed class BatchError
{
    public string FilePath { get; init; } = string.Empty;
    public string Message { get; init; } = string.Empty;
    public Exception? Exception { get; init; }
}
```
  </action>
  <verify>
Build succeeds: `dotnet build src/SharpDicom`
  </verify>
  <done>
BatchDeidentifier processes directories with configurable options
Parallel processing with SemaphoreSlim throttling
Progress reporting via IProgress
Directory structure preserved optionally
UID mappings exported after completion
Error handling with continue option
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests</name>
  <files>
    tests/SharpDicom.Tests/Deidentification/DeidentificationIntegrationTests.cs
  </files>
  <action>
Create comprehensive integration tests:
```csharp
using System.Text.Json;

namespace SharpDicom.Tests.Deidentification;

[TestFixture]
public class DeidentificationIntegrationTests
{
    private string _testDir = null!;
    private string _outputDir = null!;

    [SetUp]
    public void SetUp()
    {
        _testDir = Path.Combine(Path.GetTempPath(), $"deid-test-{Guid.NewGuid():N}");
        _outputDir = Path.Combine(Path.GetTempPath(), $"deid-output-{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDir);
        Directory.CreateDirectory(_outputDir);
    }

    [TearDown]
    public void TearDown()
    {
        if (Directory.Exists(_testDir))
            Directory.Delete(_testDir, true);
        if (Directory.Exists(_outputDir))
            Directory.Delete(_outputDir, true);
    }

    [Test]
    public async Task EndToEnd_BasicProfile_ProducesValidOutput()
    {
        // Create test file with patient data
        var inputPath = Path.Combine(_testDir, "test.dcm");
        var dataset = CreateTestDataset();
        await SaveTestFile(inputPath, dataset);

        // De-identify
        var deidentifier = new DicomDeidentifierBuilder()
            .WithBasicProfile()
            .WithDateShift(TimeSpan.FromDays(-100))
            .Build();

        var file = await DicomFile.OpenAsync(inputPath);
        var result = deidentifier.Deidentify(file.Dataset);

        // Save output
        var outputPath = Path.Combine(_outputDir, "test-deid.dcm");
        await file.SaveAsync(outputPath);

        // Verify output is valid DICOM
        var reloaded = await DicomFile.OpenAsync(outputPath);
        Assert.That(reloaded.Dataset, Is.Not.Null);

        // Verify patient data removed/modified
        Assert.That(reloaded.Dataset.GetString(DicomTag.PatientName),
            Is.Not.EqualTo("Doe^John"));
        Assert.That(reloaded.Dataset.GetString(DicomTag.PatientID),
            Is.Not.EqualTo("12345"));

        // Verify de-identification tags present
        Assert.That(reloaded.Dataset.GetString(DicomTag.PatientIdentityRemoved),
            Is.EqualTo("YES"));
        Assert.That(reloaded.Dataset.Contains(DicomTag.DeidentificationMethodCodeSequence),
            Is.True);
    }

    [Test]
    public async Task EndToEnd_UidConsistency_AcrossStudy()
    {
        // Create two files from same study
        var studyUid = "1.2.3.4.5.6";
        var file1Path = Path.Combine(_testDir, "file1.dcm");
        var file2Path = Path.Combine(_testDir, "file2.dcm");

        await SaveTestFile(file1Path, CreateTestDataset(studyUid, "1.2.3.4.5.6.1"));
        await SaveTestFile(file2Path, CreateTestDataset(studyUid, "1.2.3.4.5.6.2"));

        // De-identify with shared context
        var dbPath = Path.Combine(_testDir, "mappings.db");
        await using var context = new DeidentificationContext(dbPath);

        var deidentifier = context.CreateBuilder()
            .WithBasicProfile()
            .Build();

        var ds1 = (await DicomFile.OpenAsync(file1Path)).Dataset;
        var ds2 = (await DicomFile.OpenAsync(file2Path)).Dataset;

        deidentifier.Deidentify(ds1);
        deidentifier.Deidentify(ds2);

        // Same study UID should map to same new UID
        var newStudyUid1 = ds1.GetString(DicomTag.StudyInstanceUID);
        var newStudyUid2 = ds2.GetString(DicomTag.StudyInstanceUID);

        Assert.That(newStudyUid1, Is.EqualTo(newStudyUid2));
        Assert.That(newStudyUid1, Is.Not.EqualTo(studyUid));

        // Different SOP Instance UIDs should be different
        var newSopUid1 = ds1.GetString(DicomTag.SOPInstanceUID);
        var newSopUid2 = ds2.GetString(DicomTag.SOPInstanceUID);

        Assert.That(newSopUid1, Is.Not.EqualTo(newSopUid2));
    }

    [Test]
    public async Task EndToEnd_DateShifting_PreservesOrder()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.PatientID, "TEST001" },
            { DicomTag.StudyDate, "20240115" },
            { DicomTag.SeriesDate, "20240116" },
            { DicomTag.AcquisitionDate, "20240117" }
        };

        var deidentifier = new DicomDeidentifierBuilder()
            .WithBasicProfile()
            .WithDateShift(TimeSpan.FromDays(-100))
            .Build();

        deidentifier.Deidentify(dataset);

        var studyDate = dataset.GetString(DicomTag.StudyDate);
        var seriesDate = dataset.GetString(DicomTag.SeriesDate);
        var acqDate = dataset.GetString(DicomTag.AcquisitionDate);

        // Dates should maintain relative order
        Assert.That(string.Compare(studyDate, seriesDate), Is.LessThan(0));
        Assert.That(string.Compare(seriesDate, acqDate), Is.LessThan(0));
    }

    [Test]
    public async Task EndToEnd_MappingFileEnablesReidentification()
    {
        var originalPatientId = "PATIENT123";
        var originalStudyUid = "1.2.3.4.5.6.7.8.9";

        var dataset = new DicomDataset
        {
            { DicomTag.PatientID, originalPatientId },
            { DicomTag.StudyInstanceUID, originalStudyUid },
            { DicomTag.PatientName, "Original^Name" }
        };

        var dbPath = Path.Combine(_testDir, "mappings.db");
        await using var context = new DeidentificationContext(dbPath);

        var deidentifier = context.CreateBuilder()
            .WithBasicProfile()
            .Build();

        deidentifier.Deidentify(dataset);

        var newStudyUid = dataset.GetString(DicomTag.StudyInstanceUID);

        // Export mappings
        var mappingsPath = Path.Combine(_outputDir, "mappings.json");
        await context.ExportMappingsAsync(mappingsPath);

        // Verify mapping file contains the UID mapping
        var mappingsJson = await File.ReadAllTextAsync(mappingsPath);
        Assert.That(mappingsJson, Does.Contain(originalStudyUid));
        Assert.That(mappingsJson, Does.Contain(newStudyUid));

        // Verify bidirectional lookup
        Assert.That(context.UidStore.TryGetOriginal(newStudyUid!, out var lookup), Is.True);
        Assert.That(lookup, Is.EqualTo(originalStudyUid));
    }

    [Test]
    public async Task EndToEnd_ConfigFromJson_AppliesCorrectly()
    {
        var configJson = """
        {
            "options": ["RetainPatientCharacteristics"],
            "dateShift": {
                "strategy": "fixed",
                "offsetDays": -50
            },
            "overrides": {
                "(0008,0080)": "K"
            }
        }
        """;

        var config = DeidentificationConfigLoader.LoadConfigFromJson(configJson);
        var builder = DeidentificationConfigLoader.CreateBuilder(config);
        var deidentifier = builder.Build();

        var dataset = new DicomDataset
        {
            { DicomTag.PatientAge, "045Y" },
            { DicomTag.InstitutionName, "Test Hospital" },
            { DicomTag.StudyDate, "20240115" }
        };

        deidentifier.Deidentify(dataset);

        // Age should be kept (RetainPatientCharacteristics)
        Assert.That(dataset.GetString(DicomTag.PatientAge), Is.EqualTo("045Y"));

        // Institution should be kept (override)
        Assert.That(dataset.GetString(DicomTag.InstitutionName), Is.EqualTo("Test Hospital"));

        // Date should be shifted by -50 days
        Assert.That(dataset.GetString(DicomTag.StudyDate), Is.EqualTo("20231127"));
    }

    [Test]
    public async Task BatchProcessing_Directory_ProcessesAllFiles()
    {
        // Create test files
        for (int i = 0; i < 5; i++)
        {
            var path = Path.Combine(_testDir, $"file{i}.dcm");
            await SaveTestFile(path, CreateTestDataset());
        }

        var dbPath = Path.Combine(_testDir, "batch.db");
        var config = DeidentificationConfigLoader.GetPreset("basic-profile");

        await using var batch = new BatchDeidentifier(dbPath, config);
        var result = await batch.ProcessDirectoryAsync(_testDir, _outputDir);

        Assert.That(result.TotalFiles, Is.EqualTo(5));
        Assert.That(result.SuccessCount, Is.EqualTo(5));
        Assert.That(result.ErrorCount, Is.EqualTo(0));

        // Verify output files exist
        var outputFiles = Directory.GetFiles(_outputDir, "*.dcm");
        Assert.That(outputFiles.Length, Is.EqualTo(5));

        // Verify mappings exported
        var mappingsPath = Path.Combine(_outputDir, "uid-mappings.json");
        Assert.That(File.Exists(mappingsPath), Is.True);
    }

    [Test]
    public void BurnedInAnnotation_UltrasoundModality_GeneratesWarning()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.Modality, "US" }
        };

        var risk = BurnedInAnnotationDetector.DetectRisk(dataset);

        Assert.That(risk, Is.EqualTo(BurnedInAnnotationRisk.High));

        var warning = BurnedInAnnotationDetector.GetWarningMessage(risk, dataset);
        Assert.That(warning, Does.Contain("burned-in"));
    }

    private static DicomDataset CreateTestDataset(
        string? studyUid = null,
        string? sopUid = null)
    {
        return new DicomDataset
        {
            { DicomTag.PatientName, "Doe^John" },
            { DicomTag.PatientID, "12345" },
            { DicomTag.PatientBirthDate, "19800101" },
            { DicomTag.StudyDate, "20240115" },
            { DicomTag.StudyInstanceUID, studyUid ?? "1.2.3.4.5" },
            { DicomTag.SeriesInstanceUID, "1.2.3.4.5.1" },
            { DicomTag.SOPInstanceUID, sopUid ?? "1.2.3.4.5.1.1" },
            { DicomTag.SOPClassUID, DicomUID.SecondaryCaptureImageStorage.Uid },
            { DicomTag.Modality, "OT" }
        };
    }

    private static async Task SaveTestFile(string path, DicomDataset dataset)
    {
        var file = new DicomFile(dataset);
        await file.SaveAsync(path);
    }
}
```
  </action>
  <verify>
All tests pass: `dotnet test tests/SharpDicom.Tests --filter "DeidentificationIntegration"`
  </verify>
  <done>
End-to-end tests verify complete de-identification workflow
UID consistency verified across study files
Date shifting order preservation tested
Mapping file enables re-identification
JSON config application tested
Batch processing verified
Burned-in annotation warning tested
  </done>
</task>

<task type="auto">
  <name>Task 3: Run full test suite and document</name>
  <files>
    tests/SharpDicom.Tests/Deidentification/DeidentificationSmokeTests.cs
  </files>
  <action>
Create smoke tests that exercise the full de-identification surface:

```csharp
namespace SharpDicom.Tests.Deidentification;

/// <summary>
/// Smoke tests exercising the complete de-identification API surface.
/// </summary>
[TestFixture]
public class DeidentificationSmokeTests
{
    [Test]
    public void API_FluentBuilder_AllMethods()
    {
        // Verify all builder methods compile and chain
        var deidentifier = new DicomDeidentifierBuilder()
            .WithBasicProfile()
            .WithOption(DeidentificationOption.RetainPatientCharacteristics)
            .WithOption(DeidentificationOption.CleanDescriptors)
            .WithOption(DeidentificationOption.RetainLongitudinalModifiedDates)
            .WithDateShift(TimeSpan.FromDays(-100))
            .WithOverride(DicomTag.InstitutionName, DeidentificationAction.Keep)
            .WithOverride(DicomTag.StationName, DeidentificationAction.Remove)
            .WithSafePrivateCreators("SIEMENS CSA HEADER", "GEMS_PARM_01")
            .RemovePrivateTags()
            .Build();

        Assert.That(deidentifier, Is.Not.Null);
    }

    [Test]
    public void API_Presets_AllAccessible()
    {
        // Verify all presets exist
        Assert.DoesNotThrow(() => DeidentificationConfigLoader.GetPreset("basic-profile"));
        Assert.DoesNotThrow(() => DeidentificationConfigLoader.GetPreset("research"));
        Assert.DoesNotThrow(() => DeidentificationConfigLoader.GetPreset("clinical-trial"));
        Assert.DoesNotThrow(() => DeidentificationConfigLoader.GetPreset("teaching"));
    }

    [Test]
    public void API_AllOptions_Parseable()
    {
        // Verify all option names parse
        var options = new[]
        {
            "RetainSafePrivate",
            "RetainUIDs",
            "RetainDeviceIdentity",
            "RetainInstitutionIdentity",
            "RetainPatientCharacteristics",
            "RetainLongitudinalFullDates",
            "RetainLongitudinalModifiedDates",
            "CleanDescriptors",
            "CleanStructuredContent",
            "CleanGraphics"
        };

        var json = $@"{{ ""options"": [{string.Join(",", options.Select(o => $"\"{o}\""))}] }}";
        var config = DeidentificationConfigLoader.LoadConfigFromJson(json);

        Assert.That(config.Options?.Count, Is.EqualTo(options.Length));
    }

    [Test]
    public void API_AllActions_Resolvable()
    {
        // Verify all action codes resolve without error
        foreach (DeidentificationAction action in Enum.GetValues(typeof(DeidentificationAction)))
        {
            Assert.DoesNotThrow(() => ActionResolver.ResolveAction(action));
        }
    }

    [Test]
    public void API_GeneratedProfiles_HasEntries()
    {
        // Verify source generator produced the action table
        var patientNameAction = DeidentificationProfiles.GetAction(
            DicomTag.PatientName,
            DeidentificationOptions.BasicProfile);

        // Patient Name should have Z action in Basic Profile
        Assert.That(patientNameAction, Is.EqualTo(DeidentificationAction.ZeroOrDummy));
    }

    [Test]
    public void API_DateShiftStrategies_AllWork()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.PatientID, "TEST" },
            { DicomTag.StudyDate, "20240115" }
        };

        // Test each strategy
        foreach (DateShiftStrategy strategy in Enum.GetValues(typeof(DateShiftStrategy)))
        {
            var config = new DateShiftConfig { Strategy = strategy };
            var shifter = new DateShifter(config);

            Assert.DoesNotThrow(() => shifter.ShiftDates(dataset.Clone()));
        }
    }

    [Test]
    public void API_UidMapper_GeneratesValidUids()
    {
        using var store = new InMemoryUidStore();
        var mapper = new UidMapper(store);

        var newUid = mapper.Remap("1.2.3.4.5.6.7.8.9", "test");

        // Should be 2.25.xxx format
        Assert.That(newUid, Does.StartWith("2.25."));

        // Should be <= 64 chars
        Assert.That(newUid.Length, Is.LessThanOrEqualTo(64));

        // Should be consistent
        var sameUid = mapper.Remap("1.2.3.4.5.6.7.8.9", "test");
        Assert.That(sameUid, Is.EqualTo(newUid));
    }

    [Test]
    public void API_DummyValues_AllVRsCovered()
    {
        // Test that dummy generation works for all VRs
        var vrs = typeof(DicomVR)
            .GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static)
            .Where(f => f.FieldType == typeof(DicomVR))
            .Select(f => (DicomVR)f.GetValue(null)!);

        foreach (var vr in vrs)
        {
            Assert.DoesNotThrow(() => DummyValueGenerator.GenerateDummy(vr),
                $"Failed to generate dummy for VR {vr.Code}");
        }
    }
}
```

Run the full test suite and verify all de-identification tests pass:

```bash
# Run all de-identification tests
dotnet test tests/SharpDicom.Tests --filter "Deidentif"

# Run full test suite
dotnet test tests/SharpDicom.Tests
```
  </action>
  <verify>
All tests pass: `dotnet test tests/SharpDicom.Tests --filter "Deidentif"`
Full test suite passes: `dotnet test tests/SharpDicom.Tests`
  </verify>
  <done>
Smoke tests exercise entire API surface
All presets accessible
All options parseable
All actions resolvable
Generated profiles have entries
All VRs have dummy values
Full test suite passes
  </done>
</task>

</tasks>

<verification>
```bash
# Build entire solution
dotnet build

# Run all de-identification tests
dotnet test tests/SharpDicom.Tests --filter "Deidentif"

# Run full test suite
dotnet test tests/SharpDicom.Tests

# Verify no warnings
dotnet build --configuration Release 2>&1 | grep -i warning
```
</verification>

<success_criteria>
- BatchDeidentifier processes directories correctly
- Progress reporting works
- UID mappings exported to JSON
- End-to-end tests pass for complete workflows
- UID consistency maintained across study
- Date shifting preserves temporal order
- Mapping file enables re-identification
- JSON config application works
- All de-identification tests pass (50+ tests)
- Full test suite passes
- No compiler warnings
</success_criteria>

<output>
After completion, create `.planning/phases/14-de-identification/14-08-SUMMARY.md`
</output>
