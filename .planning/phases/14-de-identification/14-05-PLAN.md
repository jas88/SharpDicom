---
phase: 14-de-identification
plan: 05
type: execute
wave: 3
depends_on: ["14-01", "14-02", "14-03", "14-04"]
files_modified:
  - src/SharpDicom/Deidentification/DicomDeidentifier.cs
  - src/SharpDicom/Deidentification/DicomDeidentifierBuilder.cs
  - src/SharpDicom/Deidentification/DeidentificationContext.cs
  - src/SharpDicom/Deidentification/DeidentificationCallback.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "DicomDeidentifier applies Basic Profile actions to datasets"
    - "Fluent builder enables profile customization"
    - "Element callback integration works for streaming de-identification"
    - "De-identification Method tags (0012,0062-0064) populated correctly"
  artifacts:
    - path: "src/SharpDicom/Deidentification/DicomDeidentifier.cs"
      provides: "Main de-identification coordinator"
      exports: ["DicomDeidentifier", "Deidentify", "DeidentifyAsync"]
    - path: "src/SharpDicom/Deidentification/DicomDeidentifierBuilder.cs"
      provides: "Fluent configuration builder"
      exports: ["DicomDeidentifierBuilder", "Build"]
    - path: "src/SharpDicom/Deidentification/DeidentificationContext.cs"
      provides: "Stateful context for batch processing"
      exports: ["DeidentificationContext"]
  key_links:
    - from: "DicomDeidentifier.cs"
      to: "DeidentificationProfiles.cs"
      via: "GetAction for tag resolution"
      pattern: "DeidentificationProfiles\\.GetAction"
    - from: "DicomDeidentifier.cs"
      to: "UidRemapper.cs"
      via: "UID remapping coordination"
      pattern: "UidRemapper"
    - from: "DicomDeidentifier.cs"
      to: "DateShifter.cs"
      via: "Date shifting coordination"
      pattern: "DateShifter"
---

<objective>
Create the main DicomDeidentifier class with fluent builder API and element callback integration.

Purpose: Provide the primary API for de-identifying DICOM datasets per PS3.15
Output: DicomDeidentifier with full profile support and batch processing context
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-de-identification/14-RESEARCH.md
@src/SharpDicom/IO/DicomReaderOptions.cs
@src/SharpDicom/Validation/IValidationRule.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DicomDeidentifier core class</name>
  <files>
    src/SharpDicom/Deidentification/DicomDeidentifier.cs
  </files>
  <action>
Create DicomDeidentifier:
```csharp
namespace SharpDicom.Deidentification;

/// <summary>
/// De-identifies DICOM datasets according to PS3.15 Basic Application Level Confidentiality Profile.
/// </summary>
public sealed class DicomDeidentifier
{
    private readonly DeidentificationOptions _options;
    private readonly UidMapper _uidMapper;
    private readonly DateShifter _dateShifter;
    private readonly UidRemapper _uidRemapper;

    internal DicomDeidentifier(
        DeidentificationOptions options,
        UidMapper uidMapper,
        DateShifter dateShifter)
    {
        _options = options;
        _uidMapper = uidMapper;
        _dateShifter = dateShifter;
        _uidRemapper = new UidRemapper(uidMapper);
    }

    /// <summary>
    /// De-identifies a dataset in place.
    /// </summary>
    public DeidentificationResult Deidentify(DicomDataset dataset)
    {
        var result = new DeidentificationResult { Dataset = dataset };

        // Get patient/study identifiers for consistent processing
        var patientId = dataset.GetString(DicomTag.PatientID);
        var studyUid = dataset.GetString(DicomTag.StudyInstanceUID);

        // Phase 1: Apply tag-level actions
        ApplyTagActions(dataset, result);

        // Phase 2: Remap UIDs (if not RetainUIDs)
        if (!_options.RetainUIDs)
        {
            var uidResult = _uidRemapper.RemapUids(dataset, studyUid);
            result.Summary.UidsRemapped = uidResult.RemappedCount;
        }

        // Phase 3: Shift dates (if configured)
        if (_dateShifter != null)
        {
            var dateResult = _dateShifter.ShiftDates(dataset, patientId);
            result.Summary.DatesShifted = dateResult.TotalShifted;
        }

        // Phase 4: Add de-identification confirmation attributes
        AddDeidentificationAttributes(dataset, result);

        return result;
    }

    /// <summary>
    /// Creates a de-identified copy of the dataset.
    /// </summary>
    public DeidentificationResult DeidentifyCopy(DicomDataset dataset)
    {
        var copy = dataset.Clone();
        return Deidentify(copy);
    }

    private void ApplyTagActions(DicomDataset dataset, DeidentificationResult result)
    {
        // Process elements in tag order (allows safe removal during iteration)
        var elementsToProcess = dataset.OrderBy(e => e.Tag.Value).ToList();

        foreach (var element in elementsToProcess)
        {
            ProcessElement(dataset, element, result, depth: 0);
        }
    }

    private void ProcessElement(DicomDataset dataset, IDicomElement element, DeidentificationResult result, int depth)
    {
        // Handle private tags
        if (element.Tag.IsPrivate)
        {
            ProcessPrivateTag(dataset, element, result);
            return;
        }

        // Get the effective action for this tag
        var action = ActionResolver.GetEffectiveAction(element.Tag, _options);
        var resolved = ActionResolver.ResolveAction(action);

        switch (resolved)
        {
            case ResolvedAction.Keep:
                // Keep as-is, but process sequences recursively
                if (element is DicomSequence seq)
                {
                    foreach (var item in seq.Items)
                    {
                        ApplyTagActions(item, result);
                    }
                }
                break;

            case ResolvedAction.Remove:
                dataset.Remove(element.Tag);
                result.Summary.AttributesRemoved++;
                break;

            case ResolvedAction.ReplaceWithEmpty:
                ReplaceWithEmpty(dataset, element);
                result.Summary.AttributesReplaced++;
                break;

            case ResolvedAction.ReplaceWithDummy:
                ReplaceWithDummy(dataset, element);
                result.Summary.AttributesReplaced++;
                break;

            case ResolvedAction.Clean:
                CleanElement(dataset, element, result);
                result.Summary.AttributesReplaced++;
                break;

            case ResolvedAction.RemapUid:
                // UIDs handled in Phase 2
                break;
        }
    }

    private void ProcessPrivateTag(DicomDataset dataset, IDicomElement element, DeidentificationResult result)
    {
        // Check if this private creator is in safe list
        if (_options.SafePrivateCreators != null)
        {
            var creator = dataset.GetPrivateCreator(element.Tag);
            if (creator != null && _options.SafePrivateCreators.Contains(creator))
            {
                // Keep safe private tags
                return;
            }
        }

        // Apply default private tag action
        if (_options.DefaultPrivateTagAction == PrivateTagAction.Remove)
        {
            dataset.Remove(element.Tag);
            result.Summary.AttributesRemoved++;
        }
    }

    private void ReplaceWithEmpty(DicomDataset dataset, IDicomElement element)
    {
        var emptyElement = DicomElement.Create(element.Tag, element.VR, Array.Empty<byte>());
        dataset[element.Tag] = emptyElement;
    }

    private void ReplaceWithDummy(DicomDataset dataset, IDicomElement element)
    {
        var dummy = DummyValueGenerator.GenerateDummy(element.VR, element.Tag);
        var newElement = DicomElement.Create(element.Tag, element.VR, dummy);
        dataset[element.Tag] = newElement;
    }

    private void CleanElement(DicomDataset dataset, IDicomElement element, DeidentificationResult result)
    {
        // For sequences, recursively clean items
        if (element is DicomSequence seq)
        {
            foreach (var item in seq.Items)
            {
                ApplyTagActions(item, result);
            }
            result.Summary.SequencesCleaned++;
            return;
        }

        // For other elements, replace with cleaned version
        // (Implementation depends on VR and context)
        ReplaceWithDummy(dataset, element);
    }

    private void AddDeidentificationAttributes(DicomDataset dataset, DeidentificationResult result)
    {
        // Patient Identity Removed (0012,0062)
        dataset.AddOrUpdate(DicomTag.PatientIdentityRemoved, "YES");

        // De-identification Method (0012,0063)
        var methodText = BuildMethodText();
        dataset.AddOrUpdate(DicomTag.DeidentificationMethod, methodText);

        // De-identification Method Code Sequence (0012,0064)
        var codeSeq = BuildMethodCodeSequence();
        dataset.AddOrUpdate(codeSeq);

        // Longitudinal Temporal Information Modified (0028,0303)
        if (_dateShifter != null && result.Summary.DatesShifted > 0)
        {
            dataset.AddOrUpdate(DicomTag.LongitudinalTemporalInformationModified, "MODIFIED");
        }
        else if (!_options.RetainLongitudinalFullDates)
        {
            dataset.AddOrUpdate(DicomTag.LongitudinalTemporalInformationModified, "REMOVED");
        }
    }

    private string BuildMethodText()
    {
        var parts = new List<string> { "Basic Application Confidentiality Profile" };

        if (_options.RetainPatientCharacteristics)
            parts.Add("Retain Patient Characteristics Option");
        if (_options.CleanDescriptors)
            parts.Add("Clean Descriptors Option");
        // ... add other active options

        return string.Join("; ", parts);
    }

    private DicomSequence BuildMethodCodeSequence()
    {
        var seq = new DicomSequence(DicomTag.DeidentificationMethodCodeSequence);

        // Basic Profile code
        var basicItem = new DicomDataset
        {
            { DicomTag.CodeValue, "113100" },
            { DicomTag.CodingSchemeDesignator, "DCM" },
            { DicomTag.CodeMeaning, "Basic Application Confidentiality Profile" }
        };
        seq.Items.Add(basicItem);

        // Add codes for active options
        if (_options.RetainPatientCharacteristics)
        {
            seq.Items.Add(CreateCodeItem("113108", "Retain Patient Characteristics Option"));
        }
        if (_options.CleanDescriptors)
        {
            seq.Items.Add(CreateCodeItem("113105", "Clean Descriptors Option"));
        }
        // ... add other option codes

        return seq;
    }

    private static DicomDataset CreateCodeItem(string code, string meaning)
    {
        return new DicomDataset
        {
            { DicomTag.CodeValue, code },
            { DicomTag.CodingSchemeDesignator, "DCM" },
            { DicomTag.CodeMeaning, meaning }
        };
    }
}
```
  </action>
  <verify>
Build succeeds: `dotnet build src/SharpDicom`
  </verify>
  <done>
DicomDeidentifier applies actions from profiles
Private tags handled with configurable default
De-identification confirmation attributes added
Sequences processed recursively
  </done>
</task>

<task type="auto">
  <name>Task 2: Create fluent builder and context</name>
  <files>
    src/SharpDicom/Deidentification/DicomDeidentifierBuilder.cs
    src/SharpDicom/Deidentification/DeidentificationContext.cs
  </files>
  <action>
Create DicomDeidentifierBuilder:
```csharp
public sealed class DicomDeidentifierBuilder
{
    private DeidentificationOptions _options = new();
    private DateShiftConfig? _dateShiftConfig;
    private IUidMappingStore? _uidStore;
    private UidMappingScope _uidScope = UidMappingScope.Study;
    private readonly Dictionary<DicomTag, DeidentificationAction> _overrides = new();

    public DicomDeidentifierBuilder WithBasicProfile()
    {
        _options = DeidentificationOptions.BasicProfile;
        return this;
    }

    public DicomDeidentifierBuilder WithOption(DeidentificationOption option)
    {
        // Apply option flags
        _options = option switch
        {
            DeidentificationOption.RetainPatientCharacteristics =>
                _options with { RetainPatientCharacteristics = true },
            DeidentificationOption.RetainUIDs =>
                _options with { RetainUIDs = true },
            DeidentificationOption.CleanDescriptors =>
                _options with { CleanDescriptors = true },
            // ... other options
            _ => _options
        };
        return this;
    }

    public DicomDeidentifierBuilder WithDateShift(TimeSpan offset)
    {
        _dateShiftConfig = new DateShiftConfig
        {
            Strategy = DateShiftStrategy.FixedOffset,
            FixedOffset = offset
        };
        return this;
    }

    public DicomDeidentifierBuilder WithDateShift(DateShiftConfig config)
    {
        _dateShiftConfig = config;
        return this;
    }

    public DicomDeidentifierBuilder WithUidStore(IUidMappingStore store)
    {
        _uidStore = store;
        return this;
    }

    public DicomDeidentifierBuilder WithUidScope(UidMappingScope scope)
    {
        _uidScope = scope;
        return this;
    }

    public DicomDeidentifierBuilder WithOverride(DicomTag tag, DeidentificationAction action)
    {
        _overrides[tag] = action;
        return this;
    }

    public DicomDeidentifierBuilder WithSafePrivateCreators(params string[] creators)
    {
        _options = _options with
        {
            SafePrivateCreators = new HashSet<string>(creators, StringComparer.OrdinalIgnoreCase)
        };
        return this;
    }

    public DicomDeidentifierBuilder RemovePrivateTags()
    {
        _options = _options with { DefaultPrivateTagAction = PrivateTagAction.Remove };
        return this;
    }

    public DicomDeidentifierBuilder KeepPrivateTags()
    {
        _options = _options with { DefaultPrivateTagAction = PrivateTagAction.Keep };
        return this;
    }

    public DicomDeidentifier Build()
    {
        // Apply overrides to options
        if (_overrides.Count > 0)
        {
            _options = _options with { Overrides = _overrides };
        }

        // Create UID mapper
        var uidStore = _uidStore ?? new InMemoryUidStore();
        var uidMapper = new UidMapper(uidStore, _uidScope);

        // Create date shifter (if configured)
        var dateShifter = _dateShiftConfig != null
            ? new DateShifter(_dateShiftConfig)
            : null;

        return new DicomDeidentifier(_options, uidMapper, dateShifter);
    }
}

public enum DeidentificationOption
{
    RetainSafePrivate,
    RetainUIDs,
    RetainDeviceIdentity,
    RetainInstitutionIdentity,
    RetainPatientCharacteristics,
    RetainLongitudinalFullDates,
    RetainLongitudinalModifiedDates,
    CleanDescriptors,
    CleanStructuredContent,
    CleanGraphics
}
```

Create DeidentificationContext for batch processing:
```csharp
public sealed class DeidentificationContext : IAsyncDisposable
{
    private readonly SqliteUidStore _uidStore;
    private readonly UidMapper _uidMapper;
    private readonly IDateOffsetStore _dateOffsetStore;

    public DeidentificationContext(string sqlitePath)
    {
        _uidStore = new SqliteUidStore(sqlitePath);
        _uidMapper = new UidMapper(_uidStore);
        _dateOffsetStore = new SqliteDateOffsetStore(sqlitePath);
    }

    /// <summary>Gets the UID store for this context.</summary>
    public IUidMappingStore UidStore => _uidStore;

    /// <summary>Gets the date offset store for this context.</summary>
    public IDateOffsetStore DateOffsetStore => _dateOffsetStore;

    /// <summary>Creates a deidentifier builder pre-configured with this context's stores.</summary>
    public DicomDeidentifierBuilder CreateBuilder()
    {
        return new DicomDeidentifierBuilder()
            .WithUidStore(_uidStore);
    }

    /// <summary>Exports all UID mappings to JSON.</summary>
    public Task ExportMappingsAsync(string path, CancellationToken ct = default)
    {
        using var stream = File.Create(path);
        return _uidStore.ExportToJsonAsync(stream, ct);
    }

    public async ValueTask DisposeAsync()
    {
        _uidStore.Dispose();
        if (_dateOffsetStore is IDisposable disposable)
            disposable.Dispose();
    }
}
```
  </action>
  <verify>
Build succeeds: `dotnet build src/SharpDicom`
  </verify>
  <done>
DicomDeidentifierBuilder provides fluent configuration
WithOption methods for all profile options
DeidentificationContext manages persistent stores
Context integrates with builder
  </done>
</task>

<task type="auto">
  <name>Task 3: Create element callback integration and tests</name>
  <files>
    src/SharpDicom/Deidentification/DeidentificationCallback.cs
    tests/SharpDicom.Tests/Deidentification/DicomDeidentifierTests.cs
  </files>
  <action>
Create DeidentificationCallback for streaming integration:
```csharp
/// <summary>
/// Provides element callback for streaming de-identification during file reading.
/// </summary>
public sealed class DeidentificationCallback
{
    private readonly DicomDeidentifier _deidentifier;
    private readonly DeidentificationResult _result;

    public DeidentificationCallback(DicomDeidentifier deidentifier)
    {
        _deidentifier = deidentifier;
        _result = new DeidentificationResult();
    }

    /// <summary>
    /// Gets the accumulated result after processing.
    /// </summary>
    public DeidentificationResult Result => _result;

    /// <summary>
    /// Creates a callback function suitable for DicomReaderOptions.ElementCallback.
    /// </summary>
    public Func<DicomDataset, IDicomElement, bool> AsCallback()
    {
        return (dataset, element) =>
        {
            // This is called during parsing - allows filtering/modification
            // Return false to skip adding this element to the dataset
            var action = ActionResolver.GetEffectiveAction(element.Tag, _deidentifier.Options);
            var resolved = ActionResolver.ResolveAction(action);

            return resolved switch
            {
                ResolvedAction.Remove => false,  // Don't add to dataset
                ResolvedAction.Keep => true,
                _ => true  // Other actions applied after loading
            };
        };
    }
}
```

Create comprehensive tests:
```csharp
[TestFixture]
public class DicomDeidentifierTests
{
    [Test]
    public void Deidentify_BasicProfile_RemovesPatientName()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.PatientName, "Doe^John" },
            { DicomTag.PatientID, "12345" }
        };

        var deidentifier = new DicomDeidentifierBuilder()
            .WithBasicProfile()
            .Build();

        var result = deidentifier.Deidentify(dataset);

        // Patient Name should be replaced (Z action = zero or dummy)
        Assert.That(dataset.GetString(DicomTag.PatientName), Is.Not.EqualTo("Doe^John"));
    }

    [Test]
    public void Deidentify_AddsDeidentificationAttributes()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.PatientName, "Doe^John" }
        };

        var deidentifier = new DicomDeidentifierBuilder()
            .WithBasicProfile()
            .Build();

        deidentifier.Deidentify(dataset);

        Assert.That(dataset.GetString(DicomTag.PatientIdentityRemoved), Is.EqualTo("YES"));
        Assert.That(dataset.Contains(DicomTag.DeidentificationMethod), Is.True);
        Assert.That(dataset.Contains(DicomTag.DeidentificationMethodCodeSequence), Is.True);
    }

    [Test]
    public void Deidentify_WithRetainPatientChars_KeepsAge()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.PatientAge, "045Y" }
        };

        var deidentifier = new DicomDeidentifierBuilder()
            .WithBasicProfile()
            .WithOption(DeidentificationOption.RetainPatientCharacteristics)
            .Build();

        deidentifier.Deidentify(dataset);

        Assert.That(dataset.GetString(DicomTag.PatientAge), Is.EqualTo("045Y"));
    }

    [Test]
    public void Deidentify_WithOverride_AppliesCustomAction()
    {
        var dataset = new DicomDataset
        {
            { DicomTag.InstitutionName, "General Hospital" }
        };

        var deidentifier = new DicomDeidentifierBuilder()
            .WithBasicProfile()
            .WithOverride(DicomTag.InstitutionName, DeidentificationAction.Keep)
            .Build();

        deidentifier.Deidentify(dataset);

        // Should be kept due to override
        Assert.That(dataset.GetString(DicomTag.InstitutionName), Is.EqualTo("General Hospital"));
    }

    [Test]
    public async Task DeidentificationContext_PersistsUidMappings()
    {
        var dbPath = Path.GetTempFileName();
        try
        {
            await using var context = new DeidentificationContext(dbPath);

            var deidentifier = context.CreateBuilder()
                .WithBasicProfile()
                .Build();

            var dataset1 = new DicomDataset
            {
                { DicomTag.SOPInstanceUID, "1.2.3.4.5" },
                { DicomTag.StudyInstanceUID, "1.2.3.4" }
            };
            var dataset2 = new DicomDataset
            {
                { DicomTag.SOPInstanceUID, "1.2.3.4.6" },
                { DicomTag.StudyInstanceUID, "1.2.3.4" }  // Same study
            };

            deidentifier.Deidentify(dataset1);
            deidentifier.Deidentify(dataset2);

            // Same study UID should map to same remapped UID
            Assert.That(
                dataset1.GetString(DicomTag.StudyInstanceUID),
                Is.EqualTo(dataset2.GetString(DicomTag.StudyInstanceUID)));

            // Different SOP Instance UIDs should be different
            Assert.That(
                dataset1.GetString(DicomTag.SOPInstanceUID),
                Is.Not.EqualTo(dataset2.GetString(DicomTag.SOPInstanceUID)));
        }
        finally
        {
            File.Delete(dbPath);
        }
    }
}
```
  </action>
  <verify>
All tests pass: `dotnet test tests/SharpDicom.Tests --filter "DicomDeidentifier"`
  </verify>
  <done>
DeidentificationCallback enables streaming de-identification
Builder fluent API works for all options
De-identification confirmation attributes correct
UID consistency across datasets verified
All tests pass
  </done>
</task>

</tasks>

<verification>
```bash
# Build
dotnet build src/SharpDicom

# Run all de-identification tests
dotnet test tests/SharpDicom.Tests --filter "Deidentif"
```
</verification>

<success_criteria>
- DicomDeidentifier applies Basic Profile correctly
- Fluent builder supports all profile options and overrides
- De-identification Method tags populated per PS3.15
- DeidentificationContext manages persistent stores
- Element callback integration works
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-de-identification/14-05-SUMMARY.md`
</output>
