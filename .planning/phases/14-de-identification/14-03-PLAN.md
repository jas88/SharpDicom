---
phase: 14-de-identification
plan: 03
type: execute
wave: 2
depends_on: ["14-02"]
files_modified:
  - src/SharpDicom/Deidentification/UidMapper.cs
  - src/SharpDicom/Deidentification/IUidMappingStore.cs
  - src/SharpDicom/Deidentification/InMemoryUidStore.cs
  - src/SharpDicom/Deidentification/SqliteUidStore.cs
  - src/SharpDicom/Deidentification/UidRemapper.cs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "UIDs are consistently remapped within scope (study/batch)"
    - "Standard UIDs (Transfer Syntax, SOP Class) are never remapped"
    - "UID references in sequences are found and remapped"
    - "Bidirectional lookup works (original to new, new to original)"
  artifacts:
    - path: "src/SharpDicom/Deidentification/UidMapper.cs"
      provides: "Central UID mapping coordination"
      exports: ["UidMapper", "UidMappingScope"]
    - path: "src/SharpDicom/Deidentification/IUidMappingStore.cs"
      provides: "Storage abstraction for UID mappings"
      exports: ["IUidMappingStore"]
    - path: "src/SharpDicom/Deidentification/SqliteUidStore.cs"
      provides: "SQLite-backed persistent storage"
      exports: ["SqliteUidStore"]
    - path: "src/SharpDicom/Deidentification/UidRemapper.cs"
      provides: "Finds and remaps UIDs in datasets"
      exports: ["RemapUids"]
  key_links:
    - from: "UidMapper.cs"
      to: "IUidMappingStore.cs"
      via: "store dependency injection"
      pattern: "IUidMappingStore"
    - from: "UidRemapper.cs"
      to: "UidMapper.cs"
      via: "uses mapper for consistent remapping"
      pattern: "UidMapper"
---

<objective>
Implement UID remapping with SQLite persistence for consistent study-level or batch-level de-identification.

Purpose: Maintain referential integrity across de-identified datasets
Output: UidMapper with pluggable storage (in-memory or SQLite) and dataset traversal
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-de-identification/14-RESEARCH.md
@src/SharpDicom/Data/DicomUID.cs
@src/SharpDicom/Data/DicomDataset.cs
@src/SharpDicom/Data/DicomSequence.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UID mapping interfaces and in-memory store</name>
  <files>
    src/SharpDicom/Deidentification/IUidMappingStore.cs
    src/SharpDicom/Deidentification/InMemoryUidStore.cs
    src/SharpDicom/Deidentification/UidMapper.cs
  </files>
  <action>
Create IUidMappingStore interface:
```csharp
public interface IUidMappingStore : IDisposable
{
    /// <summary>Gets or creates a mapping for the original UID.</summary>
    string GetOrCreateMapping(string originalUid, string scope);

    /// <summary>Tries to get existing mapping for original UID.</summary>
    bool TryGetMapping(string originalUid, out string? remappedUid);

    /// <summary>Tries to get original UID from remapped UID (reverse lookup).</summary>
    bool TryGetOriginal(string remappedUid, out string? originalUid);

    /// <summary>Adds multiple mappings in a batch.</summary>
    void AddMappings(IEnumerable<(string Original, string Remapped, string Scope)> mappings);

    /// <summary>Exports all mappings to JSON.</summary>
    Task ExportToJsonAsync(Stream output, CancellationToken ct = default);

    /// <summary>Gets the count of stored mappings.</summary>
    int Count { get; }
}
```

Create InMemoryUidStore:
```csharp
public sealed class InMemoryUidStore : IUidMappingStore
{
    private readonly ConcurrentDictionary<string, string> _originalToNew = new();
    private readonly ConcurrentDictionary<string, string> _newToOriginal = new();
    private readonly object _lock = new();

    public string GetOrCreateMapping(string originalUid, string scope)
    {
        if (_originalToNew.TryGetValue(originalUid, out var existing))
            return existing;

        lock (_lock)
        {
            if (_originalToNew.TryGetValue(originalUid, out existing))
                return existing;

            var newUid = GenerateUid();
            _originalToNew[originalUid] = newUid;
            _newToOriginal[newUid] = originalUid;
            return newUid;
        }
    }

    // ... implement other methods

    private static string GenerateUid()
    {
        var uuid = Guid.NewGuid();
        var bytes = uuid.ToByteArray();
        Array.Reverse(bytes);
        var value = new System.Numerics.BigInteger(bytes, isUnsigned: true);
        return $"2.25.{value}";
    }
}
```

Create UidMapper facade:
```csharp
public sealed class UidMapper : IDisposable
{
    private readonly IUidMappingStore _store;
    private readonly UidMappingScope _scope;
    private readonly HashSet<string> _standardUidPrefixes;

    public UidMapper(IUidMappingStore store, UidMappingScope scope = UidMappingScope.Study)
    {
        _store = store;
        _scope = scope;
        _standardUidPrefixes = new HashSet<string>
        {
            "1.2.840.10008."  // DICOM standard UIDs
        };
    }

    public string Remap(string originalUid, string? scopeId = null)
    {
        // Never remap standard UIDs
        if (IsStandardUid(originalUid))
            return originalUid;

        var effectiveScope = scopeId ?? _scope.ToString();
        return _store.GetOrCreateMapping(originalUid, effectiveScope);
    }

    public bool TryGetOriginal(string remappedUid, out string? originalUid)
        => _store.TryGetOriginal(remappedUid, out originalUid);

    private bool IsStandardUid(string uid)
        => _standardUidPrefixes.Any(p => uid.StartsWith(p, StringComparison.Ordinal));
}

public enum UidMappingScope { Study, Series, Batch, Global }
```
  </action>
  <verify>
Build succeeds: `dotnet build src/SharpDicom`
  </verify>
  <done>
IUidMappingStore interface defined with bidirectional lookup
InMemoryUidStore implements thread-safe mapping
UidMapper facade with standard UID preservation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SQLite persistent store</name>
  <files>
    src/SharpDicom/Deidentification/SqliteUidStore.cs
  </files>
  <action>
Add Microsoft.Data.Sqlite package reference (or use System.Data.SQLite for broader compatibility).

Create SqliteUidStore:
```csharp
public sealed class SqliteUidStore : IUidMappingStore
{
    private readonly SqliteConnection _connection;
    private readonly SemaphoreSlim _writeLock = new(1, 1);

    public SqliteUidStore(string dbPath)
    {
        var connStr = new SqliteConnectionStringBuilder
        {
            DataSource = dbPath,
            Mode = SqliteOpenMode.ReadWriteCreate,
            Cache = SqliteCacheMode.Shared
        }.ToString();

        _connection = new SqliteConnection(connStr);
        _connection.Open();

        // Enable WAL mode for concurrent read/write
        using var cmd = _connection.CreateCommand();
        cmd.CommandText = "PRAGMA journal_mode=WAL;";
        cmd.ExecuteNonQuery();

        InitializeSchema();
    }

    private void InitializeSchema()
    {
        using var cmd = _connection.CreateCommand();
        cmd.CommandText = """
            CREATE TABLE IF NOT EXISTS uid_mappings (
                original_uid TEXT PRIMARY KEY,
                remapped_uid TEXT NOT NULL UNIQUE,
                scope TEXT NOT NULL,
                created_at TEXT NOT NULL DEFAULT (datetime('now')),
                expires_at TEXT
            );
            CREATE INDEX IF NOT EXISTS idx_remapped ON uid_mappings(remapped_uid);
            CREATE INDEX IF NOT EXISTS idx_scope ON uid_mappings(scope, created_at);
            """;
        cmd.ExecuteNonQuery();
    }

    public string GetOrCreateMapping(string originalUid, string scope)
    {
        // Try read first (no lock needed for reads in WAL mode)
        using (var readCmd = _connection.CreateCommand())
        {
            readCmd.CommandText = "SELECT remapped_uid FROM uid_mappings WHERE original_uid = @orig";
            readCmd.Parameters.AddWithValue("@orig", originalUid);
            var existing = readCmd.ExecuteScalar() as string;
            if (existing != null) return existing;
        }

        // Need to insert - acquire write lock
        _writeLock.Wait();
        try
        {
            // Double-check after acquiring lock
            using var checkCmd = _connection.CreateCommand();
            checkCmd.CommandText = "SELECT remapped_uid FROM uid_mappings WHERE original_uid = @orig";
            checkCmd.Parameters.AddWithValue("@orig", originalUid);
            var existing = checkCmd.ExecuteScalar() as string;
            if (existing != null) return existing;

            // Generate and insert
            var newUid = GenerateUid();
            using var insertCmd = _connection.CreateCommand();
            insertCmd.CommandText = """
                INSERT INTO uid_mappings (original_uid, remapped_uid, scope)
                VALUES (@orig, @new, @scope)
                """;
            insertCmd.Parameters.AddWithValue("@orig", originalUid);
            insertCmd.Parameters.AddWithValue("@new", newUid);
            insertCmd.Parameters.AddWithValue("@scope", scope);
            insertCmd.ExecuteNonQuery();

            return newUid;
        }
        finally
        {
            _writeLock.Release();
        }
    }

    public bool TryGetOriginal(string remappedUid, out string? originalUid)
    {
        using var cmd = _connection.CreateCommand();
        cmd.CommandText = "SELECT original_uid FROM uid_mappings WHERE remapped_uid = @new";
        cmd.Parameters.AddWithValue("@new", remappedUid);
        originalUid = cmd.ExecuteScalar() as string;
        return originalUid != null;
    }

    public async Task ExportToJsonAsync(Stream output, CancellationToken ct = default)
    {
        using var cmd = _connection.CreateCommand();
        cmd.CommandText = "SELECT original_uid, remapped_uid, scope, created_at FROM uid_mappings ORDER BY created_at";

        await using var writer = new Utf8JsonWriter(output, new JsonWriterOptions { Indented = true });
        writer.WriteStartArray();

        using var reader = await cmd.ExecuteReaderAsync(ct);
        while (await reader.ReadAsync(ct))
        {
            writer.WriteStartObject();
            writer.WriteString("original", reader.GetString(0));
            writer.WriteString("remapped", reader.GetString(1));
            writer.WriteString("scope", reader.GetString(2));
            writer.WriteString("created", reader.GetString(3));
            writer.WriteEndObject();
        }

        writer.WriteEndArray();
        await writer.FlushAsync(ct);
    }

    // ... implement remaining interface methods

    public void Dispose()
    {
        _writeLock.Dispose();
        _connection.Dispose();
    }
}
```
  </action>
  <verify>
Build succeeds with SQLite package: `dotnet build src/SharpDicom`
  </verify>
  <done>
SqliteUidStore creates database with schema
Thread-safe read/write with WAL mode
Bidirectional lookup implemented
JSON export works
  </done>
</task>

<task type="auto">
  <name>Task 3: Create UidRemapper for dataset traversal</name>
  <files>
    src/SharpDicom/Deidentification/UidRemapper.cs
    tests/SharpDicom.Tests/Deidentification/UidMapperTests.cs
    tests/SharpDicom.Tests/Deidentification/UidRemapperTests.cs
  </files>
  <action>
Create UidRemapper:
```csharp
public sealed class UidRemapper
{
    private readonly UidMapper _mapper;
    private readonly UidRemapperOptions _options;

    // Tags that are UIDs but should never be remapped
    private static readonly HashSet<DicomTag> StandardUidTags = new()
    {
        DicomTag.TransferSyntaxUID,
        DicomTag.SOPClassUID,
        DicomTag.ImplementationClassUID,
        // ... other standard UID tags
    };

    // Tags that contain UIDs and should be remapped
    private static readonly HashSet<DicomTag> RemappableUidTags = new()
    {
        DicomTag.SOPInstanceUID,
        DicomTag.StudyInstanceUID,
        DicomTag.SeriesInstanceUID,
        DicomTag.ReferencedSOPInstanceUID,
        DicomTag.FrameOfReferenceUID,
        // ... all UI VR tags from PS3.15 U action
    };

    public UidRemapper(UidMapper mapper, UidRemapperOptions? options = null)
    {
        _mapper = mapper;
        _options = options ?? new();
    }

    /// <summary>
    /// Remaps all UIDs in the dataset and nested sequences.
    /// </summary>
    public UidRemapResult RemapUids(DicomDataset dataset, string? scopeId = null)
    {
        var result = new UidRemapResult();

        // Process top-level elements
        foreach (var element in dataset.ToList())  // ToList to allow modification
        {
            ProcessElement(dataset, element, scopeId, result);
        }

        return result;
    }

    private void ProcessElement(DicomDataset dataset, IDicomElement element, string? scopeId, UidRemapResult result)
    {
        // Skip standard UID tags
        if (StandardUidTags.Contains(element.Tag))
            return;

        // Handle UI VR elements
        if (element.VR == DicomVR.UI && element is DicomStringElement strElem)
        {
            var originalUid = strElem.GetString();
            if (!string.IsNullOrEmpty(originalUid))
            {
                var newUid = _mapper.Remap(originalUid, scopeId);
                if (newUid != originalUid)
                {
                    dataset[element.Tag] = new DicomStringElement(element.Tag, DicomVR.UI, newUid);
                    result.RemappedCount++;
                }
            }
        }

        // Handle sequences recursively
        if (element is DicomSequence seq)
        {
            foreach (var item in seq.Items)
            {
                RemapUids(item, scopeId);  // Recursive call
            }
        }

        // Optionally scan text fields for embedded UIDs
        if (_options.ScanTextFields && element.VR.IsStringVR())
        {
            ScanAndReplaceEmbeddedUids(dataset, element, scopeId, result);
        }
    }

    private static readonly Regex UidPattern = new(@"\b[0-9]+(\.[0-9]+){2,}\b", RegexOptions.Compiled);

    private void ScanAndReplaceEmbeddedUids(DicomDataset dataset, IDicomElement element, string? scopeId, UidRemapResult result)
    {
        if (element is not DicomStringElement strElem) return;

        var text = strElem.GetString();
        if (string.IsNullOrEmpty(text)) return;

        var matches = UidPattern.Matches(text);
        if (matches.Count == 0) return;

        var modified = text;
        foreach (Match match in matches)
        {
            var potentialUid = match.Value;
            // Check if it looks like a UID (not just a version number)
            if (potentialUid.Length >= 10 && !potentialUid.StartsWith("1.2.840.10008."))
            {
                var newUid = _mapper.Remap(potentialUid, scopeId);
                if (newUid != potentialUid)
                {
                    modified = modified.Replace(potentialUid, newUid);
                    result.EmbeddedUidsFound++;
                }
            }
        }

        if (modified != text)
        {
            dataset[element.Tag] = DicomElement.Create(element.Tag, element.VR, modified);
        }
    }
}

public sealed class UidRemapperOptions
{
    public bool ScanTextFields { get; init; } = false;
    public bool ScanPrivateTags { get; init; } = false;
}

public sealed class UidRemapResult
{
    public int RemappedCount { get; set; }
    public int EmbeddedUidsFound { get; set; }
    public List<string> Warnings { get; } = new();
}
```

Create tests:
- Test UidMapper preserves standard UIDs
- Test UidMapper generates consistent mappings
- Test SqliteUidStore persists and retrieves mappings
- Test UidRemapper finds all UIDs in nested sequences
- Test UidRemapper handles Referenced SOP Instance UIDs
  </action>
  <verify>
All tests pass: `dotnet test tests/SharpDicom.Tests --filter "UidMapper|UidRemapper"`
  </verify>
  <done>
UidRemapper traverses datasets and sequences
Standard UIDs preserved (Transfer Syntax, SOP Class)
All UI VR elements remapped consistently
Tests verify mapping consistency and persistence
  </done>
</task>

</tasks>

<verification>
```bash
# Build
dotnet build src/SharpDicom

# Run UID tests
dotnet test tests/SharpDicom.Tests --filter "Uid"

# Verify SQLite package added
grep -r "Microsoft.Data.Sqlite" src/SharpDicom/*.csproj
```
</verification>

<success_criteria>
- UidMapper generates UUID-derived UIDs (2.25.xxx format)
- Standard UIDs never remapped
- SQLite store persists mappings across sessions
- Bidirectional lookup works
- Nested sequences fully traversed
- Tests pass for all UID scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/14-de-identification/14-03-SUMMARY.md`
</output>
