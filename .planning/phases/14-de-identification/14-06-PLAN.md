---
phase: 14-de-identification
plan: 06
type: execute
wave: 3
depends_on: ["14-02", "14-05"]
files_modified:
  - src/SharpDicom/Deidentification/DeidentificationConfig.cs
  - src/SharpDicom/Deidentification/DeidentificationConfigLoader.cs
  - src/SharpDicom/Deidentification/Presets/BasicProfile.json
  - src/SharpDicom/Deidentification/Presets/Research.json
  - src/SharpDicom/Deidentification/Presets/ClinicalTrial.json
autonomous: true
user_setup: []

must_haves:
  truths:
    - "JSON configs can be loaded to configure deidentifier"
    - "$extends inheritance resolves correctly"
    - "Presets provide ready-to-use configurations"
    - "Overrides in JSON map to tag actions"
  artifacts:
    - path: "src/SharpDicom/Deidentification/DeidentificationConfig.cs"
      provides: "JSON-serializable configuration model"
      exports: ["DeidentificationConfig"]
    - path: "src/SharpDicom/Deidentification/DeidentificationConfigLoader.cs"
      provides: "Configuration loading with inheritance"
      exports: ["LoadConfig", "LoadConfigAsync"]
    - path: "src/SharpDicom/Deidentification/Presets/"
      provides: "Built-in configuration presets"
  key_links:
    - from: "DeidentificationConfigLoader.cs"
      to: "DeidentificationConfig.cs"
      via: "JSON deserialization"
      pattern: "JsonSerializer"
    - from: "DeidentificationConfigLoader.cs"
      to: "DicomDeidentifierBuilder.cs"
      via: "applies config to builder"
      pattern: "DicomDeidentifierBuilder"
---

<objective>
Implement JSON configuration format with inheritance ($extends) and built-in presets for common use cases.

Purpose: Enable profile customization without code changes and shareable configurations
Output: DeidentificationConfig model, loader with inheritance, and Research/ClinicalTrial/Teaching presets
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-de-identification/14-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JSON configuration model</name>
  <files>
    src/SharpDicom/Deidentification/DeidentificationConfig.cs
  </files>
  <action>
Create DeidentificationConfig with JSON serialization attributes:
```csharp
using System.Text.Json.Serialization;

namespace SharpDicom.Deidentification;

/// <summary>
/// JSON-serializable configuration for de-identification.
/// </summary>
public sealed class DeidentificationConfig
{
    /// <summary>
    /// Schema URL for validation (informational).
    /// </summary>
    [JsonPropertyName("$schema")]
    public string? Schema { get; init; }

    /// <summary>
    /// Base configuration to extend. Can be a preset name or file path.
    /// </summary>
    [JsonPropertyName("$extends")]
    public string? Extends { get; init; }

    /// <summary>
    /// Profile options to enable.
    /// </summary>
    [JsonPropertyName("options")]
    public List<string>? Options { get; init; }

    /// <summary>
    /// Date shifting configuration.
    /// </summary>
    [JsonPropertyName("dateShift")]
    public DateShiftConfigJson? DateShift { get; init; }

    /// <summary>
    /// UID mapping configuration.
    /// </summary>
    [JsonPropertyName("uidMapping")]
    public UidMappingConfigJson? UidMapping { get; init; }

    /// <summary>
    /// Tag-specific action overrides. Keys are tags like "(0008,0080)" or "InstitutionName".
    /// </summary>
    [JsonPropertyName("overrides")]
    public Dictionary<string, string>? Overrides { get; init; }

    /// <summary>
    /// Default action for private tags: "remove" or "keep".
    /// </summary>
    [JsonPropertyName("privateTagDefaults")]
    public string? PrivateTagDefaults { get; init; }

    /// <summary>
    /// List of private creator strings considered safe to retain.
    /// </summary>
    [JsonPropertyName("safePrivateCreators")]
    public List<string>? SafePrivateCreators { get; init; }

    /// <summary>
    /// Whether to remove tags not in the profile table.
    /// </summary>
    [JsonPropertyName("removeUnknownTags")]
    public bool? RemoveUnknownTags { get; init; }

    /// <summary>
    /// Clinical trial attributes to add.
    /// </summary>
    [JsonPropertyName("clinicalTrial")]
    public ClinicalTrialConfigJson? ClinicalTrial { get; init; }

    /// <summary>
    /// Dummy value overrides per VR or tag.
    /// </summary>
    [JsonPropertyName("dummyValues")]
    public Dictionary<string, string>? DummyValues { get; init; }
}

public sealed class DateShiftConfigJson
{
    [JsonPropertyName("strategy")]
    public string? Strategy { get; init; }  // "fixed", "randomPerPatient", "removeTime", "remove"

    [JsonPropertyName("offsetDays")]
    public int? OffsetDays { get; init; }

    [JsonPropertyName("minOffsetDays")]
    public int? MinOffsetDays { get; init; }

    [JsonPropertyName("maxOffsetDays")]
    public int? MaxOffsetDays { get; init; }

    [JsonPropertyName("preserveTimeOfDay")]
    public bool? PreserveTimeOfDay { get; init; }

    [JsonPropertyName("randomSeed")]
    public int? RandomSeed { get; init; }
}

public sealed class UidMappingConfigJson
{
    [JsonPropertyName("scope")]
    public string? Scope { get; init; }  // "study", "series", "batch", "global"

    [JsonPropertyName("persistence")]
    public string? Persistence { get; init; }  // "memory", "sqlite"

    [JsonPropertyName("dbPath")]
    public string? DbPath { get; init; }
}

public sealed class ClinicalTrialConfigJson
{
    [JsonPropertyName("protocolId")]
    public string? ProtocolId { get; init; }

    [JsonPropertyName("protocolName")]
    public string? ProtocolName { get; init; }

    [JsonPropertyName("siteId")]
    public string? SiteId { get; init; }

    [JsonPropertyName("siteName")]
    public string? SiteName { get; init; }

    [JsonPropertyName("sponsorName")]
    public string? SponsorName { get; init; }
}
```
  </action>
  <verify>
Build succeeds: `dotnet build src/SharpDicom`
  </verify>
  <done>
DeidentificationConfig supports all configuration fields
JSON property names follow camelCase convention
Nullable types allow partial configs
ClinicalTrial attributes supported
  </done>
</task>

<task type="auto">
  <name>Task 2: Create config loader with inheritance</name>
  <files>
    src/SharpDicom/Deidentification/DeidentificationConfigLoader.cs
  </files>
  <action>
Create DeidentificationConfigLoader:
```csharp
using System.Text.Json;

namespace SharpDicom.Deidentification;

/// <summary>
/// Loads de-identification configurations with $extends inheritance support.
/// </summary>
public static class DeidentificationConfigLoader
{
    private static readonly JsonSerializerOptions JsonOptions = new()
    {
        PropertyNameCaseInsensitive = true,
        ReadCommentHandling = JsonCommentHandling.Skip,
        AllowTrailingCommas = true
    };

    // Built-in presets
    private static readonly Dictionary<string, DeidentificationConfig> Presets = new(StringComparer.OrdinalIgnoreCase)
    {
        ["basic-profile"] = CreateBasicProfileConfig(),
        ["research"] = CreateResearchConfig(),
        ["clinical-trial"] = CreateClinicalTrialConfig(),
        ["teaching"] = CreateTeachingConfig()
    };

    /// <summary>
    /// Loads configuration from a JSON file, resolving $extends references.
    /// </summary>
    public static async Task<DeidentificationConfig> LoadConfigAsync(
        string path,
        CancellationToken ct = default)
    {
        var json = await File.ReadAllTextAsync(path, ct);
        var config = JsonSerializer.Deserialize<DeidentificationConfig>(json, JsonOptions)
            ?? throw new InvalidOperationException($"Failed to parse config: {path}");

        return ResolveInheritance(config, Path.GetDirectoryName(path));
    }

    /// <summary>
    /// Loads configuration from a JSON string, resolving $extends references.
    /// </summary>
    public static DeidentificationConfig LoadConfigFromJson(string json, string? basePath = null)
    {
        var config = JsonSerializer.Deserialize<DeidentificationConfig>(json, JsonOptions)
            ?? throw new InvalidOperationException("Failed to parse config JSON");

        return ResolveInheritance(config, basePath);
    }

    /// <summary>
    /// Gets a built-in preset by name.
    /// </summary>
    public static DeidentificationConfig GetPreset(string name)
    {
        if (!Presets.TryGetValue(name, out var preset))
            throw new ArgumentException($"Unknown preset: {name}", nameof(name));

        return preset;
    }

    /// <summary>
    /// Creates a DicomDeidentifierBuilder from configuration.
    /// </summary>
    public static DicomDeidentifierBuilder CreateBuilder(DeidentificationConfig config)
    {
        var builder = new DicomDeidentifierBuilder().WithBasicProfile();

        // Apply options
        if (config.Options != null)
        {
            foreach (var optionName in config.Options)
            {
                if (TryParseOption(optionName, out var option))
                {
                    builder.WithOption(option);
                }
            }
        }

        // Apply date shift
        if (config.DateShift != null)
        {
            var dateConfig = ParseDateShiftConfig(config.DateShift);
            builder.WithDateShift(dateConfig);
        }

        // Apply overrides
        if (config.Overrides != null)
        {
            foreach (var (tagSpec, actionName) in config.Overrides)
            {
                var tag = ParseTagSpec(tagSpec);
                var action = ParseAction(actionName);
                builder.WithOverride(tag, action);
            }
        }

        // Apply private tag settings
        if (config.PrivateTagDefaults?.Equals("keep", StringComparison.OrdinalIgnoreCase) == true)
        {
            builder.KeepPrivateTags();
        }
        else if (config.PrivateTagDefaults?.Equals("remove", StringComparison.OrdinalIgnoreCase) == true)
        {
            builder.RemovePrivateTags();
        }

        // Apply safe private creators
        if (config.SafePrivateCreators?.Count > 0)
        {
            builder.WithSafePrivateCreators(config.SafePrivateCreators.ToArray());
        }

        return builder;
    }

    private static DeidentificationConfig ResolveInheritance(DeidentificationConfig config, string? basePath)
    {
        if (string.IsNullOrEmpty(config.Extends))
            return config;

        // Resolve base config
        DeidentificationConfig baseConfig;
        if (Presets.TryGetValue(config.Extends, out var preset))
        {
            baseConfig = preset;
        }
        else
        {
            // Load from file
            var path = basePath != null
                ? Path.Combine(basePath, config.Extends)
                : config.Extends;
            var json = File.ReadAllText(path);
            baseConfig = LoadConfigFromJson(json, Path.GetDirectoryName(path));
        }

        // Merge: child overrides parent
        return MergeConfigs(baseConfig, config);
    }

    private static DeidentificationConfig MergeConfigs(DeidentificationConfig parent, DeidentificationConfig child)
    {
        return new DeidentificationConfig
        {
            Options = MergeLists(parent.Options, child.Options),
            DateShift = child.DateShift ?? parent.DateShift,
            UidMapping = child.UidMapping ?? parent.UidMapping,
            Overrides = MergeDicts(parent.Overrides, child.Overrides),
            PrivateTagDefaults = child.PrivateTagDefaults ?? parent.PrivateTagDefaults,
            SafePrivateCreators = MergeLists(parent.SafePrivateCreators, child.SafePrivateCreators),
            RemoveUnknownTags = child.RemoveUnknownTags ?? parent.RemoveUnknownTags,
            ClinicalTrial = child.ClinicalTrial ?? parent.ClinicalTrial,
            DummyValues = MergeDicts(parent.DummyValues, child.DummyValues)
        };
    }

    private static List<T>? MergeLists<T>(List<T>? parent, List<T>? child)
    {
        if (child == null) return parent;
        if (parent == null) return child;
        return parent.Concat(child).Distinct().ToList();
    }

    private static Dictionary<K, V>? MergeDicts<K, V>(Dictionary<K, V>? parent, Dictionary<K, V>? child)
        where K : notnull
    {
        if (child == null) return parent;
        if (parent == null) return child;
        var merged = new Dictionary<K, V>(parent);
        foreach (var (key, value) in child)
            merged[key] = value;  // Child overrides parent
        return merged;
    }

    private static DicomTag ParseTagSpec(string spec)
    {
        // Handle "(GGGG,EEEE)" format
        if (spec.StartsWith("(") && spec.EndsWith(")"))
        {
            var parts = spec.Trim('(', ')').Split(',');
            if (parts.Length == 2 &&
                ushort.TryParse(parts[0], NumberStyles.HexNumber, null, out var group) &&
                ushort.TryParse(parts[1], NumberStyles.HexNumber, null, out var element))
            {
                return new DicomTag(group, element);
            }
        }

        // Try keyword lookup
        return DicomDictionary.GetTag(spec)
            ?? throw new ArgumentException($"Unknown tag: {spec}");
    }

    private static DeidentificationAction ParseAction(string name)
    {
        return name.ToUpperInvariant() switch
        {
            "D" or "DUMMY" => DeidentificationAction.Dummy,
            "Z" or "ZERO" => DeidentificationAction.ZeroOrDummy,
            "X" or "REMOVE" => DeidentificationAction.Remove,
            "K" or "KEEP" => DeidentificationAction.Keep,
            "C" or "CLEAN" => DeidentificationAction.Clean,
            "U" or "REMAP" or "UID" => DeidentificationAction.RemapUid,
            _ => throw new ArgumentException($"Unknown action: {name}")
        };
    }

    private static bool TryParseOption(string name, out DeidentificationOption option)
    {
        option = name.ToLowerInvariant() switch
        {
            "retainsafeprivate" => DeidentificationOption.RetainSafePrivate,
            "retainuids" => DeidentificationOption.RetainUIDs,
            "retaindeviceidentity" => DeidentificationOption.RetainDeviceIdentity,
            "retaininstitutionidentity" => DeidentificationOption.RetainInstitutionIdentity,
            "retainpatientcharacteristics" => DeidentificationOption.RetainPatientCharacteristics,
            "retainlongitudinalfulldates" => DeidentificationOption.RetainLongitudinalFullDates,
            "retainlongitudinalmodifieddates" => DeidentificationOption.RetainLongitudinalModifiedDates,
            "cleandescriptors" => DeidentificationOption.CleanDescriptors,
            "cleanstructuredcontent" => DeidentificationOption.CleanStructuredContent,
            "cleangraphics" => DeidentificationOption.CleanGraphics,
            _ => default
        };
        return option != default || name.Equals("retainsafeprivate", StringComparison.OrdinalIgnoreCase);
    }

    private static DateShiftConfig ParseDateShiftConfig(DateShiftConfigJson json)
    {
        return new DateShiftConfig
        {
            Strategy = json.Strategy?.ToLowerInvariant() switch
            {
                "fixed" => DateShiftStrategy.FixedOffset,
                "randomperpatient" => DateShiftStrategy.RandomPerPatient,
                "removetime" => DateShiftStrategy.RemoveTime,
                "remove" => DateShiftStrategy.Remove,
                _ => DateShiftStrategy.FixedOffset
            },
            FixedOffset = TimeSpan.FromDays(json.OffsetDays ?? -100),
            MinOffset = TimeSpan.FromDays(json.MinOffsetDays ?? -365),
            MaxOffset = TimeSpan.FromDays(json.MaxOffsetDays ?? 365),
            PreserveTimeOfDay = json.PreserveTimeOfDay ?? true,
            RandomSeed = json.RandomSeed
        };
    }

    // Preset factory methods
    private static DeidentificationConfig CreateBasicProfileConfig() => new()
    {
        Options = new List<string>(),
        PrivateTagDefaults = "remove",
        RemoveUnknownTags = true
    };

    private static DeidentificationConfig CreateResearchConfig() => new()
    {
        Extends = "basic-profile",
        Options = new List<string> { "RetainPatientCharacteristics", "CleanDescriptors" },
        DateShift = new DateShiftConfigJson
        {
            Strategy = "randomPerPatient",
            MinOffsetDays = -365,
            MaxOffsetDays = 365
        }
    };

    private static DeidentificationConfig CreateClinicalTrialConfig() => new()
    {
        Extends = "basic-profile",
        Options = new List<string> { "RetainLongitudinalModifiedDates", "CleanDescriptors" },
        DateShift = new DateShiftConfigJson
        {
            Strategy = "fixed",
            OffsetDays = -100
        }
    };

    private static DeidentificationConfig CreateTeachingConfig() => new()
    {
        Extends = "basic-profile",
        Options = new List<string> { "CleanDescriptors", "CleanGraphics" },
        PrivateTagDefaults = "remove"
    };
}
```
  </action>
  <verify>
Build succeeds: `dotnet build src/SharpDicom`
  </verify>
  <done>
DeidentificationConfigLoader loads JSON configs
$extends inheritance resolves correctly
Presets accessible by name
CreateBuilder applies all config options
  </done>
</task>

<task type="auto">
  <name>Task 3: Create preset JSON files and tests</name>
  <files>
    src/SharpDicom/Deidentification/Presets/README.md
    tests/SharpDicom.Tests/Deidentification/DeidentificationConfigTests.cs
  </files>
  <action>
Create README.md documenting presets (embedded in assembly):
```markdown
# De-identification Presets

Built-in presets for common de-identification scenarios:

## basic-profile
Standard PS3.15 Basic Application Level Confidentiality Profile.
- Removes all patient identifying information
- Remaps all UIDs
- Removes private tags
- Removes unknown tags

## research
For research datasets where some patient characteristics are needed.
- Extends: basic-profile
- Retains patient age, sex, ethnicity (non-identifying)
- Cleans description fields
- Random date shift per patient (Â±365 days)

## clinical-trial
For clinical trial submissions requiring temporal consistency.
- Extends: basic-profile
- Uses fixed date offset (configurable)
- Cleans description fields
- Retains modified dates for longitudinal analysis

## teaching
For teaching files where visual content is primary.
- Extends: basic-profile
- Cleans descriptions and graphics
- Removes all private tags
- Maximum de-identification
```

Create comprehensive config tests:
```csharp
[TestFixture]
public class DeidentificationConfigTests
{
    [Test]
    public void LoadConfig_BasicJson_ParsesCorrectly()
    {
        var json = """
        {
            "options": ["RetainPatientCharacteristics"],
            "dateShift": {
                "strategy": "fixed",
                "offsetDays": -50
            },
            "overrides": {
                "(0008,0080)": "K"
            }
        }
        """;

        var config = DeidentificationConfigLoader.LoadConfigFromJson(json);

        Assert.That(config.Options, Contains.Item("RetainPatientCharacteristics"));
        Assert.That(config.DateShift?.OffsetDays, Is.EqualTo(-50));
        Assert.That(config.Overrides?["(0008,0080)"], Is.EqualTo("K"));
    }

    [Test]
    public void LoadConfig_WithExtends_MergesCorrectly()
    {
        var json = """
        {
            "$extends": "basic-profile",
            "options": ["RetainUIDs"],
            "overrides": {
                "(0010,0010)": "K"
            }
        }
        """;

        var config = DeidentificationConfigLoader.LoadConfigFromJson(json);

        // Should inherit basic-profile settings and add new ones
        Assert.That(config.Options, Contains.Item("RetainUIDs"));
    }

    [Test]
    public void GetPreset_Research_ReturnsValidConfig()
    {
        var config = DeidentificationConfigLoader.GetPreset("research");

        Assert.That(config.Options, Contains.Item("RetainPatientCharacteristics"));
        Assert.That(config.DateShift?.Strategy, Is.EqualTo("randomPerPatient"));
    }

    [Test]
    public void CreateBuilder_FromConfig_AppliesAllSettings()
    {
        var config = new DeidentificationConfig
        {
            Options = new List<string> { "RetainPatientCharacteristics", "CleanDescriptors" },
            DateShift = new DateShiftConfigJson
            {
                Strategy = "fixed",
                OffsetDays = -100
            },
            Overrides = new Dictionary<string, string>
            {
                ["(0008,0080)"] = "K"
            },
            SafePrivateCreators = new List<string> { "SIEMENS CSA HEADER" }
        };

        var builder = DeidentificationConfigLoader.CreateBuilder(config);
        var deidentifier = builder.Build();

        // Builder should have applied all settings
        Assert.That(deidentifier, Is.Not.Null);
    }

    [Test]
    public void LoadConfig_InvalidJson_ThrowsException()
    {
        var json = "{ invalid json }";

        Assert.Throws<JsonException>(() =>
            DeidentificationConfigLoader.LoadConfigFromJson(json));
    }

    [Test]
    public void LoadConfig_UnknownPreset_ThrowsException()
    {
        Assert.Throws<ArgumentException>(() =>
            DeidentificationConfigLoader.GetPreset("nonexistent"));
    }

    [TestCase("(0008,0080)", "InstitutionName")]
    [TestCase("(0010,0010)", "PatientName")]
    public void ParseTagSpec_ValidFormats_ParsesCorrectly(string spec, string keyword)
    {
        // Verify tag parsing works for both formats
        var json = $@"{{ ""overrides"": {{ ""{spec}"": ""K"" }} }}";
        var config = DeidentificationConfigLoader.LoadConfigFromJson(json);

        Assert.That(config.Overrides, Is.Not.Null);
        Assert.That(config.Overrides.ContainsKey(spec), Is.True);
    }
}
```
  </action>
  <verify>
All tests pass: `dotnet test tests/SharpDicom.Tests --filter "DeidentificationConfig"`
  </verify>
  <done>
Preset documentation created
JSON config loading tested
$extends inheritance verified
CreateBuilder applies all settings
Error handling for invalid input tested
  </done>
</task>

</tasks>

<verification>
```bash
# Build
dotnet build src/SharpDicom

# Run config tests
dotnet test tests/SharpDicom.Tests --filter "DeidentificationConfig"
```
</verification>

<success_criteria>
- JSON configs load and parse correctly
- $extends inheritance works (preset names and file paths)
- Presets (Research, ClinicalTrial, Teaching) accessible
- CreateBuilder applies all configuration to deidentifier
- Invalid configs throw appropriate exceptions
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-de-identification/14-06-SUMMARY.md`
</output>
