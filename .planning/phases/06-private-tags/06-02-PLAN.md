---
phase: 06-private-tags
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified:
  - src/SharpDicom/Data/PrivateCreatorDictionary.cs
  - src/SharpDicom/Data/DicomDataset.cs
  - src/SharpDicom/Data/DicomDatasetExtensions.cs
  - src/SharpDicom/IO/DicomReaderOptions.cs
  - tests/SharpDicom.Tests/Data/PrivateCreatorDictionaryTests.cs
  - tests/SharpDicom.Tests/Data/DicomDatasetPrivateTagTests.cs
autonomous: true

must_haves:
  truths:
    - "Private creator slots can be auto-allocated when adding private tags"
    - "Existing creator slot is reused for same creator in same group"
    - "Slot compaction removes gaps when requested"
    - "Stripping private tags removes all odd-group elements including creators"
    - "Stripping recursively processes sequence items"
    - "Orphan private elements are detected in strict mode"
    - "Duplicate creator slots are detected in strict mode"
    - "Roundtrip preserves private data when not stripped"
  artifacts:
    - path: "src/SharpDicom/Data/PrivateCreatorDictionary.cs"
      provides: "Enhanced private creator tracking with allocation"
      exports: ["PrivateCreatorDictionary", "AllocateSlot", "Compact", "GetSlotForCreator"]
    - path: "src/SharpDicom/Data/DicomDatasetExtensions.cs"
      provides: "Extension methods for private tag operations"
      exports: ["StripPrivateTags", "AddPrivateElement"]
    - path: "src/SharpDicom/IO/DicomReaderOptions.cs"
      provides: "Private tag handling options"
      exports: ["RetainUnknownPrivateTags", "FailOnOrphanPrivateElements", "FailOnDuplicatePrivateSlots"]
    - path: "tests/SharpDicom.Tests/Data/PrivateCreatorDictionaryTests.cs"
      provides: "Unit tests for slot allocation"
      min_lines: 100
    - path: "tests/SharpDicom.Tests/Data/DicomDatasetPrivateTagTests.cs"
      provides: "Integration tests for private tag handling"
      min_lines: 80
  key_links:
    - from: "DicomDatasetExtensions.AddPrivateElement"
      to: "PrivateCreatorDictionary.AllocateSlot"
      via: "slot allocation"
      pattern: "AllocateSlot"
    - from: "DicomDatasetExtensions.StripPrivateTags"
      to: "DicomTag.IsPrivate"
      via: "private tag detection"
      pattern: "\\.IsPrivate"
    - from: "DicomDataset"
      to: "PrivateCreatorDictionary"
      via: "PrivateCreators property"
      pattern: "PrivateCreators"
---

<objective>
Enhance PrivateCreatorDictionary with slot allocation and compaction, add DicomDataset extensions for private tag operations, and integrate private tag handling options into DicomReaderOptions.

Purpose: Enable robust private tag handling during both reading (orphan detection, duplicate slot detection) and writing (auto-allocation, compaction), plus provide stripping API for de-identification workflows.

Output:
- Enhanced PrivateCreatorDictionary with AllocateSlot and Compact methods
- DicomDatasetExtensions with StripPrivateTags and AddPrivateElement
- DicomReaderOptions extended with private tag handling settings
- Comprehensive tests for allocation, stripping, and edge cases
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-private-tags/06-CONTEXT.md
@.planning/phases/06-private-tags/06-RESEARCH.md
@.planning/phases/06-private-tags/06-01-SUMMARY.md
@src/SharpDicom/Data/PrivateCreatorDictionary.cs
@src/SharpDicom/Data/DicomDataset.cs
@src/SharpDicom/IO/DicomReaderOptions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance PrivateCreatorDictionary with slot allocation and compaction</name>
  <files>
    - src/SharpDicom/Data/PrivateCreatorDictionary.cs
    - tests/SharpDicom.Tests/Data/PrivateCreatorDictionaryTests.cs
  </files>
  <action>
1. Enhance PrivateCreatorDictionary.cs with new methods:

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using SharpDicom.Data.Exceptions;

namespace SharpDicom.Data;

/// <summary>
/// Dictionary for tracking private tag creators.
/// Private tags use odd group numbers with creator identification:
/// (gggg,00xx) - Private Creator element (LO VR)
/// (gggg,xxyy) - Private data elements (xx = creator slot)
/// </summary>
public sealed class PrivateCreatorDictionary
{
    private readonly Dictionary<uint, string> _creators = new();

    /// <summary>
    /// Register a private creator element value during parsing.
    /// </summary>
    /// <param name="creatorTag">The private creator tag (odd group, element 0x00xx)</param>
    /// <param name="creator">The creator identifier string</param>
    /// <exception cref="ArgumentException">Tag is not a private creator tag.</exception>
    public void Register(DicomTag creatorTag, string creator)
    {
        if (!creatorTag.IsPrivateCreator)
            throw new ArgumentException("Not a private creator tag", nameof(creatorTag));

        var key = ((uint)creatorTag.Group << 16) | creatorTag.Element;
        _creators[key] = creator;
    }

    /// <summary>
    /// Look up the creator for a private data element.
    /// </summary>
    /// <param name="tag">The private data element tag</param>
    /// <returns>The creator string, or null if not registered</returns>
    public string? GetCreator(DicomTag tag)
    {
        if (!tag.IsPrivate || tag.IsPrivateCreator)
            return null;

        var creatorKey = tag.PrivateCreatorKey;
        if (creatorKey == 0)
            return null;

        return _creators.TryGetValue(creatorKey, out var creator) ? creator : null;
    }

    /// <summary>
    /// Check if a creator is registered for the given private data element.
    /// </summary>
    public bool HasCreator(DicomTag tag)
        => GetCreator(tag) != null;

    /// <summary>
    /// Gets the slot for an existing creator in a group, if registered.
    /// </summary>
    /// <param name="group">The group number (must be odd).</param>
    /// <param name="creator">The creator string to find.</param>
    /// <returns>The slot byte (0x10-0xFF), or null if not found.</returns>
    public byte? GetSlotForCreator(ushort group, string creator)
    {
        if ((group & 1) == 0)
            throw new ArgumentException("Group must be odd for private tags", nameof(group));

        foreach (var (key, c) in _creators)
        {
            var keyGroup = (ushort)(key >> 16);
            var keySlot = (byte)key;
            if (keyGroup == group && string.Equals(c, creator, StringComparison.Ordinal))
                return keySlot;
        }
        return null;
    }

    /// <summary>
    /// Allocates a slot for a private creator in the given group.
    /// If the creator already has a slot in this group, returns the existing slot.
    /// Otherwise allocates the next available slot (starting at 0x10).
    /// </summary>
    /// <param name="group">The group number (must be odd).</param>
    /// <param name="creator">The creator identifier string.</param>
    /// <returns>The private creator tag for the allocated slot.</returns>
    /// <exception cref="ArgumentException">Group is not odd.</exception>
    /// <exception cref="DicomDataException">No available slots (all 0x10-0xFF used).</exception>
    public DicomTag AllocateSlot(ushort group, string creator)
    {
        if ((group & 1) == 0)
            throw new ArgumentException("Group must be odd for private tags", nameof(group));

        if (string.IsNullOrEmpty(creator))
            throw new ArgumentException("Creator cannot be null or empty", nameof(creator));

        // Check if creator already has a slot
        var existingSlot = GetSlotForCreator(group, creator);
        if (existingSlot.HasValue)
            return new DicomTag(group, existingSlot.Value);

        // Find used slots in this group
        var usedSlots = new HashSet<byte>();
        foreach (var key in _creators.Keys)
        {
            var keyGroup = (ushort)(key >> 16);
            if (keyGroup == group)
            {
                usedSlots.Add((byte)key);
            }
        }

        // Find first unused slot (0x10-0xFF)
        for (int slot = 0x10; slot <= 0xFF; slot++)
        {
            if (!usedSlots.Contains((byte)slot))
            {
                var newTag = new DicomTag(group, (ushort)slot);
                Register(newTag, creator);
                return newTag;
            }
        }

        throw new DicomDataException($"No available private slots in group {group:X4}");
    }

    /// <summary>
    /// Compacts the slots in a group to remove gaps.
    /// Returns a mapping from old slot to new slot for updating data elements.
    /// </summary>
    /// <param name="group">The group number (must be odd).</param>
    /// <returns>Dictionary mapping old slot to new slot.</returns>
    public Dictionary<byte, byte> Compact(ushort group)
    {
        if ((group & 1) == 0)
            throw new ArgumentException("Group must be odd for private tags", nameof(group));

        var mapping = new Dictionary<byte, byte>();

        // Collect all creators in this group, ordered by current slot
        var groupCreators = _creators
            .Where(kvp => (ushort)(kvp.Key >> 16) == group)
            .OrderBy(kvp => (byte)kvp.Key)
            .ToList();

        if (groupCreators.Count == 0)
            return mapping;

        // Remove old entries
        foreach (var kvp in groupCreators)
        {
            _creators.Remove(kvp.Key);
        }

        // Re-add with compacted slots starting at 0x10
        byte newSlot = 0x10;
        foreach (var kvp in groupCreators)
        {
            var oldSlot = (byte)kvp.Key;
            var newKey = ((uint)group << 16) | newSlot;
            _creators[newKey] = kvp.Value;
            mapping[oldSlot] = newSlot;
            newSlot++;
        }

        return mapping;
    }

    /// <summary>
    /// Checks for duplicate creator slots (same slot with different creators).
    /// </summary>
    /// <returns>List of (group, slot) pairs that have duplicates.</returns>
    public IReadOnlyList<(ushort Group, byte Slot)> FindDuplicateSlots()
    {
        // Group by (group, slot), check for multiple values
        var duplicates = new List<(ushort, byte)>();

        // Since our dictionary is keyed by (group<<16 | slot), duplicates would be
        // multiple entries with the same key but different values.
        // However our dictionary prevents this by design (overwrites).
        // So "duplicates" means same creator string at different slots - not an error.
        // The real concern is detecting during PARSING when we see the same slot
        // being registered twice with different creators.

        // This method is more useful as a validation during parsing
        return duplicates;
    }

    /// <summary>
    /// Validates that a private data element has a corresponding creator registered.
    /// </summary>
    /// <param name="tag">The private data element tag to validate.</param>
    /// <returns>True if valid (has creator), false if orphan.</returns>
    public bool ValidateHasCreator(DicomTag tag)
    {
        if (!tag.IsPrivate || tag.IsPrivateCreator || tag.Element <= 0x00FF)
            return true; // Not a private data element, or is a creator itself

        return HasCreator(tag);
    }

    /// <summary>
    /// Clear all registered creators.
    /// </summary>
    public void Clear() => _creators.Clear();

    /// <summary>
    /// Get the number of registered creators.
    /// </summary>
    public int Count => _creators.Count;

    /// <summary>
    /// Get all registered creators.
    /// </summary>
    public IEnumerable<(DicomTag Tag, string Creator)> GetAll()
        => _creators.Select(kvp => (new DicomTag(kvp.Key), kvp.Value));

    /// <summary>
    /// Get all creators for a specific group.
    /// </summary>
    /// <param name="group">The group number.</param>
    public IEnumerable<(byte Slot, string Creator)> GetCreatorsInGroup(ushort group)
    {
        foreach (var (key, creator) in _creators)
        {
            var keyGroup = (ushort)(key >> 16);
            if (keyGroup == group)
                yield return ((byte)key, creator);
        }
    }
}
```

2. Create/update PrivateCreatorDictionaryTests.cs:

```csharp
using NUnit.Framework;
using SharpDicom.Data;
using SharpDicom.Data.Exceptions;
using System.Linq;

namespace SharpDicom.Tests.Data
{
    [TestFixture]
    public class PrivateCreatorDictionaryTests
    {
        private PrivateCreatorDictionary _dict = null!;

        [SetUp]
        public void SetUp()
        {
            _dict = new PrivateCreatorDictionary();
        }

        [Test]
        public void Register_PrivateCreatorTag_Succeeds()
        {
            var tag = new DicomTag(0x0019, 0x0010);
            _dict.Register(tag, "MY CREATOR");

            Assert.That(_dict.Count, Is.EqualTo(1));
        }

        [Test]
        public void Register_NonPrivateCreatorTag_Throws()
        {
            var tag = new DicomTag(0x0019, 0x1000); // Private data, not creator
            Assert.Throws<ArgumentException>(() => _dict.Register(tag, "MY CREATOR"));
        }

        [Test]
        public void Register_EvenGroupTag_Throws()
        {
            var tag = new DicomTag(0x0018, 0x0010); // Even group
            Assert.Throws<ArgumentException>(() => _dict.Register(tag, "MY CREATOR"));
        }

        [Test]
        public void GetCreator_RegisteredElement_ReturnsCreator()
        {
            var creatorTag = new DicomTag(0x0019, 0x0010);
            _dict.Register(creatorTag, "MY CREATOR");

            var dataTag = new DicomTag(0x0019, 0x1005); // Slot 0x10, offset 0x05
            var creator = _dict.GetCreator(dataTag);

            Assert.That(creator, Is.EqualTo("MY CREATOR"));
        }

        [Test]
        public void GetCreator_UnregisteredSlot_ReturnsNull()
        {
            var dataTag = new DicomTag(0x0019, 0x1005);
            var creator = _dict.GetCreator(dataTag);

            Assert.That(creator, Is.Null);
        }

        [Test]
        public void GetCreator_PrivateCreatorTag_ReturnsNull()
        {
            var creatorTag = new DicomTag(0x0019, 0x0010);
            _dict.Register(creatorTag, "MY CREATOR");

            // GetCreator should return null for creator tags themselves
            var creator = _dict.GetCreator(creatorTag);
            Assert.That(creator, Is.Null);
        }

        [Test]
        public void AllocateSlot_FirstCreator_ReturnsSlot10()
        {
            var tag = _dict.AllocateSlot(0x0019, "FIRST CREATOR");

            Assert.That(tag.Group, Is.EqualTo(0x0019));
            Assert.That(tag.Element, Is.EqualTo(0x0010));
        }

        [Test]
        public void AllocateSlot_SecondCreator_ReturnsSlot11()
        {
            _dict.AllocateSlot(0x0019, "FIRST CREATOR");
            var tag = _dict.AllocateSlot(0x0019, "SECOND CREATOR");

            Assert.That(tag.Element, Is.EqualTo(0x0011));
        }

        [Test]
        public void AllocateSlot_SameCreator_ReturnsSameSlot()
        {
            var tag1 = _dict.AllocateSlot(0x0019, "MY CREATOR");
            var tag2 = _dict.AllocateSlot(0x0019, "MY CREATOR");

            Assert.That(tag2, Is.EqualTo(tag1));
        }

        [Test]
        public void AllocateSlot_SameCreatorDifferentGroup_ReturnsDifferentSlots()
        {
            var tag1 = _dict.AllocateSlot(0x0019, "MY CREATOR");
            var tag2 = _dict.AllocateSlot(0x0021, "MY CREATOR");

            Assert.That(tag2.Group, Is.EqualTo(0x0021));
            Assert.That(tag2.Element, Is.EqualTo(0x0010)); // First slot in new group
        }

        [Test]
        public void AllocateSlot_EvenGroup_Throws()
        {
            Assert.Throws<ArgumentException>(() => _dict.AllocateSlot(0x0018, "CREATOR"));
        }

        [Test]
        public void AllocateSlot_EmptyCreator_Throws()
        {
            Assert.Throws<ArgumentException>(() => _dict.AllocateSlot(0x0019, ""));
        }

        [Test]
        public void GetSlotForCreator_ExistingCreator_ReturnsSlot()
        {
            _dict.AllocateSlot(0x0019, "MY CREATOR");

            var slot = _dict.GetSlotForCreator(0x0019, "MY CREATOR");
            Assert.That(slot, Is.EqualTo(0x10));
        }

        [Test]
        public void GetSlotForCreator_UnknownCreator_ReturnsNull()
        {
            var slot = _dict.GetSlotForCreator(0x0019, "UNKNOWN");
            Assert.That(slot, Is.Null);
        }

        [Test]
        public void Compact_WithGaps_ReassignsSlots()
        {
            // Register at slots 0x10 and 0x12 (gap at 0x11)
            _dict.Register(new DicomTag(0x0019, 0x0010), "FIRST");
            _dict.Register(new DicomTag(0x0019, 0x0012), "SECOND");

            var mapping = _dict.Compact(0x0019);

            Assert.That(mapping[0x10], Is.EqualTo(0x10)); // First stays
            Assert.That(mapping[0x12], Is.EqualTo(0x11)); // Second moves to fill gap

            // Verify new slots
            var slot1 = _dict.GetSlotForCreator(0x0019, "FIRST");
            var slot2 = _dict.GetSlotForCreator(0x0019, "SECOND");

            Assert.That(slot1, Is.EqualTo(0x10));
            Assert.That(slot2, Is.EqualTo(0x11));
        }

        [Test]
        public void Compact_EmptyGroup_ReturnsEmptyMapping()
        {
            var mapping = _dict.Compact(0x0019);
            Assert.That(mapping, Is.Empty);
        }

        [Test]
        public void Compact_NoGaps_PreservesOrder()
        {
            _dict.Register(new DicomTag(0x0019, 0x0010), "FIRST");
            _dict.Register(new DicomTag(0x0019, 0x0011), "SECOND");

            var mapping = _dict.Compact(0x0019);

            Assert.That(mapping[0x10], Is.EqualTo(0x10));
            Assert.That(mapping[0x11], Is.EqualTo(0x11));
        }

        [Test]
        public void ValidateHasCreator_OrphanElement_ReturnsFalse()
        {
            // Private data element with no creator registered
            var dataTag = new DicomTag(0x0019, 0x1005);

            Assert.That(_dict.ValidateHasCreator(dataTag), Is.False);
        }

        [Test]
        public void ValidateHasCreator_WithCreator_ReturnsTrue()
        {
            _dict.Register(new DicomTag(0x0019, 0x0010), "MY CREATOR");
            var dataTag = new DicomTag(0x0019, 0x1005);

            Assert.That(_dict.ValidateHasCreator(dataTag), Is.True);
        }

        [Test]
        public void ValidateHasCreator_PublicTag_ReturnsTrue()
        {
            var publicTag = new DicomTag(0x0008, 0x0010); // Patient Name
            Assert.That(_dict.ValidateHasCreator(publicTag), Is.True);
        }

        [Test]
        public void GetCreatorsInGroup_ReturnsOnlyGroupCreators()
        {
            _dict.Register(new DicomTag(0x0019, 0x0010), "CREATOR19A");
            _dict.Register(new DicomTag(0x0019, 0x0011), "CREATOR19B");
            _dict.Register(new DicomTag(0x0021, 0x0010), "CREATOR21");

            var creators19 = _dict.GetCreatorsInGroup(0x0019).ToList();
            var creators21 = _dict.GetCreatorsInGroup(0x0021).ToList();

            Assert.That(creators19.Count, Is.EqualTo(2));
            Assert.That(creators21.Count, Is.EqualTo(1));
        }

        [Test]
        public void Clear_RemovesAllCreators()
        {
            _dict.Register(new DicomTag(0x0019, 0x0010), "CREATOR");
            _dict.Clear();

            Assert.That(_dict.Count, Is.EqualTo(0));
        }
    }
}
```
  </action>
  <verify>
    - `dotnet build src/SharpDicom` compiles without errors
    - `dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~PrivateCreatorDictionaryTests"` passes all tests
  </verify>
  <done>
    - PrivateCreatorDictionary enhanced with AllocateSlot, Compact, GetSlotForCreator
    - ValidateHasCreator for orphan detection
    - GetCreatorsInGroup for group-specific queries
    - Comprehensive unit tests for all new functionality
  </done>
</task>

<task type="auto">
  <name>Task 2: Add DicomDatasetExtensions and integrate with DicomReaderOptions</name>
  <files>
    - src/SharpDicom/Data/DicomDatasetExtensions.cs
    - src/SharpDicom/Data/DicomDataset.cs
    - src/SharpDicom/IO/DicomReaderOptions.cs
    - tests/SharpDicom.Tests/Data/DicomDatasetPrivateTagTests.cs
  </files>
  <action>
1. Create DicomDatasetExtensions.cs:

```csharp
using System;
using System.Collections.Generic;
using System.Text;

namespace SharpDicom.Data;

/// <summary>
/// Extension methods for DicomDataset private tag operations.
/// </summary>
public static class DicomDatasetExtensions
{
    /// <summary>
    /// Strips all private tags (odd group elements) from the dataset.
    /// This includes both private creator elements and private data elements.
    /// Recursively processes sequences.
    /// </summary>
    /// <param name="dataset">The dataset to strip.</param>
    public static void StripPrivateTags(this DicomDataset dataset)
    {
        StripPrivateTags(dataset, creatorFilter: null);
    }

    /// <summary>
    /// Strips private tags from the dataset, optionally keeping specific creators.
    /// Recursively processes sequences.
    /// </summary>
    /// <param name="dataset">The dataset to strip.</param>
    /// <param name="creatorFilter">
    /// Optional filter function. Return true to KEEP the creator's tags, false to remove.
    /// If null, all private tags are removed.
    /// </param>
    public static void StripPrivateTags(
        this DicomDataset dataset,
        Func<string, bool>? creatorFilter)
    {
        // Collect tags to remove
        var tagsToRemove = new List<DicomTag>();

        // First pass: identify creators to keep
        var creatorsToKeep = new HashSet<(ushort Group, byte Slot)>();

        if (creatorFilter != null)
        {
            foreach (var (tag, creator) in dataset.PrivateCreators.GetAll())
            {
                if (creatorFilter(creator))
                {
                    creatorsToKeep.Add((tag.Group, (byte)tag.Element));
                }
            }
        }

        // Second pass: identify elements to remove
        foreach (var element in dataset)
        {
            if (!element.Tag.IsPrivate)
                continue;

            if (element.Tag.IsPrivateCreator)
            {
                // Keep creator if its tags are being kept
                var key = (element.Tag.Group, (byte)element.Tag.Element);
                if (!creatorsToKeep.Contains(key))
                {
                    tagsToRemove.Add(element.Tag);
                }
            }
            else
            {
                // Private data element - keep if creator is kept
                var slot = element.Tag.PrivateCreatorSlot;
                var key = (element.Tag.Group, slot);
                if (!creatorsToKeep.Contains(key))
                {
                    tagsToRemove.Add(element.Tag);
                }
            }
        }

        // Remove identified tags
        foreach (var tag in tagsToRemove)
        {
            dataset.Remove(tag);
        }

        // Process sequences recursively
        foreach (var element in dataset)
        {
            if (element is DicomSequenceElement seq)
            {
                foreach (var item in seq.Items)
                {
                    item.StripPrivateTags(creatorFilter);
                }
            }
        }
    }

    /// <summary>
    /// Adds a private element to the dataset, automatically allocating a creator slot.
    /// </summary>
    /// <param name="dataset">The dataset to add to.</param>
    /// <param name="group">The group number (must be odd).</param>
    /// <param name="creator">The private creator identifier.</param>
    /// <param name="elementOffset">The element offset within the creator's block (0x00-0xFF).</param>
    /// <param name="vr">The value representation.</param>
    /// <param name="value">The value bytes.</param>
    /// <returns>The tag of the added element.</returns>
    /// <exception cref="ArgumentException">Group is not odd.</exception>
    public static DicomTag AddPrivateElement(
        this DicomDataset dataset,
        ushort group,
        string creator,
        byte elementOffset,
        DicomVR vr,
        ReadOnlyMemory<byte> value)
    {
        if ((group & 1) == 0)
            throw new ArgumentException("Private tags require odd group number", nameof(group));

        // Allocate or reuse slot
        var creatorTag = dataset.PrivateCreators.AllocateSlot(group, creator);
        var slot = (byte)creatorTag.Element;

        // Build full element number
        var fullElement = (ushort)((slot << 8) | elementOffset);
        var dataTag = new DicomTag(group, fullElement);

        // Add creator element if not already present
        if (dataset[creatorTag] == null)
        {
            // Creator is LO VR, padded with space to even length
            var creatorBytes = Encoding.ASCII.GetBytes(creator);
            if (creatorBytes.Length % 2 != 0)
            {
                var padded = new byte[creatorBytes.Length + 1];
                creatorBytes.CopyTo(padded, 0);
                padded[^1] = (byte)' ';
                creatorBytes = padded;
            }
            dataset.Add(new DicomStringElement(creatorTag, DicomVR.LO, creatorBytes));
        }

        // Add or update data element
        var element = DicomElement.Create(dataTag, vr, value);
        dataset.AddOrUpdate(element);

        return dataTag;
    }

    /// <summary>
    /// Adds a private string element to the dataset.
    /// </summary>
    public static DicomTag AddPrivateString(
        this DicomDataset dataset,
        ushort group,
        string creator,
        byte elementOffset,
        DicomVR vr,
        string value)
    {
        var bytes = Encoding.ASCII.GetBytes(value);
        if (bytes.Length % 2 != 0)
        {
            var padded = new byte[bytes.Length + 1];
            bytes.CopyTo(padded, 0);
            padded[^1] = vr.PaddingByte();
            bytes = padded;
        }
        return AddPrivateElement(dataset, group, creator, elementOffset, vr, bytes);
    }

    /// <summary>
    /// Checks if the dataset contains any orphan private elements
    /// (private data elements without corresponding creator).
    /// </summary>
    /// <param name="dataset">The dataset to check.</param>
    /// <returns>List of orphan element tags.</returns>
    public static IReadOnlyList<DicomTag> FindOrphanPrivateElements(this DicomDataset dataset)
    {
        var orphans = new List<DicomTag>();

        foreach (var element in dataset)
        {
            if (element.Tag.IsPrivate &&
                !element.Tag.IsPrivateCreator &&
                element.Tag.Element > 0x00FF)
            {
                if (!dataset.PrivateCreators.ValidateHasCreator(element.Tag))
                {
                    orphans.Add(element.Tag);
                }
            }
        }

        return orphans;
    }

    /// <summary>
    /// Gets the padding byte for a VR.
    /// </summary>
    private static byte PaddingByte(this DicomVR vr)
    {
        // UI, OB, OD, OF, OL, OW, OV, SQ, UC, UN, UR, UT use null padding
        // All others use space padding
        var code = vr.ToString();
        return code switch
        {
            "UI" or "OB" or "OD" or "OF" or "OL" or "OW" or "OV" or
            "SQ" or "UC" or "UN" or "UR" or "UT" => 0x00,
            _ => 0x20
        };
    }
}
```

2. Update DicomReaderOptions.cs to add private tag handling options.

Add these properties after existing options:

```csharp
/// <summary>
/// Whether to retain private tags with unknown creators. Default: true.
/// If false, private tags with unrecognized creators are discarded during parsing.
/// </summary>
public bool RetainUnknownPrivateTags { get; init; } = true;

/// <summary>
/// Whether to fail when orphan private elements are detected. Default: false.
/// Orphan elements are private data elements without a corresponding creator.
/// Set to true for strict mode validation.
/// </summary>
public bool FailOnOrphanPrivateElements { get; init; } = false;

/// <summary>
/// Whether to fail when duplicate private creator slots are detected. Default: false.
/// Duplicate slots occur when the same slot is assigned to different creators.
/// Set to true for strict mode validation.
/// </summary>
public bool FailOnDuplicatePrivateSlots { get; init; } = false;
```

Also update the Strict preset:

```csharp
public static readonly DicomReaderOptions Strict = new()
{
    // ... existing strict options ...
    FailOnOrphanPrivateElements = true,
    FailOnDuplicatePrivateSlots = true,
};
```

3. Create DicomDatasetPrivateTagTests.cs:

```csharp
using NUnit.Framework;
using SharpDicom.Data;
using System;
using System.Linq;
using System.Text;

namespace SharpDicom.Tests.Data
{
    [TestFixture]
    public class DicomDatasetPrivateTagTests
    {
        [Test]
        public void StripPrivateTags_RemovesAllPrivate()
        {
            var dataset = new DicomDataset();

            // Add public tag
            dataset.Add(new DicomStringElement(
                DicomTag.PatientName, DicomVR.PN, Encoding.ASCII.GetBytes("Test^Patient")));

            // Add private creator and data
            dataset.AddPrivateString(0x0019, "MY CREATOR", 0x01, DicomVR.LO, "Private Value");

            // Verify private tag exists
            Assert.That(dataset.Count(), Is.EqualTo(3)); // PatientName + creator + data

            // Strip
            dataset.StripPrivateTags();

            // Verify only public remains
            Assert.That(dataset.Count(), Is.EqualTo(1));
            Assert.That(dataset[DicomTag.PatientName], Is.Not.Null);
        }

        [Test]
        public void StripPrivateTags_WithFilter_KeepsMatchingCreator()
        {
            var dataset = new DicomDataset();

            // Add two private creators
            dataset.AddPrivateString(0x0019, "KEEP ME", 0x01, DicomVR.LO, "Keep This");
            dataset.AddPrivateString(0x0019, "REMOVE ME", 0x01, DicomVR.LO, "Remove This");

            // Strip with filter that keeps "KEEP ME"
            dataset.StripPrivateTags(creator => creator == "KEEP ME");

            // Verify KEEP ME data remains
            var creators = dataset.PrivateCreators.GetAll().ToList();
            Assert.That(creators.Count, Is.EqualTo(1));
            Assert.That(creators[0].Creator, Is.EqualTo("KEEP ME"));
        }

        [Test]
        public void StripPrivateTags_ProcessesSequences()
        {
            var dataset = new DicomDataset();
            var item = new DicomDataset();

            // Add private tag to sequence item
            item.AddPrivateString(0x0019, "NESTED CREATOR", 0x01, DicomVR.LO, "Nested Value");

            // Add sequence to main dataset
            var sequence = new DicomSequenceElement(DicomTag.Parse("(0040,A730)"), new[] { item });
            dataset.Add(sequence);

            // Strip private tags
            dataset.StripPrivateTags();

            // Verify sequence item's private tags are also stripped
            var strippedItem = ((DicomSequenceElement)dataset.First()).Items.First();
            Assert.That(strippedItem.Any(e => e.Tag.IsPrivate), Is.False);
        }

        [Test]
        public void AddPrivateElement_AllocatesSlot()
        {
            var dataset = new DicomDataset();

            var tag = dataset.AddPrivateString(0x0019, "MY CREATOR", 0x10, DicomVR.LO, "Test Value");

            Assert.That(tag.Group, Is.EqualTo(0x0019));
            Assert.That(tag.Element, Is.EqualTo(0x1010)); // Slot 0x10 + offset 0x10

            // Verify creator was added
            var creatorTag = new DicomTag(0x0019, 0x0010);
            Assert.That(dataset[creatorTag], Is.Not.Null);
        }

        [Test]
        public void AddPrivateElement_ReusesSameCreatorSlot()
        {
            var dataset = new DicomDataset();

            var tag1 = dataset.AddPrivateString(0x0019, "MY CREATOR", 0x01, DicomVR.LO, "Value 1");
            var tag2 = dataset.AddPrivateString(0x0019, "MY CREATOR", 0x02, DicomVR.LO, "Value 2");

            // Both should use same slot (0x10)
            Assert.That(tag1.Element >> 8, Is.EqualTo(0x10));
            Assert.That(tag2.Element >> 8, Is.EqualTo(0x10));

            // Different offsets
            Assert.That(tag1.Element & 0xFF, Is.EqualTo(0x01));
            Assert.That(tag2.Element & 0xFF, Is.EqualTo(0x02));
        }

        [Test]
        public void AddPrivateElement_DifferentCreators_DifferentSlots()
        {
            var dataset = new DicomDataset();

            var tag1 = dataset.AddPrivateString(0x0019, "CREATOR A", 0x01, DicomVR.LO, "Value A");
            var tag2 = dataset.AddPrivateString(0x0019, "CREATOR B", 0x01, DicomVR.LO, "Value B");

            // Different slots
            Assert.That(tag1.Element >> 8, Is.EqualTo(0x10));
            Assert.That(tag2.Element >> 8, Is.EqualTo(0x11));
        }

        [Test]
        public void AddPrivateElement_EvenGroup_Throws()
        {
            var dataset = new DicomDataset();

            Assert.Throws<ArgumentException>(() =>
                dataset.AddPrivateString(0x0018, "CREATOR", 0x01, DicomVR.LO, "Value"));
        }

        [Test]
        public void FindOrphanPrivateElements_DetectsOrphans()
        {
            var dataset = new DicomDataset();

            // Manually add private data without creator
            var orphanTag = new DicomTag(0x0019, 0x1010);
            dataset.Add(new DicomStringElement(orphanTag, DicomVR.LO, Encoding.ASCII.GetBytes("Orphan")));

            var orphans = dataset.FindOrphanPrivateElements();

            Assert.That(orphans.Count, Is.EqualTo(1));
            Assert.That(orphans[0], Is.EqualTo(orphanTag));
        }

        [Test]
        public void FindOrphanPrivateElements_NoOrphans_ReturnsEmpty()
        {
            var dataset = new DicomDataset();

            // Add proper private element with creator
            dataset.AddPrivateString(0x0019, "MY CREATOR", 0x01, DicomVR.LO, "Value");

            var orphans = dataset.FindOrphanPrivateElements();

            Assert.That(orphans, Is.Empty);
        }

        [Test]
        public void PrivateCreators_ExposedOnDataset()
        {
            var dataset = new DicomDataset();

            dataset.AddPrivateString(0x0019, "MY CREATOR", 0x01, DicomVR.LO, "Value");

            Assert.That(dataset.PrivateCreators.Count, Is.EqualTo(1));
            var creator = dataset.PrivateCreators.GetCreator(new DicomTag(0x0019, 0x1001));
            Assert.That(creator, Is.EqualTo("MY CREATOR"));
        }
    }
}
```

4. Ensure DicomDataset exposes PrivateCreators (if not already):

Check DicomDataset.cs has:
```csharp
public PrivateCreatorDictionary PrivateCreators { get; } = new();
```

If not present, add it. The property should already exist from Phase 1.
  </action>
  <verify>
    - `dotnet build src/SharpDicom` compiles without errors
    - `dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomDatasetPrivateTagTests"` passes all tests
    - `dotnet test tests/SharpDicom.Tests` all tests pass (no regressions)
  </verify>
  <done>
    - DicomDatasetExtensions provides StripPrivateTags and AddPrivateElement
    - StripPrivateTags recursively processes sequences
    - AddPrivateElement auto-allocates creator slots
    - FindOrphanPrivateElements detects orphan elements
    - DicomReaderOptions has RetainUnknownPrivateTags, FailOnOrphanPrivateElements, FailOnDuplicatePrivateSlots
    - Strict preset enables private tag validation
    - Comprehensive integration tests pass
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build the project:
   ```bash
   dotnet build src/SharpDicom
   ```

2. Run private creator dictionary tests:
   ```bash
   dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~PrivateCreatorDictionaryTests"
   ```

3. Run private tag integration tests:
   ```bash
   dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomDatasetPrivateTagTests"
   ```

4. Run all tests to ensure no regressions:
   ```bash
   dotnet test
   ```

5. Verify phase requirements (from ROADMAP.md):
   - Private creator tracking: PrivateCreatorDictionary enhanced
   - Siemens/GE/Philips tags recognized: VendorDictionary from Plan 01
   - Strip-private callback works: StripPrivateTags with creatorFilter
   - Roundtrip preserves private data: AddPrivateElement + existing read/write
</verification>

<success_criteria>
- [ ] PrivateCreatorDictionary.AllocateSlot allocates sequential slots
- [ ] PrivateCreatorDictionary.Compact removes gaps in slot numbering
- [ ] DicomDatasetExtensions.StripPrivateTags removes all private elements
- [ ] DicomDatasetExtensions.StripPrivateTags with filter keeps specified creators
- [ ] DicomDatasetExtensions.AddPrivateElement auto-allocates slots
- [ ] DicomDatasetExtensions.FindOrphanPrivateElements detects orphans
- [ ] DicomReaderOptions includes private tag handling settings
- [ ] Strict preset enables private tag validation
- [ ] All new tests pass
- [ ] All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-private-tags/06-02-SUMMARY.md`
</output>
