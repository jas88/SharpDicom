---
phase: 02-basic-file-reading
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/SharpDicom/IO/DicomFileReader.cs
  - tests/SharpDicom.Tests/IO/DicomFileReaderTests.cs
autonomous: true

must_haves:
  truths:
    - "DicomFileReader provides async streaming element access"
    - "IAsyncEnumerable<IDicomElement> streams elements without loading entire file"
    - "ReadDatasetAsync loads complete dataset into memory"
    - "Cancellation token respected during parsing"
  artifacts:
    - path: "src/SharpDicom/IO/DicomFileReader.cs"
      provides: "High-level async DICOM file reader"
      min_lines: 150
    - path: "tests/SharpDicom.Tests/IO/DicomFileReaderTests.cs"
      provides: "File reader tests"
      min_lines: 80
  key_links:
    - from: "src/SharpDicom/IO/DicomFileReader.cs"
      to: "src/SharpDicom/IO/Part10Reader.cs"
      via: "header parsing"
      pattern: "Part10Reader"
---

<objective>
Implement the high-level DicomFileReader with async streaming support.

Purpose: Provide convenient async API for reading DICOM files with streaming element access.

Output:
- DicomFileReader with IAsyncEnumerable streaming
- ReadDatasetAsync for full dataset loading
- Proper resource management (IAsyncDisposable)
- Unit tests for file reading
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-basic-file-reading/02-CONTEXT.md
@.planning/phases/02-basic-file-reading/02-01-SUMMARY.md
@.planning/phases/02-basic-file-reading/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DicomFileReader</name>
  <files>
    src/SharpDicom/IO/DicomFileReader.cs
  </files>
  <action>
Implement high-level async file reader:

```csharp
using System.Buffers;
using System.Runtime.CompilerServices;
using SharpDicom.Data;

namespace SharpDicom.IO;

/// <summary>
/// High-level async DICOM file reader with streaming support.
/// </summary>
public sealed class DicomFileReader : IAsyncDisposable
{
    private readonly Stream _stream;
    private readonly bool _leaveOpen;
    private readonly DicomReaderOptions _options;
    private readonly ArrayPool<byte> _pool;
    private byte[]? _buffer;
    private int _bufferLength;
    private Part10Reader? _part10Reader;
    private bool _headerParsed;
    private bool _disposed;

    private const int DefaultBufferSize = 64 * 1024; // 64 KB

    /// <summary>File Meta Information (available after reading header).</summary>
    public DicomDataset? FileMetaInfo => _part10Reader?.FileMetaInfo;

    /// <summary>Transfer Syntax (available after reading header).</summary>
    public TransferSyntax TransferSyntax => _part10Reader?.TransferSyntax ?? TransferSyntax.ImplicitVRLittleEndian;

    /// <summary>Preamble bytes (available after reading header).</summary>
    public ReadOnlyMemory<byte> Preamble => _part10Reader?.Preamble ?? ReadOnlyMemory<byte>.Empty;

    public DicomFileReader(Stream stream, DicomReaderOptions? options = null, bool leaveOpen = false)
    {
        _stream = stream ?? throw new ArgumentNullException(nameof(stream));
        _options = options ?? DicomReaderOptions.Default;
        _leaveOpen = leaveOpen;
        _pool = ArrayPool<byte>.Shared;
    }

    /// <summary>
    /// Read and parse the file header (preamble, DICM, File Meta Information).
    /// </summary>
    public async ValueTask ReadFileMetaInfoAsync(CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (_headerParsed)
            return;

        // Read enough data for header detection
        _buffer = _pool.Rent(DefaultBufferSize);
        _bufferLength = await _stream.ReadAsync(_buffer.AsMemory(), ct).ConfigureAwait(false);

        if (_bufferLength == 0)
            throw new DicomFileException("Empty file");

        _part10Reader = new Part10Reader(_options);
        _part10Reader.TryParseHeader(_buffer.AsSpan(0, _bufferLength));
        _headerParsed = true;
    }

    /// <summary>
    /// Stream dataset elements asynchronously.
    /// </summary>
    public async IAsyncEnumerable<IDicomElement> ReadElementsAsync(
        [EnumeratorCancellation] CancellationToken ct = default)
    {
        ThrowIfDisposed();

        if (!_headerParsed)
            await ReadFileMetaInfoAsync(ct).ConfigureAwait(false);

        var position = _part10Reader!.DatasetStartPosition;
        var ts = TransferSyntax;
        var explicitVR = ts.IsExplicitVR;
        var littleEndian = ts.IsLittleEndian;

        // Process buffered data first
        foreach (var element in ParseElements(_buffer.AsSpan(position, _bufferLength - position),
            explicitVR, littleEndian))
        {
            yield return element;
        }

        // Continue reading from stream
        while (true)
        {
            ct.ThrowIfCancellationRequested();

            _bufferLength = await _stream.ReadAsync(_buffer.AsMemory(), ct).ConfigureAwait(false);
            if (_bufferLength == 0)
                break;

            foreach (var element in ParseElements(_buffer.AsSpan(0, _bufferLength),
                explicitVR, littleEndian))
            {
                yield return element;
            }
        }
    }

    /// <summary>
    /// Read the complete dataset into memory.
    /// </summary>
    public async ValueTask<DicomDataset> ReadDatasetAsync(CancellationToken ct = default)
    {
        var dataset = new DicomDataset();

        await foreach (var element in ReadElementsAsync(ct).ConfigureAwait(false))
        {
            dataset.Add(element);
        }

        return dataset;
    }

    private IEnumerable<IDicomElement> ParseElements(ReadOnlySpan<byte> buffer,
        bool explicitVR, bool littleEndian)
    {
        var reader = new DicomStreamReader(buffer, explicitVR, littleEndian, _options);

        while (!reader.IsAtEnd)
        {
            if (!reader.TryReadElementHeader(out var tag, out var vr, out var length))
                break;

            // Skip sequences and undefined length for now (Phase 3)
            if (length == 0xFFFFFFFF || vr == DicomVR.SQ)
            {
                // TODO: Handle in Phase 3
                continue;
            }

            if (!reader.TryReadValue(length, out var value))
                break;

            yield return CreateElement(tag, vr, value.ToArray());
        }
    }

    private static IDicomElement CreateElement(DicomTag tag, DicomVR vr, byte[] value)
    {
        if (vr.IsStringVR)
            return new DicomStringElement(tag, vr, value);
        else if (vr.IsNumericVR)
            return new DicomNumericElement(tag, vr, value);
        else
            return new DicomBinaryElement(tag, vr, value);
    }

    private void ThrowIfDisposed()
    {
        if (_disposed)
            throw new ObjectDisposedException(nameof(DicomFileReader));
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed)
            return;

        _disposed = true;

        if (_buffer != null)
        {
            _pool.Return(_buffer);
            _buffer = null;
        }

        if (!_leaveOpen)
        {
            await _stream.DisposeAsync().ConfigureAwait(false);
        }
    }
}
```

Note: This implementation handles basic Explicit VR elements. Sequences and undefined length will be added in Phase 3.
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    DicomFileReader compiles with async streaming support
  </done>
</task>

<task type="auto">
  <name>Task 2: Add TransferSyntax properties</name>
  <files>
    src/SharpDicom/Data/TransferSyntax.cs
  </files>
  <action>
Ensure TransferSyntax has the required properties (may already exist from Phase 1):

```csharp
// Add if not present:
public bool IsExplicitVR { get; }
public bool IsLittleEndian { get; }
public bool IsEncapsulated { get; }
```

Check the existing TransferSyntax implementation and add any missing properties.
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    TransferSyntax has all required properties
  </done>
</task>

<task type="auto">
  <name>Task 3: Write DicomFileReader tests</name>
  <files>
    tests/SharpDicom.Tests/IO/DicomFileReaderTests.cs
  </files>
  <action>
Write tests for DicomFileReader:

```csharp
namespace SharpDicom.Tests.IO;

[TestFixture]
public class DicomFileReaderTests
{
    [Test]
    public async Task ReadFileMetaInfoAsync_ParsesHeader()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        await using var reader = new DicomFileReader(stream);
        await reader.ReadFileMetaInfoAsync();

        Assert.That(reader.FileMetaInfo, Is.Not.Null);
        Assert.That(reader.TransferSyntax.IsKnown, Is.True);
    }

    [Test]
    public async Task ReadElementsAsync_StreamsElements()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        await using var reader = new DicomFileReader(stream);
        var elements = new List<IDicomElement>();

        await foreach (var element in reader.ReadElementsAsync())
        {
            elements.Add(element);
        }

        Assert.That(elements, Is.Not.Empty);
    }

    [Test]
    public async Task ReadDatasetAsync_ReturnsCompleteDataset()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        await using var reader = new DicomFileReader(stream);
        var dataset = await reader.ReadDatasetAsync();

        Assert.That(dataset, Is.Not.Null);
        Assert.That(dataset.Count, Is.GreaterThan(0));
    }

    [Test]
    public async Task ReadElementsAsync_RespectsCancellation()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);
        using var cts = new CancellationTokenSource();

        await using var reader = new DicomFileReader(stream);

        cts.Cancel();

        Assert.ThrowsAsync<OperationCanceledException>(async () =>
        {
            await foreach (var _ in reader.ReadElementsAsync(cts.Token))
            {
            }
        });
    }

    [Test]
    public async Task DisposeAsync_ReleasesResources()
    {
        var data = CreateTestDicomFile();
        var stream = new MemoryStream(data);

        var reader = new DicomFileReader(stream, leaveOpen: false);
        await reader.DisposeAsync();

        // Stream should be disposed
        Assert.Throws<ObjectDisposedException>(() => stream.ReadByte());
    }

    [Test]
    public async Task LeaveOpen_KeepsStreamOpen()
    {
        var data = CreateTestDicomFile();
        var stream = new MemoryStream(data);

        var reader = new DicomFileReader(stream, leaveOpen: true);
        await reader.DisposeAsync();

        // Stream should still be accessible
        stream.Position = 0;
        Assert.That(stream.ReadByte(), Is.Not.EqualTo(-1));
    }

    [Test]
    public async Task Preamble_AvailableAfterHeaderParsed()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        await using var reader = new DicomFileReader(stream);
        await reader.ReadFileMetaInfoAsync();

        Assert.That(reader.Preamble.Length, Is.EqualTo(128));
    }

    private static byte[] CreateTestDicomFile()
    {
        using var ms = new MemoryStream();

        // 128 byte preamble
        ms.Write(new byte[128]);

        // DICM prefix
        ms.Write("DICM"u8);

        // File Meta Information (Explicit VR LE)
        WriteElement(ms, 0x0002, 0x0010, "UI", "1.2.840.10008.1.2.1\0"u8.ToArray());

        // Dataset elements
        WriteElement(ms, 0x0008, 0x0005, "CS", "ISO_IR 100 "u8.ToArray());
        WriteElement(ms, 0x0008, 0x0016, "UI", "1.2.840.10008.5.1.4.1.1.2\0"u8.ToArray());
        WriteElement(ms, 0x0008, 0x0060, "CS", "CT "u8.ToArray());
        WriteElement(ms, 0x0010, 0x0010, "PN", "Doe^John"u8.ToArray());
        WriteElement(ms, 0x0010, 0x0020, "LO", "PATIENT001"u8.ToArray());

        return ms.ToArray();
    }

    private static void WriteElement(MemoryStream ms, ushort group, ushort element,
        string vr, byte[] value)
    {
        ms.Write(BitConverter.GetBytes(group));
        ms.Write(BitConverter.GetBytes(element));
        ms.Write(System.Text.Encoding.ASCII.GetBytes(vr));

        var vrCode = DicomVR.FromString(vr);
        if (vrCode.Is32BitLength)
        {
            ms.Write(new byte[2]); // Reserved
            ms.Write(BitConverter.GetBytes((uint)value.Length));
        }
        else
        {
            ms.Write(BitConverter.GetBytes((ushort)value.Length));
        }

        ms.Write(value);
    }
}
```
  </action>
  <verify>
    dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomFileReaderTests" --configuration Release
  </verify>
  <done>
    DicomFileReader tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Solution builds
2. All file reader tests pass
3. Async streaming works correctly
</verification>

<success_criteria>
- DicomFileReader provides async streaming element access
- IAsyncEnumerable streams elements without loading entire file
- ReadDatasetAsync loads complete dataset
- Cancellation token respected
</success_criteria>

<output>
After completion, create `.planning/phases/02-basic-file-reading/02-03-SUMMARY.md`
</output>
