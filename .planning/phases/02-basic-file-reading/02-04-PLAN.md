---
phase: 02-basic-file-reading
plan: 04
type: execute
wave: 2
depends_on: ["02-03"]
files_modified:
  - src/SharpDicom/DicomFile.cs
  - tests/SharpDicom.Tests/DicomFileTests.cs
  - tests/SharpDicom.Tests/Integration/ExplicitVRLETests.cs
autonomous: true

must_haves:
  truths:
    - "DicomFile provides convenient static Open/OpenAsync methods"
    - "DicomFile contains FileMetaInfo, Dataset, and TransferSyntax"
    - "Integration tests verify parsing of Explicit VR LE files"
    - "All Phase 2 tests pass"
  artifacts:
    - path: "src/SharpDicom/DicomFile.cs"
      provides: "High-level DicomFile class"
      min_lines: 80
    - path: "tests/SharpDicom.Tests/DicomFileTests.cs"
      provides: "DicomFile unit tests"
      min_lines: 60
    - path: "tests/SharpDicom.Tests/Integration/ExplicitVRLETests.cs"
      provides: "Explicit VR LE integration tests"
      min_lines: 50
  key_links:
    - from: "src/SharpDicom/DicomFile.cs"
      to: "src/SharpDicom/IO/DicomFileReader.cs"
      via: "file reading"
      pattern: "DicomFileReader"
---

<objective>
Implement the DicomFile class and complete Phase 2 with integration tests.

Purpose: Provide the main user-facing class for DICOM file operations.

Output:
- DicomFile class with static factory methods
- Unit tests for DicomFile
- Integration tests for Explicit VR LE parsing
- Phase 2 verification
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-basic-file-reading/02-CONTEXT.md
@.planning/phases/02-basic-file-reading/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DicomFile class</name>
  <files>
    src/SharpDicom/DicomFile.cs
  </files>
  <action>
Implement the main DicomFile class:

```csharp
using SharpDicom.Data;
using SharpDicom.IO;

namespace SharpDicom;

/// <summary>
/// Represents a DICOM Part 10 file.
/// </summary>
public sealed class DicomFile
{
    /// <summary>128-byte preamble (may be empty if file had no preamble).</summary>
    public ReadOnlyMemory<byte> Preamble { get; }

    /// <summary>File Meta Information (Group 0002 elements).</summary>
    public DicomDataset FileMetaInfo { get; }

    /// <summary>Main dataset content.</summary>
    public DicomDataset Dataset { get; }

    /// <summary>Transfer Syntax used for the dataset.</summary>
    public TransferSyntax TransferSyntax { get; }

    /// <summary>
    /// Create a new DicomFile from a dataset.
    /// </summary>
    public DicomFile(DicomDataset dataset, TransferSyntax? transferSyntax = null)
    {
        Dataset = dataset ?? throw new ArgumentNullException(nameof(dataset));
        TransferSyntax = transferSyntax ?? TransferSyntax.ExplicitVRLittleEndian;
        FileMetaInfo = new DicomDataset();
        Preamble = new byte[128];
    }

    /// <summary>
    /// Create a DicomFile with explicit components.
    /// </summary>
    internal DicomFile(
        ReadOnlyMemory<byte> preamble,
        DicomDataset fileMetaInfo,
        DicomDataset dataset,
        TransferSyntax transferSyntax)
    {
        Preamble = preamble;
        FileMetaInfo = fileMetaInfo;
        Dataset = dataset;
        TransferSyntax = transferSyntax;
    }

    /// <summary>
    /// Open a DICOM file from the specified path.
    /// </summary>
    public static DicomFile Open(string path, DicomReaderOptions? options = null)
    {
        using var stream = File.OpenRead(path);
        return Open(stream, options);
    }

    /// <summary>
    /// Open a DICOM file from a stream.
    /// </summary>
    public static DicomFile Open(Stream stream, DicomReaderOptions? options = null)
    {
        return OpenAsync(stream, options).AsTask().GetAwaiter().GetResult();
    }

    /// <summary>
    /// Open a DICOM file asynchronously from the specified path.
    /// </summary>
    public static async ValueTask<DicomFile> OpenAsync(
        string path,
        DicomReaderOptions? options = null,
        CancellationToken ct = default)
    {
        await using var stream = new FileStream(
            path,
            FileMode.Open,
            FileAccess.Read,
            FileShare.Read,
            bufferSize: 4096,
            useAsync: true);

        return await OpenAsync(stream, options, ct).ConfigureAwait(false);
    }

    /// <summary>
    /// Open a DICOM file asynchronously from a stream.
    /// </summary>
    public static async ValueTask<DicomFile> OpenAsync(
        Stream stream,
        DicomReaderOptions? options = null,
        CancellationToken ct = default)
    {
        await using var reader = new DicomFileReader(stream, options, leaveOpen: true);

        await reader.ReadFileMetaInfoAsync(ct).ConfigureAwait(false);
        var dataset = await reader.ReadDatasetAsync(ct).ConfigureAwait(false);

        return new DicomFile(
            reader.Preamble,
            reader.FileMetaInfo ?? new DicomDataset(),
            dataset,
            reader.TransferSyntax);
    }

    /// <summary>
    /// Get a string value from the dataset.
    /// </summary>
    public string? GetString(DicomTag tag)
        => Dataset.GetString(tag);

    /// <summary>
    /// Check if a tag exists in the dataset.
    /// </summary>
    public bool Contains(DicomTag tag)
        => Dataset.Contains(tag);

    /// <summary>
    /// Get an element from the dataset.
    /// </summary>
    public IDicomElement? this[DicomTag tag]
        => Dataset[tag];
}
```
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    DicomFile compiles with factory methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Write DicomFile unit tests</name>
  <files>
    tests/SharpDicom.Tests/DicomFileTests.cs
  </files>
  <action>
Write unit tests for DicomFile:

```csharp
namespace SharpDicom.Tests;

[TestFixture]
public class DicomFileTests
{
    [Test]
    public async Task OpenAsync_FromStream_ReturnsValidFile()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        Assert.That(file, Is.Not.Null);
        Assert.That(file.Dataset, Is.Not.Null);
        Assert.That(file.FileMetaInfo, Is.Not.Null);
    }

    [Test]
    public async Task OpenAsync_ParsesFileMetaInfo()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        Assert.That(file.FileMetaInfo.Contains(DicomTag.TransferSyntaxUID), Is.True);
    }

    [Test]
    public async Task OpenAsync_ParsesDataset()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        Assert.That(file.Dataset.Contains(new DicomTag(0x0010, 0x0010)), Is.True); // PatientName
        Assert.That(file.Dataset.Contains(new DicomTag(0x0010, 0x0020)), Is.True); // PatientID
    }

    [Test]
    public async Task OpenAsync_SetsTransferSyntax()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        Assert.That(file.TransferSyntax.IsExplicitVR, Is.True);
        Assert.That(file.TransferSyntax.IsLittleEndian, Is.True);
    }

    [Test]
    public async Task OpenAsync_PreservesPreamble()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        Assert.That(file.Preamble.Length, Is.EqualTo(128));
    }

    [Test]
    public void Open_Synchronous_Works()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        var file = DicomFile.Open(stream);

        Assert.That(file, Is.Not.Null);
        Assert.That(file.Dataset, Is.Not.Null);
    }

    [Test]
    public async Task GetString_ReturnsValue()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        var patientId = file.GetString(new DicomTag(0x0010, 0x0020));
        Assert.That(patientId, Is.EqualTo("PATIENT001"));
    }

    [Test]
    public async Task Contains_ReturnsCorrectValue()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        Assert.That(file.Contains(new DicomTag(0x0010, 0x0020)), Is.True);
        Assert.That(file.Contains(new DicomTag(0x9999, 0x9999)), Is.False);
    }

    [Test]
    public async Task Indexer_ReturnsElement()
    {
        var data = CreateTestDicomFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        var element = file[new DicomTag(0x0010, 0x0020)];
        Assert.That(element, Is.Not.Null);
    }

    [Test]
    public void Constructor_FromDataset_Works()
    {
        var dataset = new DicomDataset();
        dataset.Add(new DicomStringElement(new DicomTag(0x0010, 0x0020), DicomVR.LO, "TEST"u8.ToArray()));

        var file = new DicomFile(dataset);

        Assert.That(file.Dataset, Is.SameAs(dataset));
        Assert.That(file.TransferSyntax, Is.EqualTo(TransferSyntax.ExplicitVRLittleEndian));
    }

    private static byte[] CreateTestDicomFile()
    {
        using var ms = new MemoryStream();

        // 128 byte preamble
        ms.Write(new byte[128]);

        // DICM prefix
        ms.Write("DICM"u8);

        // File Meta Information (Explicit VR LE)
        WriteElement(ms, 0x0002, 0x0010, "UI", "1.2.840.10008.1.2.1\0"u8.ToArray());

        // Dataset elements
        WriteElement(ms, 0x0008, 0x0060, "CS", "CT "u8.ToArray());
        WriteElement(ms, 0x0010, 0x0010, "PN", "Doe^John"u8.ToArray());
        WriteElement(ms, 0x0010, 0x0020, "LO", "PATIENT001"u8.ToArray());

        return ms.ToArray();
    }

    private static void WriteElement(MemoryStream ms, ushort group, ushort element,
        string vr, byte[] value)
    {
        ms.Write(BitConverter.GetBytes(group));
        ms.Write(BitConverter.GetBytes(element));
        ms.Write(System.Text.Encoding.ASCII.GetBytes(vr));

        var vrCode = DicomVR.FromString(vr);
        if (vrCode.Is32BitLength)
        {
            ms.Write(new byte[2]);
            ms.Write(BitConverter.GetBytes((uint)value.Length));
        }
        else
        {
            ms.Write(BitConverter.GetBytes((ushort)value.Length));
        }

        ms.Write(value);
    }
}
```
  </action>
  <verify>
    dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomFileTests" --configuration Release
  </verify>
  <done>
    DicomFile tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Write integration tests</name>
  <files>
    tests/SharpDicom.Tests/Integration/ExplicitVRLETests.cs
  </files>
  <action>
Write integration tests for Explicit VR LE parsing:

```csharp
namespace SharpDicom.Tests.Integration;

[TestFixture]
public class ExplicitVRLETests
{
    [Test]
    public async Task Parse_CompleteFile_AllElementsPresent()
    {
        var data = CreateComprehensiveTestFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        // Verify all element types parsed correctly
        Assert.That(file.Dataset.Contains(new DicomTag(0x0008, 0x0005)), Is.True, "SpecificCharacterSet");
        Assert.That(file.Dataset.Contains(new DicomTag(0x0008, 0x0016)), Is.True, "SOPClassUID");
        Assert.That(file.Dataset.Contains(new DicomTag(0x0008, 0x0018)), Is.True, "SOPInstanceUID");
        Assert.That(file.Dataset.Contains(new DicomTag(0x0008, 0x0020)), Is.True, "StudyDate");
        Assert.That(file.Dataset.Contains(new DicomTag(0x0008, 0x0030)), Is.True, "StudyTime");
        Assert.That(file.Dataset.Contains(new DicomTag(0x0008, 0x0060)), Is.True, "Modality");
        Assert.That(file.Dataset.Contains(new DicomTag(0x0010, 0x0010)), Is.True, "PatientName");
        Assert.That(file.Dataset.Contains(new DicomTag(0x0010, 0x0020)), Is.True, "PatientID");
    }

    [Test]
    public async Task Parse_StringValues_DecodedCorrectly()
    {
        var data = CreateComprehensiveTestFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        Assert.That(file.GetString(new DicomTag(0x0010, 0x0010)), Is.EqualTo("Doe^John"));
        Assert.That(file.GetString(new DicomTag(0x0010, 0x0020)), Is.EqualTo("PATIENT001"));
        Assert.That(file.GetString(new DicomTag(0x0008, 0x0060)), Is.EqualTo("CT"));
    }

    [Test]
    public async Task Parse_DateValue_ParsedCorrectly()
    {
        var data = CreateComprehensiveTestFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        var studyDateElement = file.Dataset[new DicomTag(0x0008, 0x0020)] as DicomStringElement;
        Assert.That(studyDateElement, Is.Not.Null);

        var date = studyDateElement!.GetDate();
        Assert.That(date, Is.EqualTo(new DateOnly(2024, 1, 15)));
    }

    [Test]
    public async Task Parse_TimeValue_ParsedCorrectly()
    {
        var data = CreateComprehensiveTestFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        var studyTimeElement = file.Dataset[new DicomTag(0x0008, 0x0030)] as DicomStringElement;
        Assert.That(studyTimeElement, Is.Not.Null);

        var time = studyTimeElement!.GetTime();
        Assert.That(time, Is.EqualTo(new TimeOnly(14, 30, 00)));
    }

    [Test]
    public async Task Parse_NumericValue_ParsedCorrectly()
    {
        var data = CreateFileWithNumericElements();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        // Rows (US)
        var rowsElement = file.Dataset[new DicomTag(0x0028, 0x0010)] as DicomNumericElement;
        Assert.That(rowsElement, Is.Not.Null);
        Assert.That(rowsElement!.GetUInt16(), Is.EqualTo(512));

        // Columns (US)
        var colsElement = file.Dataset[new DicomTag(0x0028, 0x0011)] as DicomNumericElement;
        Assert.That(colsElement, Is.Not.Null);
        Assert.That(colsElement!.GetUInt16(), Is.EqualTo(512));
    }

    [Test]
    public async Task Parse_LongVRElement_ParsedCorrectly()
    {
        var data = CreateFileWithLongVRElement();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        // UT (Unlimited Text) is a long VR
        var element = file.Dataset[new DicomTag(0x0008, 0x0115)]; // CodingSchemeURL
        Assert.That(element, Is.Not.Null);
    }

    [Test]
    public async Task Parse_TransferSyntax_ExtractedCorrectly()
    {
        var data = CreateComprehensiveTestFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);

        Assert.That(file.TransferSyntax.IsExplicitVR, Is.True);
        Assert.That(file.TransferSyntax.IsLittleEndian, Is.True);
        Assert.That(file.TransferSyntax.IsEncapsulated, Is.False);
    }

    [Test]
    public async Task Parse_ElementEnumeration_SortedByTag()
    {
        var data = CreateComprehensiveTestFile();
        using var stream = new MemoryStream(data);

        var file = await DicomFile.OpenAsync(stream);
        var tags = file.Dataset.Select(e => e.Tag).ToList();

        // Should be sorted
        var sortedTags = tags.OrderBy(t => t).ToList();
        Assert.That(tags, Is.EqualTo(sortedTags));
    }

    private static byte[] CreateComprehensiveTestFile()
    {
        using var ms = new MemoryStream();

        // Preamble + DICM
        ms.Write(new byte[128]);
        ms.Write("DICM"u8);

        // FMI
        WriteElement(ms, 0x0002, 0x0010, "UI", "1.2.840.10008.1.2.1\0"u8.ToArray());

        // Dataset - various VRs
        WriteElement(ms, 0x0008, 0x0005, "CS", "ISO_IR 100 "u8.ToArray()); // SpecificCharacterSet
        WriteElement(ms, 0x0008, 0x0016, "UI", "1.2.840.10008.5.1.4.1.1.2\0"u8.ToArray()); // SOPClassUID
        WriteElement(ms, 0x0008, 0x0018, "UI", "1.2.3.4.5.6.7.8.9\0"u8.ToArray()); // SOPInstanceUID
        WriteElement(ms, 0x0008, 0x0020, "DA", "20240115"u8.ToArray()); // StudyDate
        WriteElement(ms, 0x0008, 0x0030, "TM", "143000"u8.ToArray()); // StudyTime
        WriteElement(ms, 0x0008, 0x0060, "CS", "CT "u8.ToArray()); // Modality
        WriteElement(ms, 0x0010, 0x0010, "PN", "Doe^John"u8.ToArray()); // PatientName
        WriteElement(ms, 0x0010, 0x0020, "LO", "PATIENT001"u8.ToArray()); // PatientID

        return ms.ToArray();
    }

    private static byte[] CreateFileWithNumericElements()
    {
        using var ms = new MemoryStream();

        ms.Write(new byte[128]);
        ms.Write("DICM"u8);

        WriteElement(ms, 0x0002, 0x0010, "UI", "1.2.840.10008.1.2.1\0"u8.ToArray());

        // Rows (US) = 512
        WriteElement(ms, 0x0028, 0x0010, "US", BitConverter.GetBytes((ushort)512));
        // Columns (US) = 512
        WriteElement(ms, 0x0028, 0x0011, "US", BitConverter.GetBytes((ushort)512));
        // BitsAllocated (US) = 16
        WriteElement(ms, 0x0028, 0x0100, "US", BitConverter.GetBytes((ushort)16));

        return ms.ToArray();
    }

    private static byte[] CreateFileWithLongVRElement()
    {
        using var ms = new MemoryStream();

        ms.Write(new byte[128]);
        ms.Write("DICM"u8);

        WriteElement(ms, 0x0002, 0x0010, "UI", "1.2.840.10008.1.2.1\0"u8.ToArray());

        // CodingSchemeURL (UT - long VR)
        WriteElementLong(ms, 0x0008, 0x0115, "UT", "http://example.com/codingscheme"u8.ToArray());

        return ms.ToArray();
    }

    private static void WriteElement(MemoryStream ms, ushort group, ushort element,
        string vr, byte[] value)
    {
        ms.Write(BitConverter.GetBytes(group));
        ms.Write(BitConverter.GetBytes(element));
        ms.Write(System.Text.Encoding.ASCII.GetBytes(vr));

        var vrCode = DicomVR.FromString(vr);
        if (vrCode.Is32BitLength)
        {
            ms.Write(new byte[2]);
            ms.Write(BitConverter.GetBytes((uint)value.Length));
        }
        else
        {
            ms.Write(BitConverter.GetBytes((ushort)value.Length));
        }

        ms.Write(value);
    }

    private static void WriteElementLong(MemoryStream ms, ushort group, ushort element,
        string vr, byte[] value)
    {
        ms.Write(BitConverter.GetBytes(group));
        ms.Write(BitConverter.GetBytes(element));
        ms.Write(System.Text.Encoding.ASCII.GetBytes(vr));
        ms.Write(new byte[2]); // Reserved
        ms.Write(BitConverter.GetBytes((uint)value.Length));
        ms.Write(value);
    }
}
```
  </action>
  <verify>
    dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~ExplicitVRLETests" --configuration Release
  </verify>
  <done>
    Integration tests pass
  </done>
</task>

<task type="auto">
  <name>Task 4: Run full Phase 2 test suite</name>
  <files>
    (none - verification only)
  </files>
  <action>
Run the complete test suite and verify Phase 2 success criteria:

```bash
# Build solution
dotnet build SharpDicom.sln --configuration Release

# Run all tests
dotnet test tests/SharpDicom.Tests --configuration Release --verbosity normal

# Verify test count increased
```

Expected results:
- All Phase 1 tests (226) still pass
- New Phase 2 tests pass
- No build warnings
  </action>
  <verify>
    dotnet test tests/SharpDicom.Tests --configuration Release --verbosity normal 2>&1 | tail -30
  </verify>
  <done>
    Full test suite passes, Phase 2 complete
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Full solution builds:
   ```bash
   dotnet build SharpDicom.sln --configuration Release
   ```

2. All tests pass:
   ```bash
   dotnet test tests/SharpDicom.Tests --configuration Release
   ```

3. Phase 2 success criteria from ROADMAP.md:
   - Parse standard test files
   - Stream elements via IAsyncEnumerable
   - File Meta Information extracted correctly
</verification>

<success_criteria>
- DicomFile provides convenient Open/OpenAsync methods
- DicomFile contains FileMetaInfo, Dataset, and TransferSyntax
- Integration tests verify Explicit VR LE parsing
- All Phase 2 tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-basic-file-reading/02-04-SUMMARY.md`
</output>
