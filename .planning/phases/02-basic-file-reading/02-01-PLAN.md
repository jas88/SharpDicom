---
phase: 02-basic-file-reading
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SharpDicom/IO/DicomStreamReader.cs
  - src/SharpDicom/IO/DicomReaderOptions.cs
  - src/SharpDicom/IO/DicomReaderState.cs
  - tests/SharpDicom.Tests/IO/DicomStreamReaderTests.cs
autonomous: true

must_haves:
  truths:
    - "DicomStreamReader parses element headers from Span<byte>"
    - "Both short VR (2-byte length) and long VR (4-byte length) formats handled"
    - "Reader tracks current position for error reporting"
    - "DicomReaderOptions configures parsing behavior"
  artifacts:
    - path: "src/SharpDicom/IO/DicomStreamReader.cs"
      provides: "Low-level Span-based element parsing"
      min_lines: 150
    - path: "src/SharpDicom/IO/DicomReaderOptions.cs"
      provides: "Reader configuration options"
      min_lines: 40
    - path: "tests/SharpDicom.Tests/IO/DicomStreamReaderTests.cs"
      provides: "Stream reader unit tests"
      min_lines: 80
  key_links:
    - from: "src/SharpDicom/IO/DicomStreamReader.cs"
      to: "src/SharpDicom/Data/DicomTag.cs"
      via: "element parsing"
      pattern: "new DicomTag"
---

<objective>
Implement the low-level DicomStreamReader for parsing DICOM elements from byte spans.

Purpose: Provide zero-allocation element parsing that can be used by higher-level readers.

Output:
- DicomStreamReader with Span<T>-based parsing
- DicomReaderOptions for configuration
- DicomReaderState enum for state machine
- Unit tests for element parsing
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-basic-file-reading/02-CONTEXT.md
@CLAUDE.md (DicomStreamReader section)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DicomReaderOptions and enums</name>
  <files>
    src/SharpDicom/IO/DicomReaderOptions.cs
    src/SharpDicom/IO/DicomReaderState.cs
  </files>
  <action>
Create reader configuration types in src/SharpDicom/IO/:

**DicomReaderState.cs**:
```csharp
namespace SharpDicom.IO;

/// <summary>
/// State machine states for DICOM file parsing.
/// </summary>
public enum DicomReaderState
{
    /// <summary>Initial state, not yet started.</summary>
    Initial,
    /// <summary>Reading 128-byte preamble.</summary>
    Preamble,
    /// <summary>Reading DICM prefix.</summary>
    Prefix,
    /// <summary>Reading File Meta Information (Group 0002).</summary>
    FileMetaInfo,
    /// <summary>Reading dataset elements.</summary>
    Dataset,
    /// <summary>Parsing complete.</summary>
    Complete,
    /// <summary>Error state.</summary>
    Error
}

/// <summary>
/// How to handle the 128-byte preamble and DICM prefix.
/// </summary>
public enum FilePreambleHandling
{
    /// <summary>Require valid preamble and DICM prefix.</summary>
    Require,
    /// <summary>Accept files with or without preamble (auto-detect).</summary>
    Optional,
    /// <summary>Skip preamble detection, assume raw dataset.</summary>
    Ignore
}

/// <summary>
/// How to handle File Meta Information (Group 0002).
/// </summary>
public enum FileMetaInfoHandling
{
    /// <summary>Require valid File Meta Information.</summary>
    Require,
    /// <summary>Use if present, infer if missing.</summary>
    Optional,
    /// <summary>Skip to dataset, assume Implicit VR Little Endian.</summary>
    Ignore
}

/// <summary>
/// How to handle invalid or unknown VRs.
/// </summary>
public enum InvalidVRHandling
{
    /// <summary>Throw DicomDataException.</summary>
    Throw,
    /// <summary>Map to UN and continue.</summary>
    MapToUN,
    /// <summary>Preserve original bytes.</summary>
    Preserve
}
```

**DicomReaderOptions.cs**:
```csharp
namespace SharpDicom.IO;

/// <summary>
/// Configuration options for DICOM file reading.
/// </summary>
public sealed class DicomReaderOptions
{
    /// <summary>How to handle the preamble and DICM prefix.</summary>
    public FilePreambleHandling Preamble { get; init; } = FilePreambleHandling.Optional;

    /// <summary>How to handle File Meta Information.</summary>
    public FileMetaInfoHandling FileMetaInfo { get; init; } = FileMetaInfoHandling.Optional;

    /// <summary>How to handle invalid VRs.</summary>
    public InvalidVRHandling InvalidVR { get; init; } = InvalidVRHandling.MapToUN;

    /// <summary>Maximum element length to accept (prevents OOM on malformed files).</summary>
    public uint MaxElementLength { get; init; } = 256 * 1024 * 1024; // 256 MB

    /// <summary>Strict preset: requires valid preamble and FMI.</summary>
    public static DicomReaderOptions Strict { get; } = new()
    {
        Preamble = FilePreambleHandling.Require,
        FileMetaInfo = FileMetaInfoHandling.Require,
        InvalidVR = InvalidVRHandling.Throw
    };

    /// <summary>Lenient preset: accepts variations.</summary>
    public static DicomReaderOptions Lenient { get; } = new()
    {
        Preamble = FilePreambleHandling.Optional,
        FileMetaInfo = FileMetaInfoHandling.Optional,
        InvalidVR = InvalidVRHandling.MapToUN
    };

    /// <summary>Permissive preset: maximum compatibility.</summary>
    public static DicomReaderOptions Permissive { get; } = new()
    {
        Preamble = FilePreambleHandling.Ignore,
        FileMetaInfo = FileMetaInfoHandling.Ignore,
        InvalidVR = InvalidVRHandling.Preserve
    };

    /// <summary>Default options (lenient).</summary>
    public static DicomReaderOptions Default { get; } = Lenient;
}
```
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    Reader options and state enums compile
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement DicomStreamReader</name>
  <files>
    src/SharpDicom/IO/DicomStreamReader.cs
  </files>
  <action>
Implement low-level Span-based element parsing:

```csharp
using System.Buffers.Binary;
using SharpDicom.Data;

namespace SharpDicom.IO;

/// <summary>
/// Low-level DICOM element parser using Span&lt;T&gt; for zero-copy parsing.
/// </summary>
public ref struct DicomStreamReader
{
    private ReadOnlySpan<byte> _buffer;
    private int _position;
    private readonly DicomReaderOptions _options;
    private readonly bool _explicitVR;
    private readonly bool _littleEndian;

    /// <summary>Current position in the buffer.</summary>
    public int Position => _position;

    /// <summary>Remaining bytes in buffer.</summary>
    public int Remaining => _buffer.Length - _position;

    /// <summary>Whether end of buffer is reached.</summary>
    public bool IsAtEnd => _position >= _buffer.Length;

    public DicomStreamReader(
        ReadOnlySpan<byte> buffer,
        bool explicitVR = true,
        bool littleEndian = true,
        DicomReaderOptions? options = null)
    {
        _buffer = buffer;
        _position = 0;
        _options = options ?? DicomReaderOptions.Default;
        _explicitVR = explicitVR;
        _littleEndian = littleEndian;
    }

    /// <summary>
    /// Try to read the next element header.
    /// </summary>
    public bool TryReadElementHeader(
        out DicomTag tag,
        out DicomVR vr,
        out uint length)
    {
        tag = default;
        vr = default;
        length = 0;

        // Need at least 8 bytes for tag + VR + length (short form)
        if (Remaining < 8)
            return false;

        var span = _buffer.Slice(_position);

        // Read tag
        ushort group = _littleEndian
            ? BinaryPrimitives.ReadUInt16LittleEndian(span)
            : BinaryPrimitives.ReadUInt16BigEndian(span);
        ushort element = _littleEndian
            ? BinaryPrimitives.ReadUInt16LittleEndian(span.Slice(2))
            : BinaryPrimitives.ReadUInt16BigEndian(span.Slice(2));

        tag = new DicomTag(group, element);

        if (_explicitVR)
        {
            // Explicit VR: read VR from stream
            vr = DicomVR.FromBytes(span.Slice(4, 2));

            if (vr.Is32BitLength)
            {
                // Long VRs: 2 reserved bytes + 4-byte length
                if (Remaining < 12)
                    return false;

                length = _littleEndian
                    ? BinaryPrimitives.ReadUInt32LittleEndian(span.Slice(8))
                    : BinaryPrimitives.ReadUInt32BigEndian(span.Slice(8));

                _position += 12;
            }
            else
            {
                // Short VRs: 2-byte length
                length = _littleEndian
                    ? BinaryPrimitives.ReadUInt16LittleEndian(span.Slice(6))
                    : BinaryPrimitives.ReadUInt16BigEndian(span.Slice(6));

                _position += 8;
            }
        }
        else
        {
            // Implicit VR: look up VR from dictionary, 4-byte length
            var entry = DicomDictionary.Default.GetEntry(tag);
            vr = entry?.DefaultVR ?? DicomVR.UN;

            length = _littleEndian
                ? BinaryPrimitives.ReadUInt32LittleEndian(span.Slice(4))
                : BinaryPrimitives.ReadUInt32BigEndian(span.Slice(4));

            _position += 8;
        }

        return true;
    }

    /// <summary>
    /// Read element value bytes after reading header.
    /// </summary>
    public bool TryReadValue(uint length, out ReadOnlySpan<byte> value)
    {
        value = default;

        // Undefined length - cannot read with this method
        if (length == 0xFFFFFFFF)
            return false;

        if (length > _options.MaxElementLength)
            throw new DicomDataException($"Element length {length} exceeds maximum {_options.MaxElementLength}");

        if ((int)length > Remaining)
            return false;

        value = _buffer.Slice(_position, (int)length);
        _position += (int)length;
        return true;
    }

    /// <summary>
    /// Skip bytes in the buffer.
    /// </summary>
    public void Skip(int count)
    {
        if (count > Remaining)
            throw new ArgumentOutOfRangeException(nameof(count));
        _position += count;
    }

    /// <summary>
    /// Check if buffer starts with DICM prefix at current position.
    /// </summary>
    public bool CheckDicmPrefix()
    {
        if (Remaining < 4)
            return false;

        var span = _buffer.Slice(_position, 4);
        return span[0] == (byte)'D' &&
               span[1] == (byte)'I' &&
               span[2] == (byte)'C' &&
               span[3] == (byte)'M';
    }

    /// <summary>
    /// Read a 16-bit unsigned integer.
    /// </summary>
    public ushort ReadUInt16()
    {
        if (Remaining < 2)
            throw new DicomDataException("Unexpected end of data");

        var value = _littleEndian
            ? BinaryPrimitives.ReadUInt16LittleEndian(_buffer.Slice(_position))
            : BinaryPrimitives.ReadUInt16BigEndian(_buffer.Slice(_position));

        _position += 2;
        return value;
    }

    /// <summary>
    /// Read a 32-bit unsigned integer.
    /// </summary>
    public uint ReadUInt32()
    {
        if (Remaining < 4)
            throw new DicomDataException("Unexpected end of data");

        var value = _littleEndian
            ? BinaryPrimitives.ReadUInt32LittleEndian(_buffer.Slice(_position))
            : BinaryPrimitives.ReadUInt32BigEndian(_buffer.Slice(_position));

        _position += 4;
        return value;
    }
}
```

Note: Need to add `Is32BitLength` property to DicomVR or DicomVRInfo.
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    DicomStreamReader compiles with element parsing methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Add VR length property</name>
  <files>
    src/SharpDicom/Data/DicomVR.cs
    src/SharpDicom/Data/DicomVRInfo.cs
  </files>
  <action>
Add Is32BitLength property to DicomVR for determining header format:

In DicomVR.cs, add a computed property:
```csharp
/// <summary>
/// Returns true if this VR uses 32-bit length encoding in Explicit VR.
/// Long VRs: OB, OD, OF, OL, OW, SQ, UC, UN, UR, UT
/// </summary>
public bool Is32BitLength => this == OB || this == OD || this == OF ||
                              this == OL || this == OW || this == SQ ||
                              this == UC || this == UN || this == UR || this == UT;
```

This determines whether element uses:
- Short form: Tag(4) + VR(2) + Length(2) = 8 bytes
- Long form: Tag(4) + VR(2) + Reserved(2) + Length(4) = 12 bytes
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    Is32BitLength property works for VR length determination
  </done>
</task>

<task type="auto">
  <name>Task 4: Write unit tests</name>
  <files>
    tests/SharpDicom.Tests/IO/DicomStreamReaderTests.cs
  </files>
  <action>
Write comprehensive tests for DicomStreamReader:

```csharp
namespace SharpDicom.Tests.IO;

[TestFixture]
public class DicomStreamReaderTests
{
    [Test]
    public void TryReadElementHeader_ShortVR_ReadsCorrectly()
    {
        // PatientID (0010,0020) LO "TEST"
        // Tag: 10 00 20 00, VR: 4C 4F (LO), Length: 04 00
        byte[] data = { 0x10, 0x00, 0x20, 0x00, 0x4C, 0x4F, 0x04, 0x00 };

        var reader = new DicomStreamReader(data);
        Assert.That(reader.TryReadElementHeader(out var tag, out var vr, out var length), Is.True);

        Assert.That(tag.Group, Is.EqualTo(0x0010));
        Assert.That(tag.Element, Is.EqualTo(0x0020));
        Assert.That(vr, Is.EqualTo(DicomVR.LO));
        Assert.That(length, Is.EqualTo(4));
        Assert.That(reader.Position, Is.EqualTo(8));
    }

    [Test]
    public void TryReadElementHeader_LongVR_ReadsCorrectly()
    {
        // PixelData (7FE0,0010) OW length=256
        // Tag: E0 7F 10 00, VR: 4F 57 (OW), Reserved: 00 00, Length: 00 01 00 00
        byte[] data = { 0xE0, 0x7F, 0x10, 0x00, 0x4F, 0x57, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 };

        var reader = new DicomStreamReader(data);
        Assert.That(reader.TryReadElementHeader(out var tag, out var vr, out var length), Is.True);

        Assert.That(tag.Group, Is.EqualTo(0x7FE0));
        Assert.That(tag.Element, Is.EqualTo(0x0010));
        Assert.That(vr, Is.EqualTo(DicomVR.OW));
        Assert.That(length, Is.EqualTo(256));
        Assert.That(reader.Position, Is.EqualTo(12));
    }

    [Test]
    public void TryReadElementHeader_InsufficientData_ReturnsFalse()
    {
        byte[] data = { 0x10, 0x00, 0x20, 0x00 }; // Only 4 bytes

        var reader = new DicomStreamReader(data);
        Assert.That(reader.TryReadElementHeader(out _, out _, out _), Is.False);
    }

    [Test]
    public void TryReadValue_ReadsCorrectly()
    {
        byte[] data = { 0x54, 0x45, 0x53, 0x54 }; // "TEST"

        var reader = new DicomStreamReader(data);
        Assert.That(reader.TryReadValue(4, out var value), Is.True);
        Assert.That(value.ToArray(), Is.EqualTo(data));
    }

    [Test]
    public void TryReadValue_UndefinedLength_ReturnsFalse()
    {
        byte[] data = new byte[100];
        var reader = new DicomStreamReader(data);
        Assert.That(reader.TryReadValue(0xFFFFFFFF, out _), Is.False);
    }

    [Test]
    public void CheckDicmPrefix_ValidPrefix_ReturnsTrue()
    {
        byte[] data = { (byte)'D', (byte)'I', (byte)'C', (byte)'M' };
        var reader = new DicomStreamReader(data);
        Assert.That(reader.CheckDicmPrefix(), Is.True);
    }

    [Test]
    public void CheckDicmPrefix_InvalidPrefix_ReturnsFalse()
    {
        byte[] data = { (byte)'D', (byte)'I', (byte)'C', (byte)'X' };
        var reader = new DicomStreamReader(data);
        Assert.That(reader.CheckDicmPrefix(), Is.False);
    }

    [Test]
    public void ReadUInt16_LittleEndian_ReadsCorrectly()
    {
        byte[] data = { 0x34, 0x12 }; // 0x1234 in LE
        var reader = new DicomStreamReader(data, littleEndian: true);
        Assert.That(reader.ReadUInt16(), Is.EqualTo(0x1234));
    }

    [Test]
    public void ReadUInt32_LittleEndian_ReadsCorrectly()
    {
        byte[] data = { 0x78, 0x56, 0x34, 0x12 }; // 0x12345678 in LE
        var reader = new DicomStreamReader(data, littleEndian: true);
        Assert.That(reader.ReadUInt32(), Is.EqualTo(0x12345678));
    }

    [Test]
    public void Skip_MovesPosition()
    {
        byte[] data = new byte[100];
        var reader = new DicomStreamReader(data);
        reader.Skip(50);
        Assert.That(reader.Position, Is.EqualTo(50));
        Assert.That(reader.Remaining, Is.EqualTo(50));
    }

    [Test]
    public void Is32BitLength_LongVRs_ReturnsTrue()
    {
        Assert.That(DicomVR.OB.Is32BitLength, Is.True);
        Assert.That(DicomVR.OW.Is32BitLength, Is.True);
        Assert.That(DicomVR.SQ.Is32BitLength, Is.True);
        Assert.That(DicomVR.UN.Is32BitLength, Is.True);
        Assert.That(DicomVR.UT.Is32BitLength, Is.True);
    }

    [Test]
    public void Is32BitLength_ShortVRs_ReturnsFalse()
    {
        Assert.That(DicomVR.AE.Is32BitLength, Is.False);
        Assert.That(DicomVR.CS.Is32BitLength, Is.False);
        Assert.That(DicomVR.DA.Is32BitLength, Is.False);
        Assert.That(DicomVR.LO.Is32BitLength, Is.False);
        Assert.That(DicomVR.US.Is32BitLength, Is.False);
    }
}
```
  </action>
  <verify>
    dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomStreamReaderTests" --configuration Release
  </verify>
  <done>
    All DicomStreamReader tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Solution builds:
   ```bash
   dotnet build SharpDicom.sln --configuration Release
   ```

2. Tests pass:
   ```bash
   dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomStreamReaderTests" --configuration Release
   ```

3. Verify files exist:
   - src/SharpDicom/IO/DicomStreamReader.cs
   - src/SharpDicom/IO/DicomReaderOptions.cs
   - src/SharpDicom/IO/DicomReaderState.cs
</verification>

<success_criteria>
- DicomStreamReader parses Explicit VR element headers
- Short and long VR formats correctly distinguished
- DicomReaderOptions provides Strict/Lenient/Permissive presets
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-basic-file-reading/02-01-SUMMARY.md`
</output>
