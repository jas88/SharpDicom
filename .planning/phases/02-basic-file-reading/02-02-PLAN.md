---
phase: 02-basic-file-reading
plan: 02
type: execute
wave: 1
depends_on: ["02-01"]
files_modified:
  - src/SharpDicom/IO/Part10Reader.cs
  - src/SharpDicom/IO/FileMetaInfo.cs
  - tests/SharpDicom.Tests/IO/Part10ReaderTests.cs
autonomous: true

must_haves:
  truths:
    - "Part10Reader parses preamble and DICM prefix"
    - "File Meta Information (Group 0002) extracted correctly"
    - "Transfer Syntax determined from (0002,0010)"
    - "Handles missing preamble per options"
  artifacts:
    - path: "src/SharpDicom/IO/Part10Reader.cs"
      provides: "DICOM Part 10 structure parsing"
      min_lines: 120
    - path: "tests/SharpDicom.Tests/IO/Part10ReaderTests.cs"
      provides: "Part 10 structure tests"
      min_lines: 80
  key_links:
    - from: "src/SharpDicom/IO/Part10Reader.cs"
      to: "src/SharpDicom/IO/DicomStreamReader.cs"
      via: "element parsing"
      pattern: "DicomStreamReader"
---

<objective>
Implement Part 10 file structure parsing including preamble, prefix, and File Meta Information.

Purpose: Parse the DICOM Part 10 file header to determine transfer syntax for the dataset.

Output:
- Part10Reader for file structure parsing
- File Meta Information extraction
- Transfer syntax determination
- Unit tests for Part 10 parsing
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-basic-file-reading/02-CONTEXT.md
@.planning/phases/02-basic-file-reading/02-01-SUMMARY.md
@CLAUDE.md (File Format section)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Part10Reader</name>
  <files>
    src/SharpDicom/IO/Part10Reader.cs
  </files>
  <action>
Implement Part 10 file structure parsing:

```csharp
using System.Buffers;
using SharpDicom.Data;

namespace SharpDicom.IO;

/// <summary>
/// Parses DICOM Part 10 file structure (preamble, prefix, File Meta Information).
/// </summary>
public sealed class Part10Reader
{
    private readonly DicomReaderOptions _options;

    /// <summary>Preamble bytes (128 bytes or empty if not present).</summary>
    public ReadOnlyMemory<byte> Preamble { get; private set; }

    /// <summary>Whether DICM prefix was found.</summary>
    public bool HasDicmPrefix { get; private set; }

    /// <summary>File Meta Information dataset (Group 0002).</summary>
    public DicomDataset? FileMetaInfo { get; private set; }

    /// <summary>Transfer Syntax from File Meta Information.</summary>
    public TransferSyntax TransferSyntax { get; private set; }

    /// <summary>Position where dataset starts (after FMI).</summary>
    public int DatasetStartPosition { get; private set; }

    public Part10Reader(DicomReaderOptions? options = null)
    {
        _options = options ?? DicomReaderOptions.Default;
        TransferSyntax = TransferSyntax.ImplicitVRLittleEndian; // Default
    }

    /// <summary>
    /// Parse Part 10 header from buffer.
    /// </summary>
    /// <param name="buffer">File data buffer</param>
    /// <returns>True if header parsed successfully</returns>
    public bool TryParseHeader(ReadOnlySpan<byte> buffer)
    {
        int position = 0;

        // Try to detect preamble + DICM
        if (buffer.Length >= 132)
        {
            // Check for DICM at position 128
            if (buffer[128] == 'D' && buffer[129] == 'I' &&
                buffer[130] == 'C' && buffer[131] == 'M')
            {
                Preamble = buffer.Slice(0, 128).ToArray();
                HasDicmPrefix = true;
                position = 132;
            }
            // Check for DICM at position 0 (no preamble)
            else if (buffer[0] == 'D' && buffer[1] == 'I' &&
                     buffer[2] == 'C' && buffer[3] == 'M')
            {
                Preamble = ReadOnlyMemory<byte>.Empty;
                HasDicmPrefix = true;
                position = 4;
            }
        }
        else if (buffer.Length >= 4)
        {
            // Short file, check for DICM at start
            if (buffer[0] == 'D' && buffer[1] == 'I' &&
                buffer[2] == 'C' && buffer[3] == 'M')
            {
                Preamble = ReadOnlyMemory<byte>.Empty;
                HasDicmPrefix = true;
                position = 4;
            }
        }

        // Handle based on options
        if (!HasDicmPrefix)
        {
            switch (_options.Preamble)
            {
                case FilePreambleHandling.Require:
                    throw new DicomFileException("Missing DICM prefix");

                case FilePreambleHandling.Optional:
                    // Try to detect if this looks like a DICOM dataset
                    if (!LooksLikeDicomDataset(buffer))
                        throw new DicomFileException("File does not appear to be DICOM");
                    position = 0;
                    break;

                case FilePreambleHandling.Ignore:
                    position = 0;
                    break;
            }
        }

        // Parse File Meta Information if present
        if (HasDicmPrefix || _options.FileMetaInfo != FileMetaInfoHandling.Ignore)
        {
            if (!TryParseFileMetaInfo(buffer.Slice(position), out var fmiLength))
            {
                if (_options.FileMetaInfo == FileMetaInfoHandling.Require)
                    throw new DicomFileException("Invalid or missing File Meta Information");

                // No FMI, use defaults
                TransferSyntax = TransferSyntax.ImplicitVRLittleEndian;
                DatasetStartPosition = position;
                return true;
            }

            DatasetStartPosition = position + fmiLength;
        }
        else
        {
            DatasetStartPosition = position;
        }

        return true;
    }

    private bool TryParseFileMetaInfo(ReadOnlySpan<byte> buffer, out int bytesConsumed)
    {
        bytesConsumed = 0;
        var fmi = new DicomDataset();

        // FMI is always Explicit VR Little Endian
        var reader = new DicomStreamReader(buffer, explicitVR: true, littleEndian: true, _options);

        // First element should be FileMetaInformationGroupLength (0002,0000)
        if (!reader.TryReadElementHeader(out var tag, out var vr, out var length))
            return false;

        // If not group 0002, no FMI present
        if (tag.Group != 0x0002)
            return false;

        // Read group length if present
        uint fmiEndPosition = 0;
        if (tag == DicomTag.FileMetaInformationGroupLength && length == 4)
        {
            if (!reader.TryReadValue(length, out var lengthValue))
                return false;

            fmiEndPosition = (uint)reader.Position + BitConverter.ToUInt32(lengthValue);
        }
        else
        {
            // No group length, read until group changes
            fmiEndPosition = uint.MaxValue;
        }

        // Re-read from start to build dataset
        reader = new DicomStreamReader(buffer, explicitVR: true, littleEndian: true, _options);

        while (!reader.IsAtEnd && (uint)reader.Position < fmiEndPosition)
        {
            if (!reader.TryReadElementHeader(out tag, out vr, out length))
                break;

            // Stop if we've left group 0002
            if (tag.Group != 0x0002)
            {
                // Back up - we read past FMI
                bytesConsumed = reader.Position - 8; // Header was 8 bytes for short VR
                break;
            }

            if (!reader.TryReadValue(length, out var value))
                break;

            // Create element and add to FMI
            var element = CreateElement(tag, vr, value.ToArray());
            fmi.Add(element);

            bytesConsumed = reader.Position;
        }

        if (fmi.Count == 0)
            return false;

        FileMetaInfo = fmi;

        // Extract Transfer Syntax
        var tsElement = fmi[DicomTag.TransferSyntaxUID];
        if (tsElement != null)
        {
            var tsUid = tsElement.GetString()?.TrimEnd();
            if (!string.IsNullOrEmpty(tsUid))
            {
                TransferSyntax = TransferSyntax.FromUID(new DicomUID(tsUid));
            }
        }

        return true;
    }

    private static bool LooksLikeDicomDataset(ReadOnlySpan<byte> buffer)
    {
        if (buffer.Length < 8)
            return false;

        // Check if first bytes look like a tag + VR
        // Common first tags: (0008,0005), (0008,0008), (0008,0016), etc.
        ushort group = (ushort)(buffer[0] | (buffer[1] << 8));
        ushort element = (ushort)(buffer[2] | (buffer[3] << 8));

        // Group 0008 is very common for datasets
        if (group == 0x0008)
            return true;

        // Group 0002 means FMI without DICM (unusual but possible)
        if (group == 0x0002)
            return true;

        // Check if bytes 4-5 look like a VR (two uppercase letters)
        if (buffer[4] >= 'A' && buffer[4] <= 'Z' &&
            buffer[5] >= 'A' && buffer[5] <= 'Z')
            return true;

        return false;
    }

    private static IDicomElement CreateElement(DicomTag tag, DicomVR vr, byte[] value)
    {
        // For now, create appropriate element type based on VR category
        if (vr.IsStringVR)
            return new DicomStringElement(tag, vr, value);
        else if (vr == DicomVR.SQ)
            return new DicomSequence(tag, Array.Empty<DicomDataset>());
        else if (vr.IsNumericVR)
            return new DicomNumericElement(tag, vr, value);
        else
            return new DicomBinaryElement(tag, vr, value);
    }
}
```
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    Part10Reader compiles with header parsing
  </done>
</task>

<task type="auto">
  <name>Task 2: Add DicomTag constants for FMI</name>
  <files>
    src/SharpDicom/Data/DicomTag.WellKnown.cs
  </files>
  <action>
Add well-known tag constants needed for Part 10 parsing:

```csharp
namespace SharpDicom.Data;

public readonly partial struct DicomTag
{
    // File Meta Information tags (Group 0002)
    // These should already be generated, but ensure they exist

    /// <summary>(0002,0000) File Meta Information Group Length</summary>
    public static readonly DicomTag FileMetaInformationGroupLength = new(0x0002, 0x0000);

    /// <summary>(0002,0001) File Meta Information Version</summary>
    public static readonly DicomTag FileMetaInformationVersion = new(0x0002, 0x0001);

    /// <summary>(0002,0002) Media Storage SOP Class UID</summary>
    public static readonly DicomTag MediaStorageSOPClassUID = new(0x0002, 0x0002);

    /// <summary>(0002,0003) Media Storage SOP Instance UID</summary>
    public static readonly DicomTag MediaStorageSOPInstanceUID = new(0x0002, 0x0003);

    /// <summary>(0002,0010) Transfer Syntax UID</summary>
    public static readonly DicomTag TransferSyntaxUID = new(0x0002, 0x0010);

    /// <summary>(0002,0012) Implementation Class UID</summary>
    public static readonly DicomTag ImplementationClassUID = new(0x0002, 0x0012);

    /// <summary>(0002,0013) Implementation Version Name</summary>
    public static readonly DicomTag ImplementationVersionName = new(0x0002, 0x0013);

    /// <summary>(0002,0016) Source Application Entity Title</summary>
    public static readonly DicomTag SourceApplicationEntityTitle = new(0x0002, 0x0016);
}
```

Note: These may already be generated. Check if they exist first, only add if missing.
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    FMI tag constants available for Part 10 parsing
  </done>
</task>

<task type="auto">
  <name>Task 3: Add VR helper properties</name>
  <files>
    src/SharpDicom/Data/DicomVR.cs
  </files>
  <action>
Add helper properties to DicomVR for element creation:

```csharp
/// <summary>
/// Returns true if this VR represents string data.
/// </summary>
public bool IsStringVR => this == AE || this == AS || this == CS || this == DA ||
                          this == DS || this == DT || this == IS || this == LO ||
                          this == LT || this == PN || this == SH || this == ST ||
                          this == TM || this == UC || this == UI || this == UR || this == UT;

/// <summary>
/// Returns true if this VR represents binary numeric data.
/// </summary>
public bool IsNumericVR => this == FL || this == FD || this == SL || this == SS ||
                           this == UL || this == US || this == AT;
```
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    VR helper properties available
  </done>
</task>

<task type="auto">
  <name>Task 4: Write Part 10 tests</name>
  <files>
    tests/SharpDicom.Tests/IO/Part10ReaderTests.cs
  </files>
  <action>
Write tests for Part 10 parsing:

```csharp
namespace SharpDicom.Tests.IO;

[TestFixture]
public class Part10ReaderTests
{
    [Test]
    public void TryParseHeader_ValidPreambleAndDicm_Succeeds()
    {
        // 128 bytes preamble + DICM + FMI
        var buffer = CreateValidPart10Header();

        var reader = new Part10Reader();
        Assert.That(reader.TryParseHeader(buffer), Is.True);
        Assert.That(reader.HasDicmPrefix, Is.True);
        Assert.That(reader.Preamble.Length, Is.EqualTo(128));
    }

    [Test]
    public void TryParseHeader_NoPreamble_DicmAtStart_Succeeds()
    {
        // DICM at position 0 + FMI
        var buffer = CreatePart10WithoutPreamble();

        var reader = new Part10Reader();
        Assert.That(reader.TryParseHeader(buffer), Is.True);
        Assert.That(reader.HasDicmPrefix, Is.True);
        Assert.That(reader.Preamble.Length, Is.EqualTo(0));
    }

    [Test]
    public void TryParseHeader_NoDicm_RequireMode_Throws()
    {
        // Raw dataset, no DICM
        var buffer = CreateRawDataset();

        var reader = new Part10Reader(DicomReaderOptions.Strict);
        Assert.Throws<DicomFileException>(() => reader.TryParseHeader(buffer));
    }

    [Test]
    public void TryParseHeader_NoDicm_OptionalMode_Succeeds()
    {
        // Raw dataset, no DICM
        var buffer = CreateRawDataset();

        var reader = new Part10Reader(DicomReaderOptions.Lenient);
        Assert.That(reader.TryParseHeader(buffer), Is.True);
        Assert.That(reader.HasDicmPrefix, Is.False);
    }

    [Test]
    public void TryParseHeader_ExtractsTransferSyntax()
    {
        var buffer = CreateValidPart10Header();

        var reader = new Part10Reader();
        reader.TryParseHeader(buffer);

        // Should have extracted transfer syntax from FMI
        Assert.That(reader.FileMetaInfo, Is.Not.Null);
        Assert.That(reader.TransferSyntax.IsKnown, Is.True);
    }

    [Test]
    public void TryParseHeader_ExtractsFileMetaInfo()
    {
        var buffer = CreateValidPart10Header();

        var reader = new Part10Reader();
        reader.TryParseHeader(buffer);

        Assert.That(reader.FileMetaInfo, Is.Not.Null);
        Assert.That(reader.FileMetaInfo!.Contains(DicomTag.TransferSyntaxUID), Is.True);
    }

    [Test]
    public void DatasetStartPosition_AfterFmi()
    {
        var buffer = CreateValidPart10Header();

        var reader = new Part10Reader();
        reader.TryParseHeader(buffer);

        // Dataset should start after preamble + DICM + FMI
        Assert.That(reader.DatasetStartPosition, Is.GreaterThan(132));
    }

    // Helper methods to create test data

    private static byte[] CreateValidPart10Header()
    {
        using var ms = new MemoryStream();

        // 128 byte preamble
        ms.Write(new byte[128]);

        // DICM prefix
        ms.Write("DICM"u8);

        // File Meta Information (Explicit VR LE)
        // (0002,0000) UL GroupLength
        WriteElement(ms, 0x0002, 0x0000, "UL", BitConverter.GetBytes((uint)90));

        // (0002,0001) OB FileMetaInformationVersion
        WriteElementLong(ms, 0x0002, 0x0001, "OB", new byte[] { 0x00, 0x01 });

        // (0002,0002) UI MediaStorageSOPClassUID
        WriteElement(ms, 0x0002, 0x0002, "UI", "1.2.840.10008.5.1.4.1.1.2\0"u8.ToArray());

        // (0002,0010) UI TransferSyntaxUID - Explicit VR LE
        WriteElement(ms, 0x0002, 0x0010, "UI", "1.2.840.10008.1.2.1\0"u8.ToArray());

        return ms.ToArray();
    }

    private static byte[] CreatePart10WithoutPreamble()
    {
        using var ms = new MemoryStream();

        // DICM prefix (no preamble)
        ms.Write("DICM"u8);

        // Minimal FMI
        WriteElement(ms, 0x0002, 0x0010, "UI", "1.2.840.10008.1.2.1\0"u8.ToArray());

        return ms.ToArray();
    }

    private static byte[] CreateRawDataset()
    {
        using var ms = new MemoryStream();

        // Start with typical dataset element (Specific Character Set)
        WriteElement(ms, 0x0008, 0x0005, "CS", "ISO_IR 100\0"u8.ToArray());

        return ms.ToArray();
    }

    private static void WriteElement(MemoryStream ms, ushort group, ushort element,
        string vr, byte[] value)
    {
        // Tag
        ms.Write(BitConverter.GetBytes(group));
        ms.Write(BitConverter.GetBytes(element));
        // VR
        ms.Write(System.Text.Encoding.ASCII.GetBytes(vr));
        // Length (16-bit)
        ms.Write(BitConverter.GetBytes((ushort)value.Length));
        // Value
        ms.Write(value);
    }

    private static void WriteElementLong(MemoryStream ms, ushort group, ushort element,
        string vr, byte[] value)
    {
        // Tag
        ms.Write(BitConverter.GetBytes(group));
        ms.Write(BitConverter.GetBytes(element));
        // VR
        ms.Write(System.Text.Encoding.ASCII.GetBytes(vr));
        // Reserved
        ms.Write(new byte[2]);
        // Length (32-bit)
        ms.Write(BitConverter.GetBytes((uint)value.Length));
        // Value
        ms.Write(value);
    }
}
```
  </action>
  <verify>
    dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~Part10ReaderTests" --configuration Release
  </verify>
  <done>
    Part 10 reader tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Solution builds without warnings
2. Part 10 tests pass
3. Transfer syntax correctly extracted from FMI
</verification>

<success_criteria>
- Part10Reader parses preamble and DICM prefix
- File Meta Information extracted correctly
- Transfer Syntax determined from (0002,0010)
- Handles missing preamble per options
</success_criteria>

<output>
After completion, create `.planning/phases/02-basic-file-reading/02-02-SUMMARY.md`
</output>
