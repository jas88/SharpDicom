---
phase: 10-network-foundation
plan: 06
type: execute
wave: 3
depends_on: ["10-03", "10-04"]
files_modified:
  - src/SharpDicom/Network/DicomServer.cs
  - src/SharpDicom/Network/DicomServerOptions.cs
  - src/SharpDicom/Network/IAssociationHandler.cs
  - tests/SharpDicom.Tests/Network/DicomServerTests.cs
autonomous: true

must_haves:
  truths:
    - "DicomServer listens on configurable TCP port"
    - "DicomServer accepts multiple concurrent associations"
    - "DicomServer uses Func delegates for event handlers"
    - "Graceful shutdown waits for active associations"
  artifacts:
    - path: "src/SharpDicom/Network/DicomServer.cs"
      provides: "SCP server implementation"
      contains: "public sealed class DicomServer"
    - path: "src/SharpDicom/Network/DicomServerOptions.cs"
      provides: "Server configuration"
      contains: "public sealed class DicomServerOptions"
    - path: "src/SharpDicom/Network/IAssociationHandler.cs"
      provides: "Handler interface for association events"
      contains: "interface"
  key_links:
    - from: "DicomServer"
      to: "TcpListener"
      via: "TCP listening"
      pattern: "new TcpListener|_listener"
    - from: "DicomServer"
      to: "DicomAssociation"
      via: "association per connection"
      pattern: "new DicomAssociation"
    - from: "DicomServerOptions"
      to: "Func delegates"
      via: "event handlers"
      pattern: "Func<.*ValueTask"
---

<objective>
Implement DicomServer for SCP (Service Class Provider) operations with event-based handling.

Purpose: DicomServer is the API for accepting incoming DICOM connections. It listens on a TCP port, accepts associations, and delegates DIMSE requests to user-provided handlers. This provides the foundation for C-ECHO SCP and future services like C-STORE SCP.

Output: Fully functional DicomServer with async start/stop, multiple concurrent associations, and graceful shutdown.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-foundation/10-RESEARCH.md
@.planning/phases/10-network-foundation/10-CONTEXT.md
@.planning/phases/10-network-foundation/10-03-SUMMARY.md
@.planning/phases/10-network-foundation/10-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Handler interfaces and options</name>
  <files>
    src/SharpDicom/Network/IAssociationHandler.cs
    src/SharpDicom/Network/DicomServerOptions.cs
  </files>
  <action>
1. **IAssociationHandler.cs** - Define handler delegate types and context:
```csharp
/// <summary>
/// Context for association request handling.
/// </summary>
public sealed class AssociationRequestContext
{
    public required string CallingAE { get; init; }
    public required string CalledAE { get; init; }
    public required IPEndPoint RemoteEndPoint { get; init; }
    public required IReadOnlyList<PresentationContext> RequestedContexts { get; init; }
}

/// <summary>
/// Result of association request handling.
/// </summary>
public sealed class AssociationRequestResult
{
    public bool Accept { get; init; }
    public RejectResult RejectResult { get; init; }
    public RejectSource RejectSource { get; init; }
    public RejectReason RejectReason { get; init; }
    public IReadOnlyList<PresentationContext>? AcceptedContexts { get; init; }

    public static AssociationRequestResult Accepted(IReadOnlyList<PresentationContext> contexts)
        => new() { Accept = true, AcceptedContexts = contexts };

    public static AssociationRequestResult Rejected(
        RejectResult result = RejectResult.PermanentRejection,
        RejectSource source = RejectSource.ServiceUser,
        RejectReason reason = RejectReason.NoReasonGiven)
        => new() { Accept = false, RejectResult = result, RejectSource = source, RejectReason = reason };
}

/// <summary>
/// Context for C-ECHO request handling.
/// </summary>
public sealed class CEchoRequestContext
{
    public required DicomAssociation Association { get; init; }
    public required ushort MessageId { get; init; }
}
```

2. **DicomServerOptions.cs:**
```csharp
public sealed class DicomServerOptions
{
    /// <summary>Port to listen on. Default: 104 (standard DICOM port).</summary>
    public int Port { get; init; } = 104;

    /// <summary>IP address to bind to. Default: IPAddress.Any (all interfaces).</summary>
    public IPAddress BindAddress { get; init; } = IPAddress.Any;

    /// <summary>AE title for this server.</summary>
    public required string AETitle { get; init; }

    /// <summary>Maximum concurrent associations. Default: 100.</summary>
    public int MaxAssociations { get; init; } = 100;

    /// <summary>ARTIM timeout for waiting for A-ASSOCIATE-RQ. Default: 30 seconds.</summary>
    public TimeSpan ArtimTimeout { get; init; } = TimeSpan.FromSeconds(30);

    /// <summary>Graceful shutdown timeout. Default: 30 seconds.</summary>
    public TimeSpan ShutdownTimeout { get; init; } = TimeSpan.FromSeconds(30);

    /// <summary>Maximum PDU length to advertise.</summary>
    public uint MaxPduLength { get; init; } = PduConstants.DefaultMaxPduLength;

    /// <summary>
    /// Called when A-ASSOCIATE-RQ received. Return accept/reject decision.
    /// If null, all associations are accepted with requested presentation contexts.
    /// </summary>
    public Func<AssociationRequestContext, ValueTask<AssociationRequestResult>>? OnAssociationRequest { get; init; }

    /// <summary>
    /// Called when C-ECHO-RQ received. Return status for response.
    /// If null, C-ECHO returns Success automatically.
    /// </summary>
    public Func<CEchoRequestContext, ValueTask<DicomStatus>>? OnCEcho { get; init; }

    // Future: OnCStore, OnCFind, etc. will be added in Phase 11

    public void Validate()
    {
        if (Port < 1 || Port > 65535)
            throw new ArgumentOutOfRangeException(nameof(Port));
        if (string.IsNullOrWhiteSpace(AETitle) || AETitle.Length > 16)
            throw new ArgumentException("AETitle must be 1-16 characters", nameof(AETitle));
        if (MaxAssociations < 1)
            throw new ArgumentOutOfRangeException(nameof(MaxAssociations));
    }
}
```
  </action>
  <verify>
dotnet build src/SharpDicom/SharpDicom.csproj
  </verify>
  <done>
Handler contexts and options defined. Func delegates for OnAssociationRequest and OnCEcho.
  </done>
</task>

<task type="auto">
  <name>Task 2: DicomServer implementation</name>
  <files>
    src/SharpDicom/Network/DicomServer.cs
  </files>
  <action>
Create DicomServer with Task-per-association model:

```csharp
public sealed class DicomServer : IAsyncDisposable
{
    private readonly DicomServerOptions _options;
    private readonly ILogger<DicomServer> _logger;
    private readonly TcpListener _listener;
    private readonly CancellationTokenSource _cts = new();
    private readonly List<Task> _activeTasks = new();
    private readonly SemaphoreSlim _semaphore;
    private Task? _acceptTask;
    private bool _disposed;

    public DicomServer(DicomServerOptions options, ILogger<DicomServer>? logger = null)
    {
        options.Validate();
        _options = options;
        _logger = logger ?? NullLogger<DicomServer>.Instance;
        _listener = new TcpListener(_options.BindAddress, _options.Port);
        _semaphore = new SemaphoreSlim(_options.MaxAssociations, _options.MaxAssociations);
    }

    public bool IsListening => _acceptTask != null && !_acceptTask.IsCompleted;
    public int ActiveAssociations
    {
        get
        {
            lock (_activeTasks)
                return _activeTasks.Count;
        }
    }

    /// <summary>
    /// Start listening for incoming associations.
    /// </summary>
    public void Start()
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        _listener.Start();
        _logger.LogInformation("DICOM server listening on {Address}:{Port} as {AE}",
            _options.BindAddress, _options.Port, _options.AETitle);

        _acceptTask = AcceptLoopAsync(_cts.Token);
    }

    private async Task AcceptLoopAsync(CancellationToken ct)
    {
        while (!ct.IsCancellationRequested)
        {
            try
            {
                // Wait for connection slot
                await _semaphore.WaitAsync(ct);

                TcpClient client;
                try
                {
                    client = await _listener.AcceptTcpClientAsync(ct);
                }
                catch
                {
                    _semaphore.Release();
                    throw;
                }

                var task = HandleAssociationAsync(client, ct);
                lock (_activeTasks)
                    _activeTasks.Add(task);

                // Fire-and-forget with cleanup
                _ = task.ContinueWith(t =>
                {
                    lock (_activeTasks)
                        _activeTasks.Remove(task);
                    _semaphore.Release();
                }, TaskScheduler.Default);
            }
            catch (OperationCanceledException) when (ct.IsCancellationRequested)
            {
                break;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error accepting connection");
            }
        }
    }

    private async Task HandleAssociationAsync(TcpClient client, CancellationToken ct)
    {
        var remoteEndPoint = (IPEndPoint)client.Client.RemoteEndPoint!;
        _logger.LogDebug("Accepted connection from {Remote}", remoteEndPoint);

        await using var _ = client.ConfigureAwait(false);
        var stream = client.GetStream();

        // Start ARTIM timer
        using var artimCts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        artimCts.CancelAfter(_options.ArtimTimeout);

        try
        {
            // Create association in TransportConnectionOpen state
            var assocOptions = new AssociationOptions
            {
                CalledAETitle = _options.AETitle,
                CallingAETitle = "", // Will be set from A-ASSOCIATE-RQ
                PresentationContexts = new List<PresentationContext>(),
                ArtimTimeout = _options.ArtimTimeout
            };
            var association = new DicomAssociation(assocOptions, _logger);
            association.ProcessEvent(AssociationEvent.TransportConnectionIndication);

            // Read A-ASSOCIATE-RQ
            var (rqType, callingAE, calledAE, requestedContexts) =
                await ReadAssociateRequestAsync(stream, artimCts.Token);

            // Stop ARTIM timer
            artimCts.CancelAfter(Timeout.InfiniteTimeSpan);

            association.ProcessEvent(AssociationEvent.AssociateRqPduReceived);

            // Validate and decide
            var requestContext = new AssociationRequestContext
            {
                CallingAE = callingAE,
                CalledAE = calledAE,
                RemoteEndPoint = remoteEndPoint,
                RequestedContexts = requestedContexts
            };

            var result = _options.OnAssociationRequest != null
                ? await _options.OnAssociationRequest(requestContext)
                : AssociationRequestResult.Accepted(requestedContexts);

            if (result.Accept)
            {
                await SendAssociateAcceptAsync(stream, result.AcceptedContexts!, ct);
                association.ProcessEvent(AssociationEvent.AAssociateResponse);

                // Run DIMSE loop
                await RunDimseLoopAsync(stream, association, ct);
            }
            else
            {
                await SendAssociateRejectAsync(stream, result, ct);
                // Association rejected - connection closes
            }
        }
        catch (OperationCanceledException) when (artimCts.IsCancellationRequested && !ct.IsCancellationRequested)
        {
            _logger.LogWarning("ARTIM timeout for connection from {Remote}", remoteEndPoint);
            // Connection will be closed
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error handling association from {Remote}", remoteEndPoint);
        }
    }

    private async Task RunDimseLoopAsync(
        NetworkStream stream,
        DicomAssociation association,
        CancellationToken ct)
    {
        // Process DIMSE requests until release or abort
        while (association.IsEstablished && !ct.IsCancellationRequested)
        {
            var pdu = await ReadPduAsync(stream, ct);

            switch (pdu.Type)
            {
                case PduType.PDataTransfer:
                    await HandlePDataAsync(stream, association, pdu, ct);
                    break;

                case PduType.ReleaseRequest:
                    association.ProcessEvent(AssociationEvent.ReleaseRqPduReceived);
                    await SendReleaseResponseAsync(stream, ct);
                    association.ProcessEvent(AssociationEvent.AReleaseResponse);
                    return;

                case PduType.Abort:
                    association.ProcessEvent(AssociationEvent.AbortPduReceived);
                    return;

                default:
                    _logger.LogWarning("Unexpected PDU type {Type} in established state", pdu.Type);
                    break;
            }
        }
    }

    private async Task HandlePDataAsync(
        NetworkStream stream,
        DicomAssociation association,
        Pdu pdu,
        CancellationToken ct)
    {
        // Parse command from P-DATA
        var command = ParseCommand(pdu);

        switch (command.CommandField)
        {
            case CommandField.CEchoRequest:
                await HandleCEchoAsync(stream, association, command, ct);
                break;

            // Future: C-STORE, C-FIND, etc.

            default:
                _logger.LogWarning("Unhandled command {Command}", command.CommandField);
                // Send failure status
                break;
        }
    }

    private async Task HandleCEchoAsync(
        NetworkStream stream,
        DicomAssociation association,
        DicomCommand request,
        CancellationToken ct)
    {
        var context = new CEchoRequestContext
        {
            Association = association,
            MessageId = request.MessageID
        };

        var status = _options.OnCEcho != null
            ? await _options.OnCEcho(context)
            : DicomStatus.Success;

        var response = DicomCommand.CreateCEchoResponse(request.MessageID, status);
        await SendCommandAsync(stream, association, response, ct);
    }

    /// <summary>
    /// Stop accepting new connections and wait for active associations.
    /// </summary>
    public async Task StopAsync()
    {
        if (_disposed) return;

        _logger.LogInformation("Stopping DICOM server");
        _cts.Cancel();
        _listener.Stop();

        // Wait for accept loop
        if (_acceptTask != null)
        {
            try { await _acceptTask; }
            catch (OperationCanceledException) { }
        }

        // Wait for active associations with timeout
        Task[] tasks;
        lock (_activeTasks)
            tasks = _activeTasks.ToArray();

        if (tasks.Length > 0)
        {
            _logger.LogDebug("Waiting for {Count} active associations", tasks.Length);
            var completed = await Task.WhenAny(
                Task.WhenAll(tasks),
                Task.Delay(_options.ShutdownTimeout));

            if (completed != Task.WhenAll(tasks))
            {
                _logger.LogWarning("Shutdown timeout, {Count} associations still active", tasks.Length);
            }
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_disposed) return;
        _disposed = true;

        await StopAsync();
        _cts.Dispose();
        _semaphore.Dispose();
    }

    // Helper methods (implementations similar to DicomClient)
    private async Task<(PduType, string, string, List<PresentationContext>)>
        ReadAssociateRequestAsync(NetworkStream stream, CancellationToken ct);
    private async Task SendAssociateAcceptAsync(
        NetworkStream stream, IReadOnlyList<PresentationContext> contexts, CancellationToken ct);
    private async Task SendAssociateRejectAsync(
        NetworkStream stream, AssociationRequestResult result, CancellationToken ct);
    private async Task SendReleaseResponseAsync(NetworkStream stream, CancellationToken ct);
    private async Task<Pdu> ReadPduAsync(NetworkStream stream, CancellationToken ct);
    private DicomCommand ParseCommand(Pdu pdu);
    private async Task SendCommandAsync(
        NetworkStream stream, DicomAssociation assoc, DicomCommand cmd, CancellationToken ct);
}
```
  </action>
  <verify>
dotnet build src/SharpDicom/SharpDicom.csproj
  </verify>
  <done>
DicomServer compiles. Task-per-association model with semaphore limiting. Graceful shutdown implemented.
  </done>
</task>

<task type="auto">
  <name>Task 3: DicomServer unit tests</name>
  <files>
    tests/SharpDicom.Tests/Network/DicomServerTests.cs
  </files>
  <action>
Create unit tests for DicomServer:

**DicomServerTests.cs:**

1. **Options validation tests:**
   - Invalid port throws ArgumentOutOfRangeException
   - Empty AETitle throws ArgumentException
   - AETitle > 16 chars throws ArgumentException
   - MaxAssociations < 1 throws ArgumentOutOfRangeException

2. **State tests:**
   - IsListening returns false before Start()
   - IsListening returns true after Start()
   - IsListening returns false after StopAsync()
   - ActiveAssociations returns 0 initially

3. **Dispose tests:**
   - DisposeAsync can be called multiple times
   - Start after dispose throws ObjectDisposedException

4. **Handler configuration tests:**
   - OnAssociationRequest with null accepts all
   - OnCEcho with null returns Success

5. **Basic start/stop test:**
   - Start and StopAsync without connections succeeds

Note: Full integration tests requiring TcpClient connections are in Plan 07 with DCMTK.
  </action>
  <verify>
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~DicomServerTests"
  </verify>
  <done>
DicomServer options validation tests pass. State tests pass. Handler configuration works.
  </done>
</task>

</tasks>

<verification>
All verification commands must pass:

```bash
# Build the library
dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release

# Run DicomServer tests
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~DicomServer"

# Run all tests
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj

# Verify DicomServer structure
grep -A 5 "public sealed class DicomServer" src/SharpDicom/Network/DicomServer.cs
grep "IAsyncDisposable" src/SharpDicom/Network/DicomServer.cs
```
</verification>

<success_criteria>
- DicomServer implements IAsyncDisposable
- Task-per-association model with configurable max connections
- Func delegates for OnAssociationRequest and OnCEcho handlers
- Graceful shutdown waits for active associations up to timeout
- ARTIM timer enforced for waiting for A-ASSOCIATE-RQ
- All tests pass
- No build warnings
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-foundation/10-06-SUMMARY.md`
</output>
