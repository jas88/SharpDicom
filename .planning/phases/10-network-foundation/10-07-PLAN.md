---
phase: 10-network-foundation
plan: 07
type: execute
wave: 4
depends_on: ["10-05", "10-06"]
files_modified:
  - src/SharpDicom/Network/DicomClient.cs
  - src/SharpDicom/Network/DicomServer.cs
  - tests/SharpDicom.Tests/Network/CEchoTests.cs
  - tests/SharpDicom.Tests/Network/CEchoIntegrationTests.cs
autonomous: true

must_haves:
  truths:
    - "DicomClient.CEchoAsync sends C-ECHO-RQ and receives C-ECHO-RSP"
    - "DicomServer handles C-ECHO-RQ and sends C-ECHO-RSP"
    - "C-ECHO roundtrip between client and server succeeds"
    - "C-ECHO returns DicomStatus.Success on success"
  artifacts:
    - path: "tests/SharpDicom.Tests/Network/CEchoTests.cs"
      provides: "C-ECHO roundtrip tests"
      contains: "CEchoTests"
  key_links:
    - from: "DicomClient.CEchoAsync"
      to: "DicomCommand.CreateCEchoRequest"
      via: "command creation"
      pattern: "CreateCEchoRequest"
    - from: "DicomServer"
      to: "DicomCommand.CreateCEchoResponse"
      via: "response creation"
      pattern: "CreateCEchoResponse"
---

<objective>
Implement C-ECHO SCU/SCP and create comprehensive integration tests for the networking foundation.

Purpose: C-ECHO is the simplest DIMSE service, used to verify connectivity (DICOM "ping"). Implementing it validates the entire networking stack: connection, association negotiation, PDU exchange, and DIMSE command handling. This completes the Phase 10 success criteria.

Output: Working C-ECHO SCU and SCP with integration tests proving the networking foundation works.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-foundation/10-RESEARCH.md
@.planning/phases/10-network-foundation/10-CONTEXT.md
@.planning/phases/10-network-foundation/10-05-SUMMARY.md
@.planning/phases/10-network-foundation/10-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: C-ECHO SCU implementation</name>
  <files>
    src/SharpDicom/Network/DicomClient.cs
  </files>
  <action>
Add C-ECHO SCU capability to DicomClient:

```csharp
// Add to DicomClient class:

/// <summary>
/// Send C-ECHO request and wait for response.
/// </summary>
/// <param name="ct">Cancellation token.</param>
/// <returns>Status from the C-ECHO response.</returns>
/// <exception cref="InvalidOperationException">Not connected or association not established.</exception>
/// <exception cref="TimeoutException">DIMSE timeout waiting for response.</exception>
public async ValueTask<DicomStatus> CEchoAsync(CancellationToken ct = default)
{
    if (_association == null || !_association.IsEstablished)
        throw new InvalidOperationException("Association not established. Call ConnectAsync first.");

    // Find Verification SOP Class presentation context
    var context = _association.AcceptedContexts?
        .FirstOrDefault(c => c.AbstractSyntax == DicomUID.Verification && c.Result == PresentationContextResult.Acceptance);

    if (context == null)
        throw new DicomAssociationException(
            "Verification SOP Class not accepted in association negotiation");

    // Create C-ECHO-RQ
    var messageId = NextMessageId();
    var request = DicomCommand.CreateCEchoRequest(messageId);

    _logger.LogDebug("Sending C-ECHO-RQ with MessageID {MessageId}", messageId);

    // Serialize command and send as P-DATA
    var commandBytes = SerializeCommand(request);
    var pdv = new PresentationDataValue
    {
        PresentationContextId = context.Id,
        IsCommand = true,
        IsLastFragment = true,
        Data = commandBytes
    };

    using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(ct);
    timeoutCts.CancelAfter(_options.DimseTimeout);

    await SendPDataAsync(new[] { pdv }, timeoutCts.Token);

    // Receive C-ECHO-RSP
    var responsePdv = await ReceivePDataAsync(timeoutCts.Token);

    if (!responsePdv.IsCommand)
        throw new DicomNetworkException("Expected command PDV, received data PDV");

    var response = ParseCommand(responsePdv.Data);

    if (response.CommandField != CommandField.CEchoResponse)
        throw new DicomNetworkException($"Expected C-ECHO-RSP, received {response.CommandField:X4}");

    if (response.MessageIDBeingRespondedTo != messageId)
        throw new DicomNetworkException(
            $"Message ID mismatch: sent {messageId}, response for {response.MessageIDBeingRespondedTo}");

    _logger.LogDebug("Received C-ECHO-RSP with Status {Status}", response.Status);

    return response.Status;
}

/// <summary>
/// Convenience method to connect with Verification SOP Class and verify connectivity.
/// </summary>
public async ValueTask<DicomStatus> VerifyAsync(CancellationToken ct = default)
{
    // Create presentation context for Verification SOP Class
    var contexts = new[]
    {
        new PresentationContext(
            id: 1,
            abstractSyntax: DicomUID.Verification,
            TransferSyntax.ExplicitVRLittleEndian)
    };

    await ConnectAsync(contexts, ct);
    try
    {
        return await CEchoAsync(ct);
    }
    finally
    {
        await ReleaseAsync(ct);
    }
}

// Internal helper to serialize command to bytes
private byte[] SerializeCommand(DicomCommand command)
{
    using var buffer = new ArrayBufferWriter<byte>();
    var writer = new DicomStreamWriter(buffer, true, true); // Explicit VR LE for command
    writer.WriteDataset(command.Dataset);
    return buffer.WrittenMemory.ToArray();
}

// Internal helper to parse command from bytes
private DicomCommand ParseCommand(ReadOnlyMemory<byte> data)
{
    var reader = new DicomStreamReader(data.Span, true, true);
    var dataset = new DicomDataset();

    while (reader.TryReadElementHeader(out var tag, out var vr, out var length))
    {
        var value = reader.ReadValue(length);
        dataset.Add(tag, vr, value);
    }

    return new DicomCommand(dataset);
}
```

Key points:
- Use Verification SOP Class UID (1.2.840.10008.1.1)
- Commands are always Implicit VR Little Endian (per PS3.7)
- Actually, correction: Command set uses Implicit VR LE per PS3.7 Section 6.3.1
- Wait for response with configurable timeout
- Validate MessageIDBeingRespondedTo matches our MessageID
  </action>
  <verify>
dotnet build src/SharpDicom/SharpDicom.csproj
  </verify>
  <done>
CEchoAsync and VerifyAsync methods compile. Command serialization and parsing implemented.
  </done>
</task>

<task type="auto">
  <name>Task 2: C-ECHO roundtrip tests</name>
  <files>
    tests/SharpDicom.Tests/Network/CEchoTests.cs
  </files>
  <action>
Create C-ECHO tests that run client and server in the same process:

```csharp
[TestFixture]
public class CEchoTests
{
    private const int TestPort = 11112;
    private const string ServerAE = "TESTSERVER";
    private const string ClientAE = "TESTCLIENT";

    [Test]
    public async Task CEcho_ClientToServer_ReturnsSuccess()
    {
        // Arrange
        var serverOptions = new DicomServerOptions
        {
            Port = TestPort,
            AETitle = ServerAE,
            OnCEcho = ctx => ValueTask.FromResult(DicomStatus.Success)
        };

        await using var server = new DicomServer(serverOptions);
        server.Start();

        var clientOptions = new DicomClientOptions
        {
            Host = "127.0.0.1",
            Port = TestPort,
            CalledAE = ServerAE,
            CallingAE = ClientAE
        };

        await using var client = new DicomClient(clientOptions);

        var contexts = new[]
        {
            new PresentationContext(1, DicomUID.Verification, TransferSyntax.ExplicitVRLittleEndian)
        };

        // Act
        await client.ConnectAsync(contexts);
        var status = await client.CEchoAsync();

        // Assert
        Assert.That(status.IsSuccess, Is.True);
        Assert.That(status.Code, Is.EqualTo(0x0000));
    }

    [Test]
    public async Task CEcho_ServerReturnsCustomStatus_ClientReceivesIt()
    {
        // Arrange - server returns warning status
        var customStatus = new DicomStatus(0xB000); // Warning

        var serverOptions = new DicomServerOptions
        {
            Port = TestPort + 1,
            AETitle = ServerAE,
            OnCEcho = ctx => ValueTask.FromResult(customStatus)
        };

        await using var server = new DicomServer(serverOptions);
        server.Start();

        var clientOptions = new DicomClientOptions
        {
            Host = "127.0.0.1",
            Port = TestPort + 1,
            CalledAE = ServerAE,
            CallingAE = ClientAE
        };

        await using var client = new DicomClient(clientOptions);

        var contexts = new[]
        {
            new PresentationContext(1, DicomUID.Verification, TransferSyntax.ExplicitVRLittleEndian)
        };

        // Act
        await client.ConnectAsync(contexts);
        var status = await client.CEchoAsync();

        // Assert
        Assert.That(status.Code, Is.EqualTo(0xB000));
        Assert.That(status.IsWarning, Is.True);
    }

    [Test]
    public async Task VerifyAsync_ConvenienceMethod_Works()
    {
        // Arrange
        var serverOptions = new DicomServerOptions
        {
            Port = TestPort + 2,
            AETitle = ServerAE
        };

        await using var server = new DicomServer(serverOptions);
        server.Start();

        var clientOptions = new DicomClientOptions
        {
            Host = "127.0.0.1",
            Port = TestPort + 2,
            CalledAE = ServerAE,
            CallingAE = ClientAE
        };

        await using var client = new DicomClient(clientOptions);

        // Act
        var status = await client.VerifyAsync();

        // Assert
        Assert.That(status.IsSuccess, Is.True);
    }

    [Test]
    public async Task CEcho_MultipleTimes_AllSucceed()
    {
        // Arrange
        var serverOptions = new DicomServerOptions
        {
            Port = TestPort + 3,
            AETitle = ServerAE
        };

        await using var server = new DicomServer(serverOptions);
        server.Start();

        var clientOptions = new DicomClientOptions
        {
            Host = "127.0.0.1",
            Port = TestPort + 3,
            CalledAE = ServerAE,
            CallingAE = ClientAE
        };

        await using var client = new DicomClient(clientOptions);

        var contexts = new[]
        {
            new PresentationContext(1, DicomUID.Verification, TransferSyntax.ExplicitVRLittleEndian)
        };

        await client.ConnectAsync(contexts);

        // Act - send multiple C-ECHOs
        for (int i = 0; i < 5; i++)
        {
            var status = await client.CEchoAsync();
            Assert.That(status.IsSuccess, Is.True);
        }
    }

    [Test]
    public async Task AssociationReject_ClientThrowsException()
    {
        // Arrange - server rejects all associations
        var serverOptions = new DicomServerOptions
        {
            Port = TestPort + 4,
            AETitle = ServerAE,
            OnAssociationRequest = ctx => ValueTask.FromResult(
                AssociationRequestResult.Rejected(
                    RejectResult.PermanentRejection,
                    RejectSource.ServiceUser,
                    RejectReason.CallingAETitleNotRecognized))
        };

        await using var server = new DicomServer(serverOptions);
        server.Start();

        var clientOptions = new DicomClientOptions
        {
            Host = "127.0.0.1",
            Port = TestPort + 4,
            CalledAE = ServerAE,
            CallingAE = "UNKNOWN"
        };

        await using var client = new DicomClient(clientOptions);

        var contexts = new[]
        {
            new PresentationContext(1, DicomUID.Verification, TransferSyntax.ExplicitVRLittleEndian)
        };

        // Act & Assert
        var ex = Assert.ThrowsAsync<DicomAssociationException>(
            async () => await client.ConnectAsync(contexts));

        Assert.That(ex!.RejectReason, Is.EqualTo(RejectReason.CallingAETitleNotRecognized));
    }

    [Test]
    public async Task Release_GracefulDisconnect_Works()
    {
        // Arrange
        var serverOptions = new DicomServerOptions
        {
            Port = TestPort + 5,
            AETitle = ServerAE
        };

        await using var server = new DicomServer(serverOptions);
        server.Start();

        var clientOptions = new DicomClientOptions
        {
            Host = "127.0.0.1",
            Port = TestPort + 5,
            CalledAE = ServerAE,
            CallingAE = ClientAE
        };

        await using var client = new DicomClient(clientOptions);

        var contexts = new[]
        {
            new PresentationContext(1, DicomUID.Verification, TransferSyntax.ExplicitVRLittleEndian)
        };

        // Act
        await client.ConnectAsync(contexts);
        Assert.That(client.IsConnected, Is.True);

        await client.ReleaseAsync();

        // Assert
        Assert.That(client.IsConnected, Is.False);
    }
}
```

These tests validate the entire networking stack works end-to-end.
  </action>
  <verify>
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~CEchoTests"
  </verify>
  <done>
All C-ECHO roundtrip tests pass. Client-server communication validated. Association rejection handled correctly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration tests for DCMTK compatibility</name>
  <files>
    tests/SharpDicom.Tests/Network/CEchoIntegrationTests.cs
  </files>
  <action>
Create integration test class for DCMTK interoperability:

```csharp
[TestFixture]
[Category("Integration")]
[Category("DCMTK")]
public class CEchoIntegrationTests
{
    // These tests require DCMTK tools installed and are marked explicit
    // Run manually with: dotnet test --filter "Category=DCMTK"

    [Test]
    [Explicit("Requires DCMTK storescp running: storescp -v 11113")]
    public async Task CEcho_ToDCMTKStoreScp_Succeeds()
    {
        // Arrange
        // Prerequisites: Run in terminal: storescp -v 11113
        var clientOptions = new DicomClientOptions
        {
            Host = "127.0.0.1",
            Port = 11113,
            CalledAE = "STORESCP",
            CallingAE = "SHARPDICOM"
        };

        await using var client = new DicomClient(clientOptions);

        // Act
        var status = await client.VerifyAsync();

        // Assert
        Assert.That(status.IsSuccess, Is.True, "C-ECHO to DCMTK storescp should succeed");
    }

    [Test]
    [Explicit("Requires DCMTK echoscu to connect: echoscu -v 127.0.0.1 11114")]
    public async Task DicomServer_AcceptsDCMTKEchoScu()
    {
        // Arrange
        var echoReceived = new TaskCompletionSource<bool>();

        var serverOptions = new DicomServerOptions
        {
            Port = 11114,
            AETitle = "SHARPDICOM",
            OnCEcho = ctx =>
            {
                echoReceived.TrySetResult(true);
                return ValueTask.FromResult(DicomStatus.Success);
            }
        };

        await using var server = new DicomServer(serverOptions);
        server.Start();

        Console.WriteLine("Server started. Run: echoscu -v 127.0.0.1 11114");

        // Act - wait for DCMTK echoscu to connect
        // In real test, you'd spawn echoscu process, but here we wait for manual run
        var timeout = Task.Delay(TimeSpan.FromSeconds(30));
        var completedTask = await Task.WhenAny(echoReceived.Task, timeout);

        // Assert
        Assert.That(completedTask, Is.EqualTo(echoReceived.Task), "Expected C-ECHO from echoscu");
        Assert.That(echoReceived.Task.Result, Is.True);
    }

    [Test]
    [Explicit("Requires both directions of DCMTK interop")]
    public async Task BidirectionalCEcho_WithDCMTK()
    {
        // This test validates both SCU and SCP against DCMTK
        // 1. Start our server
        // 2. Send C-ECHO from DCMTK echoscu to our server
        // 3. Send C-ECHO from our client to DCMTK storescp

        // Prerequisites:
        // Terminal 1: storescp -v 11115
        // Terminal 2: (wait for test output)

        var serverOptions = new DicomServerOptions
        {
            Port = 11116,
            AETitle = "SHARPDICOM_SCP"
        };

        await using var server = new DicomServer(serverOptions);
        server.Start();

        // Our client to DCMTK
        var clientOptions = new DicomClientOptions
        {
            Host = "127.0.0.1",
            Port = 11115,
            CalledAE = "STORESCP",
            CallingAE = "SHARPDICOM_SCU"
        };

        await using var client = new DicomClient(clientOptions);

        var status = await client.VerifyAsync();
        Assert.That(status.IsSuccess, Is.True, "Our SCU -> DCMTK SCP");

        Console.WriteLine("Now run: echoscu -v 127.0.0.1 11116");
        // Manual verification that echoscu succeeds
    }
}
```

Additionally, add a simple test helper script (not committed, just for documentation):

```bash
# Test commands for DCMTK interoperability:

# Start DCMTK server:
storescp -v 11113

# Test our client against DCMTK:
# (run integration test)

# Start our server on 11114, then:
echoscu -v 127.0.0.1 11114
```

Document these in the test class comments so developers know how to run DCMTK tests.
  </action>
  <verify>
# Unit tests (not integration) should pass without DCMTK
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "Category!=Integration"
  </verify>
  <done>
Integration test class created with DCMTK instructions. Unit tests still pass without DCMTK installed.
  </done>
</task>

</tasks>

<verification>
All verification commands must pass:

```bash
# Build the library
dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release

# Run non-integration tests
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "Category!=Integration"

# Run C-ECHO tests specifically
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~CEcho" --filter "Category!=Integration"

# Run all tests
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "Category!=Integration"

# Verify C-ECHO API
grep "CEchoAsync" src/SharpDicom/Network/DicomClient.cs
```
</verification>

<success_criteria>
- DicomClient.CEchoAsync sends C-ECHO-RQ and receives C-ECHO-RSP
- DicomServer handles C-ECHO-RQ via OnCEcho handler
- C-ECHO roundtrip tests pass (client to server in same process)
- Multiple C-ECHOs on same association work
- Association rejection properly reported to client
- Integration test class documents DCMTK interop testing
- All non-integration tests pass
- No build warnings
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-foundation/10-07-SUMMARY.md`
</output>
