---
phase: 10-network-foundation
plan: 04
type: execute
wave: 2
depends_on: ["10-01", "10-02"]
files_modified:
  - src/SharpDicom/Network/Association/AssociationState.cs
  - src/SharpDicom/Network/Association/AssociationEvent.cs
  - src/SharpDicom/Network/Association/DicomAssociation.cs
  - tests/SharpDicom.Tests/Network/Association/AssociationStateTests.cs
autonomous: true

must_haves:
  truths:
    - "Association state machine has 13 states per DICOM PS3.8 Section 9.2"
    - "State transitions follow DICOM state table"
    - "Invalid state transitions throw DicomAssociationException"
    - "ARTIM timer fires appropriate state changes"
  artifacts:
    - path: "src/SharpDicom/Network/Association/AssociationState.cs"
      provides: "13 association states enum"
      contains: "public enum AssociationState"
    - path: "src/SharpDicom/Network/Association/DicomAssociation.cs"
      provides: "Association state machine"
      contains: "public sealed class DicomAssociation"
  key_links:
    - from: "DicomAssociation"
      to: "AssociationState"
      via: "state machine transitions"
      pattern: "_state = nextState"
    - from: "DicomAssociation"
      to: "AssociationEvent"
      via: "event processing"
      pattern: "ProcessEvent"
---

<objective>
Implement the DICOM association state machine per PS3.8 Section 9.2.

Purpose: The association state machine manages the lifecycle of DICOM associations, handling connection establishment, negotiation, data exchange, and release/abort. This is the core protocol logic that both DicomClient and DicomServer depend on.

Output: AssociationState enum, AssociationEvent enum, and DicomAssociation class implementing the state machine.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-foundation/10-RESEARCH.md
@.planning/phases/10-network-foundation/10-CONTEXT.md
@.planning/phases/10-network-foundation/10-01-SUMMARY.md
@.planning/phases/10-network-foundation/10-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Association states and events</name>
  <files>
    src/SharpDicom/Network/Association/AssociationState.cs
    src/SharpDicom/Network/Association/AssociationEvent.cs
  </files>
  <action>
Create Network/Association directory with:

1. **AssociationState.cs** - Enum for the 13 DICOM association states per PS3.8 Section 9.2:
```csharp
public enum AssociationState
{
    /// <summary>Sta1: Idle - no connection</summary>
    Idle = 1,

    /// <summary>Sta2: Transport connection open (awaiting A-ASSOCIATE)</summary>
    TransportConnectionOpen = 2,

    /// <summary>Sta3: Awaiting local A-ASSOCIATE response primitive</summary>
    AwaitingLocalAssociateResponse = 3,

    /// <summary>Sta4: Awaiting transport connection opening to complete</summary>
    AwaitingTransportConnectionOpen = 4,

    /// <summary>Sta5: Awaiting A-ASSOCIATE-AC or A-ASSOCIATE-RJ PDU</summary>
    AwaitingAssociateResponse = 5,

    /// <summary>Sta6: Association established and ready for data transfer</summary>
    AssociationEstablished = 6,

    /// <summary>Sta7: Awaiting A-RELEASE-RP PDU</summary>
    AwaitingReleaseResponse = 7,

    /// <summary>Sta8: Awaiting local A-RELEASE response primitive</summary>
    AwaitingLocalReleaseResponse = 8,

    /// <summary>Sta9: Release collision - requestor side</summary>
    ReleaseCollisionRequestor = 9,

    /// <summary>Sta10: Release collision - acceptor side</summary>
    ReleaseCollisionAcceptor = 10,

    /// <summary>Sta11: Release collision - requestor side, awaiting response</summary>
    ReleaseCollisionRequestorAwaiting = 11,

    /// <summary>Sta12: Release collision - acceptor side, awaiting response</summary>
    ReleaseCollisionAcceptorAwaiting = 12,

    /// <summary>Sta13: Awaiting transport connection close indication</summary>
    AwaitingTransportClose = 13
}
```

2. **AssociationEvent.cs** - Enum for events that trigger state transitions:
```csharp
public enum AssociationEvent
{
    // Service user events
    AAssociateRequest,      // A-ASSOCIATE request from local user
    AAssociateResponse,     // A-ASSOCIATE response from local user
    AReleaseRequest,        // A-RELEASE request from local user
    AReleaseResponse,       // A-RELEASE response from local user
    AAbortRequest,          // A-ABORT request from local user
    PDataRequest,           // P-DATA request from local user

    // Transport events
    TransportConnectionConfirm,   // TCP connection established
    TransportConnectionIndication,// Incoming TCP connection accepted
    TransportConnectionClose,     // TCP connection closed

    // PDU received events
    AssociateAcPduReceived,       // A-ASSOCIATE-AC PDU received
    AssociateRjPduReceived,       // A-ASSOCIATE-RJ PDU received
    AssociateRqPduReceived,       // A-ASSOCIATE-RQ PDU received
    PDataPduReceived,             // P-DATA-TF PDU received
    ReleaseRqPduReceived,         // A-RELEASE-RQ PDU received
    ReleaseRpPduReceived,         // A-RELEASE-RP PDU received
    AbortPduReceived,             // A-ABORT PDU received
    InvalidPduReceived,           // Unrecognized or malformed PDU

    // Timer events
    ArtimTimerExpired             // ARTIM timer expired
}
```

Include XML documentation with references to PS3.8 Section 9.2.
  </action>
  <verify>
dotnet build src/SharpDicom/SharpDicom.csproj
  </verify>
  <done>
All 13 states defined. All events that trigger state transitions defined. XML docs reference PS3.8.
  </done>
</task>

<task type="auto">
  <name>Task 2: DicomAssociation state machine</name>
  <files>
    src/SharpDicom/Network/Association/DicomAssociation.cs
  </files>
  <action>
Create DicomAssociation class implementing the state machine:

```csharp
public sealed class DicomAssociation
{
    private AssociationState _state = AssociationState.Idle;
    private readonly AssociationOptions _options;
    private readonly ILogger<DicomAssociation> _logger;
    private CancellationTokenSource? _artimCts;

    // Negotiated parameters (set after A-ASSOCIATE-AC received/sent)
    public AssociationState State => _state;
    public string? CalledAE { get; private set; }
    public string? CallingAE { get; private set; }
    public IReadOnlyList<PresentationContext>? AcceptedContexts { get; private set; }
    public uint MaxPduLength { get; private set; }
    public bool IsEstablished => _state == AssociationState.AssociationEstablished;

    public DicomAssociation(AssociationOptions options, ILogger<DicomAssociation>? logger = null)
    {
        _options = options;
        _logger = logger ?? NullLogger<DicomAssociation>.Instance;
    }

    /// <summary>
    /// Process a state machine event, transitioning to new state and executing actions.
    /// </summary>
    public void ProcessEvent(AssociationEvent evt, object? context = null)
    {
        var (nextState, action) = GetTransition(_state, evt);

        _logger.LogDebug("Association state transition: {Current} + {Event} -> {Next}",
            _state, evt, nextState);

        action?.Invoke(context);
        _state = nextState;
    }

    private (AssociationState, Action<object?>?) GetTransition(
        AssociationState current, AssociationEvent evt)
    {
        // State table from PS3.8 Section 9.2.3
        return (current, evt) switch
        {
            // Sta1: Idle
            (AssociationState.Idle, AssociationEvent.AAssociateRequest) =>
                (AssociationState.AwaitingTransportConnectionOpen, null),
            (AssociationState.Idle, AssociationEvent.TransportConnectionIndication) =>
                (AssociationState.TransportConnectionOpen, StartArtimTimer),

            // Sta2: Transport connection open (SCP side)
            (AssociationState.TransportConnectionOpen, AssociationEvent.AssociateRqPduReceived) =>
                (AssociationState.AwaitingLocalAssociateResponse, StopArtimTimer),
            (AssociationState.TransportConnectionOpen, AssociationEvent.ArtimTimerExpired) =>
                (AssociationState.Idle, CloseTransport),

            // Sta3: Awaiting local associate response (SCP side)
            (AssociationState.AwaitingLocalAssociateResponse, AssociationEvent.AAssociateResponse) =>
                (AssociationState.AssociationEstablished, null), // Or Idle if rejection

            // Sta4: Awaiting transport connection (SCU side)
            (AssociationState.AwaitingTransportConnectionOpen, AssociationEvent.TransportConnectionConfirm) =>
                (AssociationState.AwaitingAssociateResponse, null),

            // Sta5: Awaiting A-ASSOCIATE-AC/RJ (SCU side)
            (AssociationState.AwaitingAssociateResponse, AssociationEvent.AssociateAcPduReceived) =>
                (AssociationState.AssociationEstablished, HandleAssociateAccept),
            (AssociationState.AwaitingAssociateResponse, AssociationEvent.AssociateRjPduReceived) =>
                (AssociationState.Idle, HandleAssociateReject),

            // Sta6: Association established
            (AssociationState.AssociationEstablished, AssociationEvent.PDataRequest) =>
                (AssociationState.AssociationEstablished, null),
            (AssociationState.AssociationEstablished, AssociationEvent.PDataPduReceived) =>
                (AssociationState.AssociationEstablished, null),
            (AssociationState.AssociationEstablished, AssociationEvent.AReleaseRequest) =>
                (AssociationState.AwaitingReleaseResponse, null),
            (AssociationState.AssociationEstablished, AssociationEvent.ReleaseRqPduReceived) =>
                (AssociationState.AwaitingLocalReleaseResponse, null),
            (AssociationState.AssociationEstablished, AssociationEvent.AbortPduReceived) =>
                (AssociationState.Idle, HandleAbort),
            (AssociationState.AssociationEstablished, AssociationEvent.AAbortRequest) =>
                (AssociationState.Idle, null),

            // Sta7: Awaiting release response
            (AssociationState.AwaitingReleaseResponse, AssociationEvent.ReleaseRpPduReceived) =>
                (AssociationState.AwaitingTransportClose, StartArtimTimer),
            (AssociationState.AwaitingReleaseResponse, AssociationEvent.ReleaseRqPduReceived) =>
                (AssociationState.ReleaseCollisionRequestor, null),

            // Sta8: Awaiting local release response
            (AssociationState.AwaitingLocalReleaseResponse, AssociationEvent.AReleaseResponse) =>
                (AssociationState.AwaitingTransportClose, StartArtimTimer),
            (AssociationState.AwaitingLocalReleaseResponse, AssociationEvent.AReleaseRequest) =>
                (AssociationState.ReleaseCollisionAcceptor, null),

            // Sta13: Awaiting transport close
            (AssociationState.AwaitingTransportClose, AssociationEvent.TransportConnectionClose) =>
                (AssociationState.Idle, StopArtimTimer),
            (AssociationState.AwaitingTransportClose, AssociationEvent.ArtimTimerExpired) =>
                (AssociationState.Idle, CloseTransport),

            // Any state: abort handling
            (_, AssociationEvent.AbortPduReceived) =>
                (AssociationState.Idle, HandleAbort),
            (_, AssociationEvent.AAbortRequest) =>
                (AssociationState.Idle, null),
            (_, AssociationEvent.TransportConnectionClose) when current != AssociationState.Idle =>
                (AssociationState.Idle, null),

            // Invalid transition
            _ => throw new DicomAssociationException(
                $"Invalid state transition: {current} + {evt}")
        };
    }

    // Action methods
    private void StartArtimTimer(object? _) { ... }
    private void StopArtimTimer(object? _) { ... }
    private void CloseTransport(object? _) { ... }
    private void HandleAssociateAccept(object? context) { ... }
    private void HandleAssociateReject(object? context) { ... }
    private void HandleAbort(object? context) { ... }

    // Helper to get accepted presentation context by ID
    public PresentationContext? GetPresentationContext(byte contextId)
    {
        return AcceptedContexts?.FirstOrDefault(c => c.Id == contextId);
    }
}
```

Note: This is a simplified version. The full state table has more transitions for release collision handling (Sta9-Sta12). Implement the core paths first; collision handling can be expanded if needed.
  </action>
  <verify>
dotnet build src/SharpDicom/SharpDicom.csproj
  </verify>
  <done>
DicomAssociation compiles with state machine logic. Core transitions implemented for SCU and SCP paths.
  </done>
</task>

<task type="auto">
  <name>Task 3: State machine tests</name>
  <files>
    tests/SharpDicom.Tests/Network/Association/AssociationStateTests.cs
  </files>
  <action>
Create unit tests for the state machine:

**AssociationStateTests.cs:**

1. **SCU path tests:**
   - Idle -> AwaitingTransportConnectionOpen (AAssociateRequest)
   - AwaitingTransportConnectionOpen -> AwaitingAssociateResponse (TransportConnectionConfirm)
   - AwaitingAssociateResponse -> AssociationEstablished (AssociateAcPduReceived)
   - AwaitingAssociateResponse -> Idle (AssociateRjPduReceived)
   - AssociationEstablished -> AwaitingReleaseResponse (AReleaseRequest)
   - AwaitingReleaseResponse -> AwaitingTransportClose (ReleaseRpPduReceived)

2. **SCP path tests:**
   - Idle -> TransportConnectionOpen (TransportConnectionIndication)
   - TransportConnectionOpen -> AwaitingLocalAssociateResponse (AssociateRqPduReceived)
   - AwaitingLocalAssociateResponse -> AssociationEstablished (AAssociateResponse - accept)
   - AssociationEstablished -> AwaitingLocalReleaseResponse (ReleaseRqPduReceived)
   - AwaitingLocalReleaseResponse -> AwaitingTransportClose (AReleaseResponse)

3. **Invalid transition tests:**
   - Idle + PDataRequest throws DicomAssociationException
   - TransportConnectionOpen + AssociateAcPduReceived throws
   - AssociationEstablished + AssociateRqPduReceived throws

4. **Abort handling tests:**
   - Any state + AbortPduReceived -> Idle
   - Any state + AAbortRequest -> Idle

5. **Property tests:**
   - IsEstablished returns true only in AssociationEstablished state
   - GetPresentationContext returns null before negotiation
  </action>
  <verify>
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~AssociationStateTests"
  </verify>
  <done>
All state machine transitions validated. Invalid transitions throw DicomAssociationException. All tests pass.
  </done>
</task>

</tasks>

<verification>
All verification commands must pass:

```bash
# Build the library
dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release

# Run association tests
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~Association"

# Run all tests
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj

# Verify state machine structure
grep -A 3 "public enum AssociationState" src/SharpDicom/Network/Association/AssociationState.cs
grep -A 3 "public sealed class DicomAssociation" src/SharpDicom/Network/Association/DicomAssociation.cs
```
</verification>

<success_criteria>
- 13 association states defined per PS3.8 Section 9.2
- State machine transitions follow DICOM state table
- Invalid transitions throw DicomAssociationException
- SCU and SCP paths tested end-to-end
- ARTIM timer hookpoints in place (actual timer integration in client/server)
- All tests pass
- No build warnings
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-foundation/10-04-SUMMARY.md`
</output>
