---
phase: 10-network-foundation
plan: 03
type: execute
wave: 2
depends_on: ["10-01", "10-02"]
files_modified:
  - src/SharpDicom/Network/Pdu/PduReader.cs
  - src/SharpDicom/Network/Pdu/PduWriter.cs
  - tests/SharpDicom.Tests/Network/Pdu/PduReaderTests.cs
  - tests/SharpDicom.Tests/Network/Pdu/PduWriterTests.cs
autonomous: true

must_haves:
  truths:
    - "PDU headers are parsed using Big-Endian byte order"
    - "PduReader can parse all 7 PDU types from byte buffers"
    - "PduWriter can build all 7 PDU types to IBufferWriter<byte>"
    - "PDU fragmentation is handled (partial reads return false)"
  artifacts:
    - path: "src/SharpDicom/Network/Pdu/PduReader.cs"
      provides: "Zero-copy PDU parsing"
      contains: "public ref struct PduReader"
    - path: "src/SharpDicom/Network/Pdu/PduWriter.cs"
      provides: "PDU building to IBufferWriter"
      contains: "public ref struct PduWriter"
  key_links:
    - from: "PduReader"
      to: "BinaryPrimitives.ReadUInt32BigEndian"
      via: "PDU header parsing"
      pattern: "ReadUInt32BigEndian"
    - from: "PduWriter"
      to: "BinaryPrimitives.WriteUInt32BigEndian"
      via: "PDU header building"
      pattern: "WriteUInt32BigEndian"
---

<objective>
Implement PDU parsing and building using ref structs following the DicomStreamReader pattern.

Purpose: Provide zero-allocation PDU parsing from network buffers and efficient PDU building for transmission. These are the fundamental I/O primitives for all DICOM network communication.

Output: PduReader for parsing incoming PDUs and PduWriter for building outgoing PDUs.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-foundation/10-RESEARCH.md
@.planning/phases/10-network-foundation/10-01-SUMMARY.md
@.planning/phases/10-network-foundation/10-02-SUMMARY.md

Reference existing patterns:
@src/SharpDicom/IO/DicomStreamReader.cs (for ref struct pattern)
@src/SharpDicom/IO/DicomStreamWriter.cs (for IBufferWriter pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: PduReader ref struct</name>
  <files>
    src/SharpDicom/Network/Pdu/PduReader.cs
  </files>
  <action>
Create PduReader as a ref struct following DicomStreamReader pattern:

```csharp
public ref struct PduReader
{
    private readonly ReadOnlySpan<byte> _buffer;
    private int _position;

    public PduReader(ReadOnlySpan<byte> buffer) { ... }

    public int Position => _position;
    public int Remaining => _buffer.Length - _position;

    // Core header parsing - returns false if insufficient data
    public bool TryReadPduHeader(out PduType type, out uint length);

    // Specific PDU parsers - call after TryReadPduHeader confirms type
    public bool TryReadAssociateRequest(
        out ushort protocolVersion,
        out string calledAE,
        out string callingAE,
        out ReadOnlySpan<byte> variableItems);

    public bool TryReadAssociateAccept(
        out ushort protocolVersion,
        out string calledAE,
        out string callingAE,
        out ReadOnlySpan<byte> variableItems);

    public bool TryReadAssociateReject(
        out RejectResult result,
        out RejectSource source,
        out RejectReason reason);

    public bool TryReadPData(out ReadOnlySpan<byte> pdvData);

    public bool TryReadReleaseRequest();  // No variable fields
    public bool TryReadReleaseResponse(); // No variable fields

    public bool TryReadAbort(out AbortSource source, out AbortReason reason);

    // Variable item parsing helpers
    public bool TryReadVariableItem(out ItemType type, out ushort length);
    public bool TryReadApplicationContext(out string uid);
    public bool TryReadPresentationContextRequest(
        out byte contextId,
        out ReadOnlySpan<byte> itemData);
    public bool TryReadPresentationContextAccept(
        out byte contextId,
        out PresentationContextResult result,
        out ReadOnlySpan<byte> itemData);
    public bool TryReadAbstractSyntax(out string uid);
    public bool TryReadTransferSyntax(out string uid);
    public bool TryReadUserInformation(out ReadOnlySpan<byte> itemData);
    public bool TryReadMaxPduLength(out uint maxLength);
    public bool TryReadImplementationClassUid(out string uid);
    public bool TryReadImplementationVersionName(out string name);

    // PDV parsing within P-DATA
    public bool TryReadPresentationDataValue(
        out byte contextId,
        out bool isCommand,
        out bool isLastFragment,
        out ReadOnlySpan<byte> data);
}
```

Key implementation details:
- All lengths in PDU headers are Big-Endian (BinaryPrimitives.ReadUInt32BigEndian)
- Variable item lengths are also Big-Endian (ReadUInt16BigEndian)
- AE titles are 16 bytes, space-padded, trim trailing spaces when returning
- Return false (not throw) when insufficient data for TCP fragmentation handling
- Advance _position only after successful read
  </action>
  <verify>
dotnet build src/SharpDicom/SharpDicom.csproj
  </verify>
  <done>
PduReader compiles. All TryRead methods use Big-Endian parsing. Returns false on insufficient data.
  </done>
</task>

<task type="auto">
  <name>Task 2: PduWriter ref struct</name>
  <files>
    src/SharpDicom/Network/Pdu/PduWriter.cs
  </files>
  <action>
Create PduWriter as a ref struct for building PDUs to IBufferWriter<byte>:

```csharp
public ref struct PduWriter
{
    private readonly IBufferWriter<byte> _writer;

    public PduWriter(IBufferWriter<byte> writer) { ... }

    // A-ASSOCIATE-RQ building
    public void WriteAssociateRequest(
        string calledAE,
        string callingAE,
        IReadOnlyList<PresentationContext> contexts,
        UserInformation userInfo);

    // A-ASSOCIATE-AC building
    public void WriteAssociateAccept(
        string calledAE,
        string callingAE,
        IReadOnlyList<PresentationContext> contexts,
        UserInformation userInfo);

    // A-ASSOCIATE-RJ building (fixed 10 bytes)
    public void WriteAssociateReject(
        RejectResult result,
        RejectSource source,
        RejectReason reason);

    // P-DATA-TF building
    public void WritePData(IReadOnlyList<PresentationDataValue> pdvs);

    // A-RELEASE-RQ building (fixed 10 bytes)
    public void WriteReleaseRequest();

    // A-RELEASE-RP building (fixed 10 bytes)
    public void WriteReleaseResponse();

    // A-ABORT building (fixed 10 bytes)
    public void WriteAbort(AbortSource source, AbortReason reason);

    // Helper methods
    private void WritePduHeader(PduType type, uint length);
    private void WriteAeTitle(ReadOnlySpan<char> aeTitle);
    private void WriteVariableItem(ItemType type, ReadOnlySpan<byte> data);
    private void WriteApplicationContext();
    private void WritePresentationContextRequest(PresentationContext ctx);
    private void WritePresentationContextAccept(PresentationContext ctx);
    private void WriteUserInformation(UserInformation info);
}
```

Key implementation details:
- All lengths in PDU headers are Big-Endian (BinaryPrimitives.WriteUInt32BigEndian)
- Variable item lengths are also Big-Endian (WriteUInt16BigEndian)
- AE titles padded to 16 bytes with spaces using ASCII encoding
- Application Context UID is always "1.2.840.10008.3.1.1.1" (DICOM standard)
- Calculate total length before writing header (header length is PDU length - 6)
- Use _writer.GetSpan() / _writer.Advance() pattern from DicomStreamWriter
  </action>
  <verify>
dotnet build src/SharpDicom/SharpDicom.csproj
  </verify>
  <done>
PduWriter compiles. All Write methods use Big-Endian encoding. AE titles properly padded.
  </done>
</task>

<task type="auto">
  <name>Task 3: PDU reader/writer tests</name>
  <files>
    tests/SharpDicom.Tests/Network/Pdu/PduReaderTests.cs
    tests/SharpDicom.Tests/Network/Pdu/PduWriterTests.cs
  </files>
  <action>
Create comprehensive tests for PDU parsing and building:

**PduReaderTests.cs:**
- Test parsing A-ASSOCIATE-RJ (fixed format, known bytes)
- Test parsing A-RELEASE-RQ (fixed format)
- Test parsing A-RELEASE-RP (fixed format)
- Test parsing A-ABORT (fixed format)
- Test parsing PDU header with insufficient data returns false
- Test Big-Endian length parsing (construct buffer with known length, verify parsed)
- Test AE title trimming (space-padded input, verify trimmed output)
- Test parsing A-ASSOCIATE-RQ variable items (application context, presentation context)

**PduWriterTests.cs:**
- Test writing A-ASSOCIATE-RJ produces correct bytes
- Test writing A-RELEASE-RQ produces correct 10-byte format
- Test writing A-RELEASE-RP produces correct 10-byte format
- Test writing A-ABORT produces correct bytes
- Test AE title padding (short AE padded to 16 bytes with spaces)
- Test Big-Endian length encoding (write PDU, verify length bytes)
- Roundtrip test: Write A-ASSOCIATE-RQ, read with PduReader, verify fields match

Use ArrayBufferWriter<byte> for writer tests (from System.Buffers).
  </action>
  <verify>
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~Pdu"
  </verify>
  <done>
PDU reader/writer roundtrip tests pass. All fixed-format PDUs produce correct byte sequences.
  </done>
</task>

</tasks>

<verification>
All verification commands must pass:

```bash
# Build the library
dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release

# Run PDU tests
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~Pdu"

# Run all tests
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj

# Verify ref struct pattern
grep -A 5 "public ref struct PduReader" src/SharpDicom/Network/Pdu/PduReader.cs
grep -A 5 "public ref struct PduWriter" src/SharpDicom/Network/Pdu/PduWriter.cs
```
</verification>

<success_criteria>
- PduReader parses all 7 PDU types from byte buffers
- PduWriter builds all 7 PDU types to IBufferWriter<byte>
- Big-Endian byte order used for all PDU headers and item lengths
- Roundtrip tests pass (write -> read -> verify)
- Insufficient data returns false (not throw) for fragmentation handling
- All tests pass
- No build warnings
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-foundation/10-03-SUMMARY.md`
</output>
