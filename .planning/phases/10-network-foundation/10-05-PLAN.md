---
phase: 10-network-foundation
plan: 05
type: execute
wave: 3
depends_on: ["10-03", "10-04"]
files_modified:
  - src/SharpDicom/Network/Dimse/DicomCommand.cs
  - src/SharpDicom/Network/Dimse/CommandField.cs
  - src/SharpDicom/Network/DicomClient.cs
  - src/SharpDicom/Network/DicomClientOptions.cs
  - tests/SharpDicom.Tests/Network/DicomClientTests.cs
autonomous: true

must_haves:
  truths:
    - "DicomClient connects to remote DICOM AE using TCP"
    - "DicomClient sends A-ASSOCIATE-RQ and receives A-ASSOCIATE-AC/RJ"
    - "DicomClient uses async/await with CancellationToken"
    - "Connection timeout is configurable"
  artifacts:
    - path: "src/SharpDicom/Network/DicomClient.cs"
      provides: "SCU client implementation"
      contains: "public sealed class DicomClient"
    - path: "src/SharpDicom/Network/DicomClientOptions.cs"
      provides: "Client configuration"
      contains: "public sealed class DicomClientOptions"
    - path: "src/SharpDicom/Network/Dimse/DicomCommand.cs"
      provides: "DIMSE command wrapper"
      contains: "public sealed class DicomCommand"
  key_links:
    - from: "DicomClient"
      to: "TcpClient"
      via: "TCP connection"
      pattern: "new TcpClient"
    - from: "DicomClient"
      to: "DicomAssociation"
      via: "association state machine"
      pattern: "_association"
    - from: "DicomClient"
      to: "PduReader/PduWriter"
      via: "PDU I/O"
      pattern: "new PduReader|new PduWriter"
---

<objective>
Implement DicomClient for SCU (Service Class User) operations with async TCP connectivity.

Purpose: DicomClient is the primary API for connecting to remote DICOM AEs (e.g., PACS servers). It manages TCP connection, association negotiation, and provides the foundation for C-ECHO and other DIMSE services.

Output: Fully functional DicomClient with async connect, association negotiation, and resource cleanup.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-network-foundation/10-RESEARCH.md
@.planning/phases/10-network-foundation/10-CONTEXT.md
@.planning/phases/10-network-foundation/10-03-SUMMARY.md
@.planning/phases/10-network-foundation/10-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: DIMSE command infrastructure</name>
  <files>
    src/SharpDicom/Network/Dimse/DicomCommand.cs
    src/SharpDicom/Network/Dimse/CommandField.cs
  </files>
  <action>
Create Network/Dimse directory with:

1. **CommandField.cs** - Constants for DIMSE Command Field values per PS3.7:
```csharp
public static class CommandField
{
    // C-STORE
    public const ushort CStoreRequest = 0x0001;
    public const ushort CStoreResponse = 0x8001;

    // C-GET
    public const ushort CGetRequest = 0x0010;
    public const ushort CGetResponse = 0x8010;

    // C-FIND
    public const ushort CFindRequest = 0x0020;
    public const ushort CFindResponse = 0x8020;

    // C-MOVE
    public const ushort CMoveRequest = 0x0021;
    public const ushort CMoveResponse = 0x8021;

    // C-ECHO
    public const ushort CEchoRequest = 0x0030;
    public const ushort CEchoResponse = 0x8030;

    // N-EVENT-REPORT (for future)
    public const ushort NEventReportRequest = 0x0100;
    public const ushort NEventReportResponse = 0x8100;

    // ... other N-* commands can be added later

    public static bool IsResponse(ushort commandField) => (commandField & 0x8000) != 0;
    public static bool IsRequest(ushort commandField) => (commandField & 0x8000) == 0;
}
```

2. **DicomCommand.cs** - Wrapper for DIMSE command datasets:
```csharp
public sealed class DicomCommand
{
    private readonly DicomDataset _dataset;

    public DicomCommand(DicomDataset dataset)
    {
        _dataset = dataset ?? throw new ArgumentNullException(nameof(dataset));
    }

    public DicomDataset Dataset => _dataset;

    // Command fields (Group 0000)
    public DicomUID AffectedSOPClassUID =>
        _dataset.GetValue<DicomUID>(DicomTag.AffectedSOPClassUID);

    public ushort CommandField =>
        _dataset.GetValue<ushort>(DicomTag.CommandField);

    public ushort MessageID =>
        _dataset.GetValue<ushort>(DicomTag.MessageID);

    public ushort MessageIDBeingRespondedTo =>
        _dataset.GetValueOrDefault<ushort>(DicomTag.MessageIDBeingRespondedTo);

    public ushort CommandDataSetType =>
        _dataset.GetValue<ushort>(DicomTag.CommandDataSetType);

    public DicomStatus Status =>
        new DicomStatus(_dataset.GetValueOrDefault<ushort>(DicomTag.Status));

    public bool HasDataset => CommandDataSetType != 0x0101;
    // Note: First "CommandField" is the static helper class (Dimse.CommandField),
    // second "CommandField" is this property returning the ushort value
    public bool IsRequest => Dimse.CommandField.IsRequest(CommandField);
    public bool IsResponse => Dimse.CommandField.IsResponse(CommandField);

    // Factory methods for C-ECHO
    public static DicomCommand CreateCEchoRequest(ushort messageId)
    {
        var ds = new DicomDataset();
        ds.Add(DicomTag.AffectedSOPClassUID, DicomUID.Verification);
        ds.Add(DicomTag.CommandField, CommandField.CEchoRequest);
        ds.Add(DicomTag.MessageID, messageId);
        ds.Add(DicomTag.CommandDataSetType, (ushort)0x0101); // No dataset
        return new DicomCommand(ds);
    }

    public static DicomCommand CreateCEchoResponse(ushort messageIdBeingRespondedTo, DicomStatus status)
    {
        var ds = new DicomDataset();
        ds.Add(DicomTag.AffectedSOPClassUID, DicomUID.Verification);
        ds.Add(DicomTag.CommandField, CommandField.CEchoResponse);
        ds.Add(DicomTag.MessageIDBeingRespondedTo, messageIdBeingRespondedTo);
        ds.Add(DicomTag.CommandDataSetType, (ushort)0x0101);
        ds.Add(DicomTag.Status, status.Code);
        return new DicomCommand(ds);
    }
}
```

Note: DicomTag.CommandField etc. need to be added to the dictionary if not present. They are Group 0000 tags from Part 7.
  </action>
  <verify>
dotnet build src/SharpDicom/SharpDicom.csproj
  </verify>
  <done>
DicomCommand wraps DIMSE command datasets. C-ECHO request/response factory methods work.
  </done>
</task>

<task type="auto">
  <name>Task 2: DicomClientOptions and DicomClient</name>
  <files>
    src/SharpDicom/Network/DicomClientOptions.cs
    src/SharpDicom/Network/DicomClient.cs
  </files>
  <action>
1. **DicomClientOptions.cs:**
```csharp
public sealed class DicomClientOptions
{
    public required string Host { get; init; }
    public required int Port { get; init; }
    public required string CalledAE { get; init; }
    public required string CallingAE { get; init; }
    public TimeSpan ConnectionTimeout { get; init; } = TimeSpan.FromSeconds(30);
    public TimeSpan AssociationTimeout { get; init; } = TimeSpan.FromSeconds(30);
    public TimeSpan DimseTimeout { get; init; } = TimeSpan.FromSeconds(60);
    public uint MaxPduLength { get; init; } = PduConstants.DefaultMaxPduLength;

    // Validate in constructor or Build method
    public void Validate()
    {
        if (string.IsNullOrWhiteSpace(Host))
            throw new ArgumentException("Host is required", nameof(Host));
        if (Port < 1 || Port > 65535)
            throw new ArgumentOutOfRangeException(nameof(Port));
        // AE title validation via AssociationOptions
    }
}
```

2. **DicomClient.cs:**
```csharp
public sealed class DicomClient : IAsyncDisposable
{
    private readonly DicomClientOptions _options;
    private readonly ILogger<DicomClient> _logger;
    private TcpClient? _tcp;
    private NetworkStream? _stream;
    private DicomAssociation? _association;
    private ushort _messageId;
    private bool _disposed;

    public DicomClient(DicomClientOptions options, ILogger<DicomClient>? logger = null)
    {
        options.Validate();
        _options = options;
        _logger = logger ?? NullLogger<DicomClient>.Instance;
    }

    public bool IsConnected => _association?.IsEstablished ?? false;

    /// <summary>
    /// Connect to the remote AE and establish association.
    /// </summary>
    public async ValueTask<DicomAssociation> ConnectAsync(
        IReadOnlyList<PresentationContext> presentationContexts,
        CancellationToken ct = default)
    {
        ObjectDisposedException.ThrowIf(_disposed, this);

        _tcp = new TcpClient();

        // Connect with timeout
        using var connectCts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        connectCts.CancelAfter(_options.ConnectionTimeout);

        _logger.LogDebug("Connecting to {Host}:{Port}", _options.Host, _options.Port);

        try
        {
            await _tcp.ConnectAsync(_options.Host, _options.Port, connectCts.Token);
        }
        catch (OperationCanceledException) when (!ct.IsCancellationRequested)
        {
            throw new TimeoutException(
                $"Connection to {_options.Host}:{_options.Port} timed out after {_options.ConnectionTimeout}");
        }

        _stream = _tcp.GetStream();

        // Create association options
        var assocOptions = new AssociationOptions
        {
            CalledAETitle = _options.CalledAE,
            CallingAETitle = _options.CallingAE,
            PresentationContexts = presentationContexts.ToList(),
            UserInformation = new UserInformation
            {
                MaxPduLength = _options.MaxPduLength
            },
            ArtimTimeout = _options.AssociationTimeout,
            DimseTimeout = _options.DimseTimeout
        };

        _association = new DicomAssociation(assocOptions, _logger);
        _association.ProcessEvent(AssociationEvent.TransportConnectionConfirm);

        // Send A-ASSOCIATE-RQ
        await SendAssociateRequestAsync(presentationContexts, ct);

        // Receive A-ASSOCIATE-AC/RJ
        await ReceiveAssociateResponseAsync(ct);

        if (!_association.IsEstablished)
        {
            throw new DicomAssociationException("Association was not established");
        }

        _logger.LogInformation("Association established with {CalledAE}", _options.CalledAE);
        return _association;
    }

    /// <summary>
    /// Send A-RELEASE-RQ and wait for A-RELEASE-RP.
    /// </summary>
    public async ValueTask ReleaseAsync(CancellationToken ct = default)
    {
        if (_association == null || !_association.IsEstablished)
            return;

        _logger.LogDebug("Releasing association");
        _association.ProcessEvent(AssociationEvent.AReleaseRequest);

        // Send A-RELEASE-RQ
        await SendReleaseRequestAsync(ct);

        // Receive A-RELEASE-RP
        await ReceiveReleaseResponseAsync(ct);
    }

    /// <summary>
    /// Send A-ABORT and close connection immediately.
    /// </summary>
    public void Abort(AbortSource source = AbortSource.ServiceUser, AbortReason reason = AbortReason.NotSpecified)
    {
        if (_stream == null) return;

        _logger.LogDebug("Aborting association");
        _association?.ProcessEvent(AssociationEvent.AAbortRequest);

        // Send A-ABORT (best effort, don't wait for response)
        try
        {
            using var buffer = new ArrayBufferWriter<byte>();
            var writer = new PduWriter(buffer);
            writer.WriteAbort(source, reason);
            _stream.Write(buffer.WrittenSpan);
        }
        catch { /* Best effort */ }
    }

    // Internal helpers
    private ushort NextMessageId() => ++_messageId;

    private async ValueTask SendAssociateRequestAsync(
        IReadOnlyList<PresentationContext> contexts,
        CancellationToken ct);

    private async ValueTask ReceiveAssociateResponseAsync(CancellationToken ct);

    private async ValueTask SendReleaseRequestAsync(CancellationToken ct);

    private async ValueTask ReceiveReleaseResponseAsync(CancellationToken ct);

    internal async ValueTask SendPDataAsync(
        IReadOnlyList<PresentationDataValue> pdvs,
        CancellationToken ct);

    internal async ValueTask<PresentationDataValue> ReceivePDataAsync(
        CancellationToken ct);

    // Serialize command to byte array and wrap in PDV
    internal byte[] SerializeCommand(DicomCommand command);

    public async ValueTask DisposeAsync()
    {
        if (_disposed) return;
        _disposed = true;

        try
        {
            await ReleaseAsync();
        }
        catch
        {
            Abort();
        }
        finally
        {
            _stream?.Dispose();
            _tcp?.Dispose();
        }
    }
}
```

Key implementation notes:
- Use ArrayPool<byte>.Shared for PDU receive buffers
- Always read 6-byte PDU header first, then exact body length
- Use ReadExactlyAsync for complete reads (handles TCP fragmentation)
- Log state transitions and PDU types at Debug level
  </action>
  <verify>
dotnet build src/SharpDicom/SharpDicom.csproj
  </verify>
  <done>
DicomClient compiles. Connect/Release/Abort methods implemented. Async patterns with CancellationToken.
  </done>
</task>

<task type="auto">
  <name>Task 3: DicomClient unit tests</name>
  <files>
    tests/SharpDicom.Tests/Network/DicomClientTests.cs
  </files>
  <action>
Create unit tests for DicomClient:

**DicomClientTests.cs:**

Note: Full integration tests require a real DICOM server. For unit tests, focus on:

1. **Options validation tests:**
   - Empty host throws ArgumentException
   - Invalid port throws ArgumentOutOfRangeException
   - Invalid AE title throws (via AssociationOptions)

2. **State tests:**
   - IsConnected returns false before connect
   - Dispose can be called multiple times safely
   - Connect after dispose throws ObjectDisposedException

3. **PDU serialization tests:**
   - SerializeCommand produces valid command dataset bytes
   - Command dataset includes all required Group 0000 tags

4. **Timeout tests (mock-based if possible):**
   - Connection timeout produces TimeoutException with helpful message

For full integration testing against DCMTK, add a separate test class:
```csharp
[TestFixture]
[Category("Integration")]
[Explicit("Requires DCMTK storescp running")]
public class DicomClientIntegrationTests
{
    // These tests are explicit - run manually with DCMTK
}
```

The Phase 10 success criteria require testing against DCMTK, but those will be checkpoint:human-verify tests in Plan 07.
  </action>
  <verify>
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~DicomClientTests"
  </verify>
  <done>
DicomClient option validation tests pass. State tests pass. Unit tests don't require external server.
  </done>
</task>

</tasks>

<verification>
All verification commands must pass:

```bash
# Build the library
dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release

# Run DicomClient tests
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~DicomClient"

# Run all tests
dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj

# Verify DicomClient structure
grep -A 5 "public sealed class DicomClient" src/SharpDicom/Network/DicomClient.cs
grep "IAsyncDisposable" src/SharpDicom/Network/DicomClient.cs
```
</verification>

<success_criteria>
- DicomClient implements IAsyncDisposable
- ConnectAsync establishes TCP connection and negotiates association
- ReleaseAsync sends A-RELEASE-RQ/RP sequence
- Abort sends A-ABORT for immediate disconnect
- All async methods accept CancellationToken
- Connection timeout configurable via DicomClientOptions
- All tests pass
- No build warnings
</success_criteria>

<output>
After completion, create `.planning/phases/10-network-foundation/10-05-SUMMARY.md`
</output>
