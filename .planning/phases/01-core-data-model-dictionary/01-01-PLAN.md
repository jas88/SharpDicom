---
phase: 01-core-data-model-dictionary
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SharpDicom/SharpDicom.csproj
  - src/SharpDicom/Data/DicomTag.cs
  - src/SharpDicom/Data/DicomVR.cs
  - src/SharpDicom/Data/DicomMaskedTag.cs
  - src/SharpDicom/Data/ValueMultiplicity.cs
  - src/SharpDicom/Data/Exceptions/DicomException.cs
  - tests/SharpDicom.Tests/SharpDicom.Tests.csproj
  - tests/SharpDicom.Tests/Data/DicomTagTests.cs
  - tests/SharpDicom.Tests/Data/DicomVRTests.cs
  - Directory.Build.props
  - Directory.Packages.props
  - global.json
  - SharpDicom.sln
autonomous: true

must_haves:
  truths:
    - "DicomTag can be created from group/element and compared for equality"
    - "DicomVR can be created from two-character codes and reports validity"
    - "Solution builds without warnings on net9.0"
    - "Unit tests pass for DicomTag and DicomVR"
  artifacts:
    - path: "src/SharpDicom/SharpDicom.csproj"
      provides: "Multi-targeted library project"
      contains: "netstandard2.0;net6.0;net8.0;net9.0"
    - path: "src/SharpDicom/Data/DicomTag.cs"
      provides: "DicomTag readonly record struct"
      min_lines: 50
    - path: "src/SharpDicom/Data/DicomVR.cs"
      provides: "DicomVR readonly record struct with static VR instances"
      min_lines: 80
    - path: "tests/SharpDicom.Tests/Data/DicomTagTests.cs"
      provides: "DicomTag unit tests"
      min_lines: 40
  key_links:
    - from: "tests/SharpDicom.Tests/SharpDicom.Tests.csproj"
      to: "src/SharpDicom/SharpDicom.csproj"
      via: "ProjectReference"
      pattern: "ProjectReference.*SharpDicom.csproj"
---

<objective>
Set up the SharpDicom solution with foundational project structure and core primitive types (DicomTag, DicomVR, DicomMaskedTag, ValueMultiplicity).

Purpose: Establish the project foundation and implement the most fundamental DICOM data types that all other components depend on.

Output:
- Working .NET solution with multi-targeted library
- DicomTag (4-byte readonly record struct)
- DicomVR (2-byte readonly record struct with static instances)
- DicomMaskedTag (for pattern matching like 50xx,0010)
- ValueMultiplicity (min/max/unlimited)
- Exception hierarchy base classes
- Unit tests for primitive types
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-data-model-dictionary/01-CONTEXT.md
@.planning/phases/01-core-data-model-dictionary/01-RESEARCH.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create solution and project structure</name>
  <files>
    SharpDicom.sln
    global.json
    Directory.Build.props
    Directory.Packages.props
    src/SharpDicom/SharpDicom.csproj
    tests/SharpDicom.Tests/SharpDicom.Tests.csproj
  </files>
  <action>
Create the .NET solution with proper project structure:

1. Create `global.json` pinning SDK version to 9.0.x (latest stable)

2. Create `Directory.Build.props` with:
   - Nullable enabled
   - TreatWarningsAsErrors true
   - AnalysisLevel latest
   - GenerateDocumentationFile true
   - LangVersion latest
   - ImplicitUsings disable (explicit imports for clarity)

3. Create `Directory.Packages.props` with Central Package Management:
   - NUnit 4.x
   - NUnit3TestAdapter latest
   - Microsoft.NET.Test.Sdk latest
   - coverlet.collector latest

4. Create `src/SharpDicom/SharpDicom.csproj`:
   - Multi-target: netstandard2.0;net6.0;net8.0;net9.0
   - RootNamespace: SharpDicom
   - Nullable enabled
   - AllowUnsafeBlocks true (needed for Span manipulation)
   - Include System.Memory package for netstandard2.0

5. Create `tests/SharpDicom.Tests/SharpDicom.Tests.csproj`:
   - Target net9.0 only (primary test TFM)
   - Reference SharpDicom project
   - Include NUnit packages

6. Create `SharpDicom.sln` with both projects
  </action>
  <verify>
    dotnet build SharpDicom.sln --configuration Release
  </verify>
  <done>
    Solution builds successfully with no errors or warnings on all target frameworks
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement DicomTag and DicomVR primitives</name>
  <files>
    src/SharpDicom/Data/DicomTag.cs
    src/SharpDicom/Data/DicomVR.cs
    src/SharpDicom/Data/DicomVRInfo.cs
    src/SharpDicom/Data/DicomMaskedTag.cs
    src/SharpDicom/Data/ValueMultiplicity.cs
    src/SharpDicom/Data/Exceptions/DicomException.cs
    src/SharpDicom/Data/Exceptions/DicomDataException.cs
    src/SharpDicom/Data/Exceptions/DicomTagException.cs
    src/SharpDicom/Data/Exceptions/DicomVRException.cs
  </files>
  <action>
Implement core primitive types following CONTEXT.md decisions:

**DicomTag** (src/SharpDicom/Data/DicomTag.cs):
- readonly record struct with single uint _value field (4 bytes total)
- Constructor: DicomTag(ushort group, ushort element) and DicomTag(uint value)
- Properties: Group, Element, Value (computed from _value)
- IsPrivate: (Group & 1) == 1
- IsPrivateCreator: IsPrivate && Element > 0x0000 && Element <= 0x00FF
- PrivateCreatorSlot: (byte)(Element >> 8) for private data elements
- PrivateCreatorKey: uint for PrivateCreatorDictionary lookup
- IEquatable<DicomTag>: Equals via _value comparison
- IComparable<DicomTag>: CompareTo via _value.CompareTo
- GetHashCode: return (int)_value
- ToString: $"({Group:X4},{Element:X4})"
- Static Parse method: accepts "(GGGG,EEEE)" or "GGGGEEEE" hex formats
- XML documentation on all public members

**DicomVR** (src/SharpDicom/Data/DicomVR.cs):
- readonly record struct with ushort _code field (2 bytes total)
- Constructor: DicomVR(byte char1, byte char2), DicomVR(string code)
- Static FromBytes(ReadOnlySpan<byte> bytes)
- Properties: Char1, Char2, Code
- IsKnown: check against known VR lookup
- Explicit IEquatable<DicomVR>: Equals via _code comparison
- GetHashCode: return _code
- ToString: return two-character string
- Static readonly instances for all 31 standard VRs (AE, AS, AT, CS, DA, DS, DT, FL, FD, IS, LO, LT, OB, OD, OF, OL, OW, PN, SH, SL, SQ, SS, ST, TM, UC, UI, UL, UN, UR, US, UT)
- XML documentation

**DicomVRInfo** (src/SharpDicom/Data/DicomVRInfo.cs):
- readonly record struct
- Properties: VR, Name, PaddingByte, MaxLength, IsStringVR, Is16BitLength, CanHaveUndefinedLength, MultiValueDelimiter
- Static GetInfo(DicomVR vr) method that returns info or default for unknown
- Hardcoded data for all 31 VRs (generator will supplement later)

**DicomMaskedTag** (src/SharpDicom/Data/DicomMaskedTag.cs):
- readonly record struct
- Properties: Mask (uint), Card (uint - expected value after masking)
- Matches(DicomTag tag): (tag.Value & Mask) == Card
- Factory method FromPattern(string pattern) parsing "50xx,0010" format

**ValueMultiplicity** (src/SharpDicom/Data/ValueMultiplicity.cs):
- readonly record struct
- Properties: Min (ushort), Max (ushort), IsUnlimited (bool)
- Static instances: VM_1, VM_1_N, VM_2, VM_3, etc.
- IsValid(int count) method

**Exception hierarchy** (src/SharpDicom/Data/Exceptions/):
- DicomException : Exception (base class)
- DicomDataException : DicomException (with Tag?, VR?, StreamPosition?, ElementValue? properties)
- DicomTagException : DicomDataException
- DicomVRException : DicomDataException (with InvalidVR, ExpectedVR? properties)

All types must:
- Be in SharpDicom.Data namespace (exceptions in SharpDicom.Data.Exceptions)
- Have full XML documentation
- Use #if NET8_0_OR_GREATER for newer APIs where applicable
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    All primitive types compile without warnings, XML docs complete
  </done>
</task>

<task type="auto">
  <name>Task 3: Write unit tests for primitives</name>
  <files>
    tests/SharpDicom.Tests/Data/DicomTagTests.cs
    tests/SharpDicom.Tests/Data/DicomVRTests.cs
    tests/SharpDicom.Tests/Data/DicomMaskedTagTests.cs
    tests/SharpDicom.Tests/Data/ValueMultiplicityTests.cs
  </files>
  <action>
Write comprehensive NUnit tests:

**DicomTagTests.cs**:
- Construction from group/element
- Construction from uint
- Group and Element property extraction
- Equality (two tags with same value are equal)
- Inequality (different tags are not equal)
- Comparison (ordering by uint value)
- Hashing (same tag = same hash)
- ToString format "(GGGG,EEEE)"
- Parse from hex string "(0010,0020)"
- Parse from compact hex "00100020"
- IsPrivate detection (odd group number)
- IsPrivateCreator detection
- PrivateCreatorSlot extraction
- Edge cases: (0000,0000), (FFFF,FFFF)

**DicomVRTests.cs**:
- Construction from bytes
- Construction from string
- All 31 static VR instances exist and have correct codes
- IsKnown for standard VRs returns true
- IsKnown for unknown VR returns false
- Equality between instances
- GetInfo returns correct metadata for each VR
- Use [TestCase] for data-driven tests across all VRs
- Test VRInfo properties: padding byte, max length, etc.

**DicomMaskedTagTests.cs**:
- FromPattern parsing "(50xx,0010)"
- Matches returns true for matching tags
- Matches returns false for non-matching tags
- Various mask patterns (xxxx, 00xx, xx00)

**ValueMultiplicityTests.cs**:
- Static VM instances have correct values
- IsValid for various counts
- IsUnlimited property

Use NUnit Assert (not FluentAssertions per CONTEXT.md).
  </action>
  <verify>
    dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --configuration Release --verbosity normal
  </verify>
  <done>
    All unit tests pass, covering DicomTag and DicomVR core functionality
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Solution structure is correct:
   ```
   SharpDicom/
   ├── SharpDicom.sln
   ├── global.json
   ├── Directory.Build.props
   ├── Directory.Packages.props
   ├── src/SharpDicom/
   │   ├── SharpDicom.csproj
   │   └── Data/
   │       ├── DicomTag.cs
   │       ├── DicomVR.cs
   │       ├── DicomVRInfo.cs
   │       ├── DicomMaskedTag.cs
   │       ├── ValueMultiplicity.cs
   │       └── Exceptions/
   └── tests/SharpDicom.Tests/
       └── Data/
   ```

2. Build succeeds on all TFMs:
   ```bash
   dotnet build --configuration Release
   ```

3. Tests pass:
   ```bash
   dotnet test --configuration Release
   ```

4. No warnings in build output
</verification>

<success_criteria>
- Solution builds without errors or warnings on all target frameworks
- DicomTag equality/comparison/hashing works correctly
- DicomVR static instances (AE, DA, UI, etc.) are accessible
- All unit tests pass
- XML documentation generates without warnings
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-data-model-dictionary/01-01-SUMMARY.md`
</output>
