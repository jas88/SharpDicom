---
phase: 01-core-data-model-dictionary
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SharpDicom.Generators/SharpDicom.Generators.csproj
  - src/SharpDicom.Generators/DicomDictionaryGenerator.cs
  - src/SharpDicom.Generators/Parsing/Part6Parser.cs
  - src/SharpDicom.Generators/Parsing/Part7Parser.cs
  - src/SharpDicom.Generators/Emitters/TagEmitter.cs
  - src/SharpDicom.Generators/Emitters/UidEmitter.cs
  - data/dicom-standard/part06.xml
  - data/dicom-standard/part07.xml
  - data/dicom-standard/VERSION
autonomous: true

must_haves:
  truths:
    - "NEMA Part 6 and Part 7 XML files are cached in repository"
    - "Source generator project compiles as netstandard2.0 analyzer"
    - "Generator can be referenced by main library"
  artifacts:
    - path: "data/dicom-standard/part06.xml"
      provides: "DICOM Part 6 data dictionary XML"
      min_lines: 10000
    - path: "data/dicom-standard/part07.xml"
      provides: "DICOM Part 7 command fields XML"
      min_lines: 1000
    - path: "src/SharpDicom.Generators/SharpDicom.Generators.csproj"
      provides: "Roslyn source generator project"
      contains: "Microsoft.CodeAnalysis"
    - path: "src/SharpDicom.Generators/DicomDictionaryGenerator.cs"
      provides: "IIncrementalGenerator implementation"
      contains: "[Generator]"
  key_links:
    - from: "src/SharpDicom.Generators/DicomDictionaryGenerator.cs"
      to: "data/dicom-standard/part06.xml"
      via: "AdditionalTextsProvider"
      pattern: "AdditionalTextsProvider"
---

<objective>
Download and cache NEMA DICOM standard XML files, and create the source generator infrastructure for parsing them.

Purpose: Provide the raw DICOM dictionary data and set up the Roslyn incremental generator that will transform XML into C# code.

Output:
- Cached NEMA Part 6 (data dictionary) and Part 7 (command fields) XML files
- SharpDicom.Generators project with IIncrementalGenerator skeleton
- XML parsing infrastructure (Part6Parser, Part7Parser)
- Code emission infrastructure (TagEmitter, UidEmitter stubs)
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-data-model-dictionary/01-CONTEXT.md
@.planning/phases/01-core-data-model-dictionary/01-RESEARCH.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Download and cache NEMA XML files</name>
  <files>
    data/dicom-standard/part06.xml
    data/dicom-standard/part07.xml
    data/dicom-standard/VERSION
  </files>
  <action>
Download the NEMA DICOM standard XML files from the official source:

1. Create `data/dicom-standard/` directory

2. Download Part 6 (Data Dictionary):
   URL: https://dicom.nema.org/medical/dicom/current/source/docbook/part06/part06.xml
   Save to: data/dicom-standard/part06.xml

3. Download Part 7 (Message Exchange - contains command field definitions):
   URL: https://dicom.nema.org/medical/dicom/current/source/docbook/part07/part07.xml
   Save to: data/dicom-standard/part07.xml

4. Create VERSION file with current date and DICOM version info:
   ```
   Source: NEMA DICOM Standard
   Downloaded: YYYY-MM-DD
   URL: https://dicom.nema.org/medical/dicom/current/source/docbook/
   ```

5. Verify files are valid XML by attempting to parse them

Note: These files are ~5-10MB each. The DocBook format uses XML namespaces.
If download fails, use curl with appropriate headers and retry.
  </action>
  <verify>
    test -f data/dicom-standard/part06.xml && test -f data/dicom-standard/part07.xml && head -5 data/dicom-standard/part06.xml
  </verify>
  <done>
    Part 6 and Part 7 XML files exist and contain valid XML content
  </done>
</task>

<task type="auto">
  <name>Task 2: Create source generator project</name>
  <files>
    src/SharpDicom.Generators/SharpDicom.Generators.csproj
    src/SharpDicom.Generators/DicomDictionaryGenerator.cs
    SharpDicom.sln
  </files>
  <action>
Create the Roslyn source generator project:

1. Create `src/SharpDicom.Generators/SharpDicom.Generators.csproj`:
   - Target netstandard2.0 (required for source generators)
   - Add package references:
     - Microsoft.CodeAnalysis.CSharp (4.8.0 or latest compatible)
     - Microsoft.CodeAnalysis.Analyzers (latest)
   - Set EnforceExtendedAnalyzerRules to true
   - Set IsRoslynComponent to true
   - Set IncludeBuildOutput to false (analyzer-only)
   - Disable nullable (netstandard2.0 limitation)

2. Create `src/SharpDicom.Generators/DicomDictionaryGenerator.cs`:
   - Implement IIncrementalGenerator
   - Add [Generator] attribute
   - In Initialize method:
     a. Use AdditionalTextsProvider to filter for part06.xml and part07.xml
     b. Set up pipeline stages (will be completed in Plan 04)
     c. For now, just register a simple source output that emits a placeholder comment

3. Update SharpDicom.sln to include the Generators project

4. Update src/SharpDicom/SharpDicom.csproj to reference the generator:
   ```xml
   <ItemGroup>
     <ProjectReference Include="..\SharpDicom.Generators\SharpDicom.Generators.csproj"
                       OutputItemType="Analyzer"
                       ReferenceOutputAssembly="false" />
     <AdditionalFiles Include="..\..\data\dicom-standard\*.xml" />
   </ItemGroup>
   ```

The generator skeleton should:
- Have proper namespaces (SharpDicom.Generators)
- Follow incremental generator patterns from research
- Be ready for XML parsing logic to be added
  </action>
  <verify>
    dotnet build src/SharpDicom.Generators/SharpDicom.Generators.csproj --configuration Release
  </verify>
  <done>
    Generator project compiles without errors as a valid Roslyn analyzer
  </done>
</task>

<task type="auto">
  <name>Task 3: Create XML parsing and code emission infrastructure</name>
  <files>
    src/SharpDicom.Generators/Parsing/Part6Parser.cs
    src/SharpDicom.Generators/Parsing/Part7Parser.cs
    src/SharpDicom.Generators/Parsing/TagDefinition.cs
    src/SharpDicom.Generators/Parsing/UidDefinition.cs
    src/SharpDicom.Generators/Emitters/TagEmitter.cs
    src/SharpDicom.Generators/Emitters/UidEmitter.cs
  </files>
  <action>
Create the parsing and emission infrastructure:

**TagDefinition.cs** (src/SharpDicom.Generators/Parsing/):
Record struct for passing tag data through generator pipeline:
```csharp
internal readonly record struct TagDefinition(
    ushort Group,
    ushort Element,
    string Keyword,
    string Name,
    string[] VRs,           // Multiple VRs possible
    string VM,              // e.g., "1", "1-n", "2-2n"
    bool IsRetired
);
```

**UidDefinition.cs** (src/SharpDicom.Generators/Parsing/):
Record struct for UID data:
```csharp
internal readonly record struct UidDefinition(
    string Value,           // e.g., "1.2.840.10008.1.2"
    string Keyword,         // e.g., "ImplicitVRLittleEndian"
    string Name,            // e.g., "Implicit VR Little Endian"
    string Type,            // e.g., "Transfer Syntax", "SOP Class"
    bool IsRetired
);
```

**Part6Parser.cs** (src/SharpDicom.Generators/Parsing/):
Static class with methods to parse Part 6 XML:
- `ParseTags(XDocument doc)`: Returns IEnumerable<TagDefinition>
- `ParseUids(XDocument doc)`: Returns IEnumerable<UidDefinition>
- Uses XNamespace for DocBook namespace handling
- Finds table rows containing tag/UID definitions
- Handles retired entries (marked in XML)
- Stub implementation that returns empty for now (will be completed in Plan 04)

**Part7Parser.cs** (src/SharpDicom.Generators/Parsing/):
Static class for Part 7 (command field tags):
- `ParseCommandTags(XDocument doc)`: Returns IEnumerable<TagDefinition>
- Group 0000 tags only
- Stub implementation

**TagEmitter.cs** (src/SharpDicom.Generators/Emitters/):
Static class to generate C# source:
- `Emit(ImmutableArray<TagDefinition> tags)`: Returns string
- Generates DicomTag.Generated.cs content
- Uses StringBuilder for efficient string building
- Handles #if NET8_0_OR_GREATER for FrozenDictionary
- Stub that generates placeholder class for now

**UidEmitter.cs** (src/SharpDicom.Generators/Emitters/):
Static class to generate UID source:
- `Emit(ImmutableArray<UidDefinition> uids)`: Returns string
- Generates DicomUID.Generated.cs content
- Stub implementation

All parsers should:
- Use System.Xml.Linq (XDocument, XElement)
- Handle XML namespaces properly
- Be static methods (no instance state)
- Return value types/immutable collections for pipeline caching
  </action>
  <verify>
    dotnet build src/SharpDicom.Generators/SharpDicom.Generators.csproj --configuration Release && dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    Generator project compiles with parsing/emission stubs, main library can reference generator
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. NEMA XML files exist and are valid:
   ```bash
   ls -la data/dicom-standard/
   head -20 data/dicom-standard/part06.xml
   ```

2. Generator project structure is correct:
   ```
   src/SharpDicom.Generators/
   ├── SharpDicom.Generators.csproj
   ├── DicomDictionaryGenerator.cs
   ├── Parsing/
   │   ├── TagDefinition.cs
   │   ├── UidDefinition.cs
   │   ├── Part6Parser.cs
   │   └── Part7Parser.cs
   └── Emitters/
       ├── TagEmitter.cs
       └── UidEmitter.cs
   ```

3. Full solution builds:
   ```bash
   dotnet build SharpDicom.sln --configuration Release
   ```

4. Generator is correctly referenced as analyzer
</verification>

<success_criteria>
- Part 6 and Part 7 XML files are cached in repository
- Generator project compiles as netstandard2.0 analyzer
- Main library references generator correctly
- Parsing and emission infrastructure is in place (stubs)
- Solution builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-data-model-dictionary/01-02-SUMMARY.md`
</output>
