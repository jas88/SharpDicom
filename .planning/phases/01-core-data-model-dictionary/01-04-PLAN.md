---
phase: 01-core-data-model-dictionary
plan: 04
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - src/SharpDicom.Generators/Parsing/Part6Parser.cs
  - src/SharpDicom.Generators/Parsing/Part7Parser.cs
  - src/SharpDicom.Generators/Emitters/TagEmitter.cs
  - src/SharpDicom.Generators/Emitters/UidEmitter.cs
  - src/SharpDicom.Generators/Emitters/TransferSyntaxEmitter.cs
  - src/SharpDicom.Generators/Emitters/DictionaryEmitter.cs
  - src/SharpDicom.Generators/DicomDictionaryGenerator.cs
autonomous: true

must_haves:
  truths:
    - "Part6Parser extracts tag definitions from NEMA XML"
    - "Part6Parser extracts UID definitions from NEMA XML"
    - "TagEmitter generates valid C# source with static tag members"
    - "Generator produces DicomTag.Generated.cs when run"
  artifacts:
    - path: "src/SharpDicom.Generators/Parsing/Part6Parser.cs"
      provides: "XML parsing for Part 6 dictionary"
      min_lines: 100
    - path: "src/SharpDicom.Generators/Emitters/TagEmitter.cs"
      provides: "C# code generation for tags"
      min_lines: 80
    - path: "src/SharpDicom.Generators/DicomDictionaryGenerator.cs"
      provides: "Complete IIncrementalGenerator"
      min_lines: 60
  key_links:
    - from: "src/SharpDicom.Generators/DicomDictionaryGenerator.cs"
      to: "src/SharpDicom.Generators/Parsing/Part6Parser.cs"
      via: "ParseTags call"
      pattern: "Part6Parser\\.ParseTags"
    - from: "src/SharpDicom.Generators/DicomDictionaryGenerator.cs"
      to: "src/SharpDicom.Generators/Emitters/TagEmitter.cs"
      via: "Emit call"
      pattern: "TagEmitter\\.Emit"
---

<objective>
Complete the source generator by implementing XML parsing and C# code emission logic.

Purpose: Transform the NEMA XML files into generated C# source code that provides static tag/UID members and dictionary lookup tables.

Output:
- Complete Part6Parser that extracts ~4000 tags and UIDs from XML
- Complete Part7Parser for command field tags
- TagEmitter that generates DicomTag.Generated.cs
- UidEmitter that generates DicomUID.Generated.cs
- TransferSyntaxEmitter for transfer syntax definitions
- DictionaryEmitter for lookup tables with FrozenDictionary support
- Working generator that produces code on build
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-data-model-dictionary/01-CONTEXT.md
@.planning/phases/01-core-data-model-dictionary/01-RESEARCH.md
@.planning/phases/01-core-data-model-dictionary/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Part6Parser XML extraction</name>
  <files>
    src/SharpDicom.Generators/Parsing/Part6Parser.cs
  </files>
  <action>
Implement Part6Parser to extract data from NEMA Part 6 DocBook XML:

First, analyze the actual XML structure by examining part06.xml. The NEMA DocBook XML uses:
- DocBook namespace: http://docbook.org/ns/docbook
- Tables with specific IDs for data dictionary and UID registry

**ParseTags method**:
1. Load XDocument and handle DocBook namespace
2. Find the data dictionary table (look for table with title containing "Registry of DICOM Data Elements")
3. Extract rows containing: Tag, Name, Keyword, VR, VM, Retired status
4. Parse tag format "(GGGG,EEEE)" or with "x" wildcards
5. Handle multi-VR entries (e.g., "US or SS")
6. Return IEnumerable<TagDefinition>

**ParseUids method**:
1. Find UID registry table
2. Extract: UID Value, UID Name, UID Keyword, UID Type (Transfer Syntax, SOP Class, etc.)
3. Handle retired UIDs
4. Return IEnumerable<UidDefinition>

Key parsing considerations:
- Use XNamespace for DocBook
- Handle whitespace and formatting variations
- Convert DICOM naming to C# naming (remove spaces, handle abbreviations)
- Mark masked tags specially (50xx becomes pattern)
- Handle optional fields gracefully

Example XPath-style queries:
```csharp
XNamespace db = "http://docbook.org/ns/docbook";
var rows = doc.Descendants(db + "tbody")
              .Elements(db + "tr");
```

Keyword conversion rules:
- Remove spaces: "Patient ID" -> "PatientId"
- Handle abbreviations: "SOP" stays "SOP", "UID" stays "UID"
- CamelCase: first letter uppercase, rest as-is
- .NET naming conventions (PatientId not PatientID)

Handle errors gracefully - skip malformed entries rather than failing build.
  </action>
  <verify>
    dotnet build src/SharpDicom.Generators/SharpDicom.Generators.csproj --configuration Release
  </verify>
  <done>
    Part6Parser compiles and has complete parsing logic for tags and UIDs
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement code emitters</name>
  <files>
    src/SharpDicom.Generators/Emitters/TagEmitter.cs
    src/SharpDicom.Generators/Emitters/UidEmitter.cs
    src/SharpDicom.Generators/Emitters/TransferSyntaxEmitter.cs
    src/SharpDicom.Generators/Emitters/DictionaryEmitter.cs
    src/SharpDicom.Generators/Parsing/Part7Parser.cs
  </files>
  <action>
Implement the code emitters:

**TagEmitter.cs**:
Generate DicomTag.Generated.cs with:
```csharp
// <auto-generated />
#nullable enable

namespace SharpDicom.Data;

public readonly partial record struct DicomTag
{
    // Static tag definitions
    /// <summary>Patient ID (0010,0020)</summary>
    public static readonly DicomTag PatientId = new(0x0010, 0x0020);
    // ... ~4000 more

    // Masked tags for pattern matching
    public static readonly DicomMaskedTag OverlayData = DicomMaskedTag.FromPattern("(60xx,3000)");
}
```

Use StringBuilder for efficient generation. Include:
- XML documentation comments with tag description
- Group tags logically (File Meta, Patient, Study, Series, etc.)
- Mark retired tags with [Obsolete] attribute

**UidEmitter.cs**:
Generate DicomUID.Generated.cs with:
```csharp
public readonly partial struct DicomUID
{
    /// <summary>Implicit VR Little Endian - Transfer Syntax</summary>
    public static readonly DicomUID ImplicitVRLittleEndian = new("1.2.840.10008.1.2");
    // ... hundreds more
}
```

**TransferSyntaxEmitter.cs**:
Generate TransferSyntax.Generated.cs with transfer syntax definitions extracted from UIDs.

**DictionaryEmitter.cs**:
Generate DicomDictionary.Generated.cs with:
```csharp
public partial class DicomDictionary
{
    private static readonly DicomDictionaryEntry[] s_entries = new[]
    {
        new DicomDictionaryEntry(
            new DicomTag(0x0010, 0x0020),
            "PatientId",
            "Patient ID",
            new[] { DicomVR.LO },
            ValueMultiplicity.VM_1,
            false),
        // ... all entries
    };

#if NET8_0_OR_GREATER
    private static readonly FrozenDictionary<uint, DicomDictionaryEntry> s_byTag =
        s_entries.ToFrozenDictionary(e => e.Tag.Value);
#else
    private static readonly Dictionary<uint, DicomDictionaryEntry> s_byTag =
        s_entries.ToDictionary(e => e.Tag.Value);
#endif
}
```

**Part7Parser.cs**:
Parse command field tags from Part 7 (Group 0000 tags like CommandField, MessageID, etc.)

All emitters should:
- Generate valid, compilable C# code
- Include proper using statements
- Use #nullable enable
- Include <auto-generated /> header
- Handle special characters in names
  </action>
  <verify>
    dotnet build src/SharpDicom.Generators/SharpDicom.Generators.csproj --configuration Release
  </verify>
  <done>
    All emitters compile and generate valid C# source code patterns
  </done>
</task>

<task type="auto">
  <name>Task 3: Complete generator pipeline</name>
  <files>
    src/SharpDicom.Generators/DicomDictionaryGenerator.cs
  </files>
  <action>
Complete the DicomDictionaryGenerator to wire parsing and emission:

```csharp
[Generator]
public class DicomDictionaryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 1. Filter for Part 6 XML
        var part6Xml = context.AdditionalTextsProvider
            .Where(static file => file.Path.EndsWith("part06.xml"));

        // 2. Parse tags from Part 6
        var tags = part6Xml
            .Select(static (text, ct) =>
            {
                var content = text.GetText(ct)?.ToString() ?? "";
                var doc = XDocument.Parse(content);
                return Part6Parser.ParseTags(doc).ToImmutableArray();
            })
            .SelectMany(static (tags, _) => tags)
            .Collect();

        // 3. Register DicomTag.Generated.cs output
        context.RegisterSourceOutput(tags,
            static (ctx, tagArray) =>
            {
                var source = TagEmitter.Emit(tagArray);
                ctx.AddSource("DicomTag.Generated.cs",
                    SourceText.From(source, Encoding.UTF8));
            });

        // 4. Parse UIDs from Part 6
        var uids = part6Xml
            .Select(static (text, ct) =>
            {
                var content = text.GetText(ct)?.ToString() ?? "";
                var doc = XDocument.Parse(content);
                return Part6Parser.ParseUids(doc).ToImmutableArray();
            })
            .SelectMany(static (uids, _) => uids)
            .Collect();

        // 5. Register DicomUID.Generated.cs output
        context.RegisterSourceOutput(uids,
            static (ctx, uidArray) =>
            {
                var source = UidEmitter.Emit(uidArray);
                ctx.AddSource("DicomUID.Generated.cs",
                    SourceText.From(source, Encoding.UTF8));
            });

        // 6. Generate dictionary lookup (needs both tags and UIDs)
        var combined = tags.Combine(uids);
        context.RegisterSourceOutput(combined,
            static (ctx, data) =>
            {
                var source = DictionaryEmitter.Emit(data.Left, data.Right);
                ctx.AddSource("DicomDictionary.Generated.cs",
                    SourceText.From(source, Encoding.UTF8));
            });

        // 7. Filter transfer syntaxes from UIDs and generate
        context.RegisterSourceOutput(uids,
            static (ctx, uidArray) =>
            {
                var transferSyntaxes = uidArray
                    .Where(u => u.Type == "Transfer Syntax")
                    .ToImmutableArray();
                var source = TransferSyntaxEmitter.Emit(transferSyntaxes);
                ctx.AddSource("TransferSyntax.Generated.cs",
                    SourceText.From(source, Encoding.UTF8));
            });

        // 8. Handle Part 7 (command fields) similarly
        var part7Xml = context.AdditionalTextsProvider
            .Where(static file => file.Path.EndsWith("part07.xml"));
        // ... parse and emit command tags
    }
}
```

Handle errors gracefully:
- Wrap parsing in try/catch
- Report diagnostics for XML errors
- Generate empty files rather than failing if XML is malformed

Add diagnostic descriptors:
- DICOM001: Invalid XML file
- DICOM002: Missing expected table
- DICOM003: Malformed tag definition
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release -v:n 2>&1 | head -100
  </verify>
  <done>
    Generator runs during build and produces generated source files
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build main library and check for generated files:
   ```bash
   dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release -v:n
   ```

2. Generated code should include DicomTag static members:
   ```bash
   # Check obj folder for generated files
   find src/SharpDicom/obj -name "*.Generated.cs" -exec head -50 {} \;
   ```

3. Solution builds completely:
   ```bash
   dotnet build SharpDicom.sln --configuration Release
   ```

4. No generator warnings in build output
</verification>

<success_criteria>
- Part6Parser extracts tags and UIDs from XML successfully
- TagEmitter generates ~4000 static DicomTag members
- UidEmitter generates static DicomUID members
- DictionaryEmitter generates lookup tables with FrozenDictionary support
- Generator runs on build without errors
- Generated code compiles without warnings
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-data-model-dictionary/01-04-SUMMARY.md`
</output>
