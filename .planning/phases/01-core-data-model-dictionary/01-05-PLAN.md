---
phase: 01-core-data-model-dictionary
plan: 05
type: execute
wave: 3
depends_on: ["01-01", "01-03"]
files_modified:
  - src/SharpDicom/Data/IDicomElement.cs
  - src/SharpDicom/Data/DicomElement.cs
  - src/SharpDicom/Data/DicomStringElement.cs
  - src/SharpDicom/Data/DicomNumericElement.cs
  - src/SharpDicom/Data/DicomSequence.cs
  - src/SharpDicom/Data/DicomFragmentSequence.cs
  - tests/SharpDicom.Tests/Data/DicomElementTests.cs
  - tests/SharpDicom.Tests/Data/DicomSequenceTests.cs
autonomous: true

must_haves:
  truths:
    - "IDicomElement interface defines common element contract"
    - "DicomElement implementations provide typed value access"
    - "DicomSequence holds nested datasets"
    - "Elements can be created with raw byte values"
  artifacts:
    - path: "src/SharpDicom/Data/IDicomElement.cs"
      provides: "Common element interface"
      min_lines: 20
    - path: "src/SharpDicom/Data/DicomStringElement.cs"
      provides: "String VR element implementation"
      min_lines: 50
    - path: "src/SharpDicom/Data/DicomSequence.cs"
      provides: "Sequence element with nested datasets"
      min_lines: 40
    - path: "tests/SharpDicom.Tests/Data/DicomElementTests.cs"
      provides: "Element unit tests"
      min_lines: 60
  key_links:
    - from: "src/SharpDicom/Data/DicomStringElement.cs"
      to: "src/SharpDicom/Data/IDicomElement.cs"
      via: "interface implementation"
      pattern: ": IDicomElement"
---

<objective>
Implement the DicomElement interface hierarchy and DicomSequence for representing DICOM data values.

Purpose: Complete the element types needed to hold DICOM values with typed accessors, following the interface-based design from CONTEXT.md.

Output:
- IDicomElement interface defining common contract
- DicomStringElement for text VRs (AE, AS, CS, DA, DS, DT, IS, LO, LT, PN, SH, ST, TM, UC, UI, UR, UT)
- DicomNumericElement for binary VRs (FL, FD, SL, SS, UL, US, AT)
- DicomBinaryElement for OB, OD, OF, OL, OW, UN
- DicomSequence for SQ VR
- DicomFragmentSequence for encapsulated pixel data
- Unit tests for element types
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-data-model-dictionary/01-CONTEXT.md
@.planning/phases/01-core-data-model-dictionary/01-01-SUMMARY.md
@.planning/phases/01-core-data-model-dictionary/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement IDicomElement interface and base elements</name>
  <files>
    src/SharpDicom/Data/IDicomElement.cs
    src/SharpDicom/Data/DicomElement.cs
    src/SharpDicom/Data/DicomStringElement.cs
    src/SharpDicom/Data/DicomNumericElement.cs
    src/SharpDicom/Data/DicomBinaryElement.cs
  </files>
  <action>
Implement the element interface hierarchy following CONTEXT.md:

**IDicomElement.cs** (src/SharpDicom/Data/):
```csharp
public interface IDicomElement
{
    DicomTag Tag { get; }
    DicomVR VR { get; }
    ReadOnlyMemory<byte> RawValue { get; }
    int Length { get; }
    bool IsEmpty { get; }

    // Create a deep copy that owns its memory
    IDicomElement ToOwned();
}
```

**DicomElement.cs** - Abstract base providing common functionality:
```csharp
public abstract class DicomElement : IDicomElement
{
    public DicomTag Tag { get; }
    public DicomVR VR { get; }
    public ReadOnlyMemory<byte> RawValue { get; }
    public int Length => RawValue.Length;
    public bool IsEmpty => RawValue.IsEmpty;

    protected DicomElement(DicomTag tag, DicomVR vr, ReadOnlyMemory<byte> value);

    public abstract IDicomElement ToOwned();
}
```

**DicomStringElement.cs** - For string VRs:
- Inherits DicomElement
- Covers: AE, AS, CS, DA, DS, DT, IS, LO, LT, PN, SH, ST, TM, UC, UI, UR, UT
- Methods:
  - GetString(DicomEncoding? encoding = null): string?
  - GetStringOrThrow(DicomEncoding? encoding = null): string
  - GetStrings(DicomEncoding? encoding = null): string[]? (for VM > 1, split by backslash)
  - GetStringsOrThrow(): string[]
- For specific VRs add convenience:
  - GetDate(): DateOnly? (for DA)
  - GetTime(): TimeOnly? (for TM)
  - GetDateTime(): DateTime? (for DT)
  - GetInt32(): int? (for IS)
  - GetFloat64(): double? (for DS)

**DicomNumericElement.cs** - For binary numeric VRs:
- Covers: FL, FD, SL, SS, UL, US, AT
- Generic accessor: GetValue<T>() where T is value type
- Specific accessors:
  - GetInt16(): short? (SS)
  - GetUInt16(): ushort? (US)
  - GetInt32(): int? (SL)
  - GetUInt32(): uint? (UL)
  - GetFloat32(): float? (FL)
  - GetFloat64(): double? (FD)
  - GetTag(): DicomTag? (AT)
- Array accessors for VM > 1:
  - GetInt16Array(): short[]?
  - etc.

**DicomBinaryElement.cs** - For binary data VRs:
- Covers: OB, OD, OF, OL, OW, UN
- Just provides RawValue access
- GetBytes(): ReadOnlyMemory<byte>

Design notes:
- All value parsing is stateless (no caching)
- Nullable return for invalid/empty values
- OrThrow variants throw DicomDataException
- ToOwned() copies RawValue to new array
- Encoding parameter for string elements defaults to ASCII

Include internal polyfills for DateOnly/TimeOnly on netstandard2.0.
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    Element interface hierarchy compiles, all element types implemented
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement DicomSequence and DicomFragmentSequence</name>
  <files>
    src/SharpDicom/Data/DicomSequence.cs
    src/SharpDicom/Data/DicomFragmentSequence.cs
    src/SharpDicom/Data/DicomDataset.cs
  </files>
  <action>
Implement sequence elements:

**DicomSequence.cs** (src/SharpDicom/Data/):
```csharp
public sealed class DicomSequence : IDicomElement
{
    public DicomTag Tag { get; }
    public DicomVR VR => DicomVR.SQ;
    public ReadOnlyMemory<byte> RawValue => ReadOnlyMemory<byte>.Empty;
    public int Length => -1;  // Undefined length for sequences
    public bool IsEmpty => Items.Count == 0;

    public IReadOnlyList<DicomDataset> Items { get; }

    public DicomSequence(DicomTag tag, IEnumerable<DicomDataset> items);

    public IDicomElement ToOwned() => new DicomSequence(Tag,
        Items.Select(ds => ds.ToOwned()).ToList());
}
```

**DicomFragmentSequence.cs** - For encapsulated pixel data:
```csharp
public sealed class DicomFragmentSequence : IDicomElement
{
    public DicomTag Tag { get; }  // Always (7FE0,0010)
    public DicomVR VR { get; }    // OB or OW
    public ReadOnlyMemory<byte> RawValue => ReadOnlyMemory<byte>.Empty;
    public int Length => -1;
    public bool IsEmpty => Fragments.Count == 0;

    public ReadOnlyMemory<byte> OffsetTable { get; }
    public IReadOnlyList<ReadOnlyMemory<byte>> Fragments { get; }

    public DicomFragmentSequence(
        DicomTag tag,
        DicomVR vr,
        ReadOnlyMemory<byte> offsetTable,
        IEnumerable<ReadOnlyMemory<byte>> fragments);

    public IDicomElement ToOwned();
}
```

**DicomDataset.cs** - Stub for Plan 06 (forward reference needed):
```csharp
public sealed partial class DicomDataset : IEnumerable<IDicomElement>
{
    // Full implementation in Plan 06
    // Stub needed here for DicomSequence.Items type

    public DicomDataset ToOwned();
    public IEnumerator<IDicomElement> GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator();
}
```

Sequence design notes:
- Sequences are classes (not structs) due to nested nature
- Items list is read-only once created
- ToOwned creates deep copy of entire sequence tree
- Fragment sequences separate from regular sequences
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    DicomSequence and DicomFragmentSequence compile with proper item containment
  </done>
</task>

<task type="auto">
  <name>Task 3: Write element unit tests</name>
  <files>
    tests/SharpDicom.Tests/Data/DicomElementTests.cs
    tests/SharpDicom.Tests/Data/DicomSequenceTests.cs
  </files>
  <action>
Write comprehensive NUnit tests:

**DicomElementTests.cs**:

String element tests:
- Create element with tag, VR, raw bytes
- GetString returns decoded value
- GetString handles empty value
- GetStrings splits on backslash for VM > 1
- GetDate parses DA format (YYYYMMDD)
- GetTime parses TM format (HHMMSS.FFFFFF)
- GetDateTime parses DT format
- GetInt32 parses IS format
- GetFloat64 parses DS format
- Invalid format returns null (not throws)
- GetStringOrThrow throws for invalid

Numeric element tests:
- GetInt16 reads SS value correctly
- GetUInt16 reads US value correctly
- GetInt32 reads SL value correctly
- GetUInt32 reads UL value correctly
- GetFloat32 reads FL value correctly
- GetFloat64 reads FD value correctly
- GetTag reads AT value correctly
- Array methods return multiple values
- Empty value returns null
- ToOwned creates independent copy

Binary element tests:
- GetBytes returns raw value
- ToOwned copies bytes

**DicomSequenceTests.cs**:
- Empty sequence has zero items
- Sequence with items returns them
- Items are read-only
- ToOwned creates deep copy
- Nested sequences work correctly

Use test data that represents real DICOM values:
- Patient ID "12345678"
- Study Date "20240115"
- Modality "CT"
- Pixel spacing as DS
  </action>
  <verify>
    dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomElementTests or FullyQualifiedName~DicomSequenceTests" --configuration Release
  </verify>
  <done>
    All element tests pass, covering typed accessors and sequence handling
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Element hierarchy structure:
   ```
   src/SharpDicom/Data/
   ├── IDicomElement.cs
   ├── DicomElement.cs
   ├── DicomStringElement.cs
   ├── DicomNumericElement.cs
   ├── DicomBinaryElement.cs
   ├── DicomSequence.cs
   ├── DicomFragmentSequence.cs
   └── DicomDataset.cs (stub)
   ```

2. Solution builds:
   ```bash
   dotnet build SharpDicom.sln --configuration Release
   ```

3. All tests pass:
   ```bash
   dotnet test tests/SharpDicom.Tests --configuration Release
   ```

4. Elements provide typed access to DICOM values
</verification>

<success_criteria>
- IDicomElement interface defines common contract
- String elements parse text values with encoding support
- Numeric elements read binary values correctly
- Sequences contain nested datasets
- ToOwned creates independent copies
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-data-model-dictionary/01-05-SUMMARY.md`
</output>
