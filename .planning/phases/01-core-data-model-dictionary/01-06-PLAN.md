---
phase: 01-core-data-model-dictionary
plan: 06
type: execute
wave: 3
depends_on: ["01-03", "01-04", "01-05"]
files_modified:
  - src/SharpDicom/Data/DicomDataset.cs
  - src/SharpDicom/Data/PrivateCreatorDictionary.cs
  - tests/SharpDicom.Tests/Data/DicomDatasetTests.cs
autonomous: true

must_haves:
  truths:
    - "DicomDataset provides O(1) element lookup by tag"
    - "DicomDataset enumerates elements in sorted order"
    - "Generated dictionary entries are accessible via DicomDictionary.Default"
    - "DicomTag static members from generator are usable"
  artifacts:
    - path: "src/SharpDicom/Data/DicomDataset.cs"
      provides: "Complete DicomDataset implementation"
      min_lines: 150
    - path: "src/SharpDicom/Data/PrivateCreatorDictionary.cs"
      provides: "Private tag creator tracking"
      min_lines: 30
    - path: "tests/SharpDicom.Tests/Data/DicomDatasetTests.cs"
      provides: "Dataset unit tests"
      min_lines: 80
  key_links:
    - from: "src/SharpDicom/Data/DicomDataset.cs"
      to: "src/SharpDicom/Data/IDicomElement.cs"
      via: "element storage"
      pattern: "Dictionary<DicomTag, IDicomElement>"
    - from: "tests/SharpDicom.Tests/Data/DicomDatasetTests.cs"
      to: "DicomTag.Generated.cs"
      via: "using generated tags"
      pattern: "DicomTag\\.PatientId|DicomTag\\.StudyDate"
---

<objective>
Complete the DicomDataset implementation and integrate with the generated dictionary.

Purpose: Provide the main data container that holds DICOM elements with O(1) lookup and sorted enumeration, wiring everything together with the source-generated code.

Output:
- Complete DicomDataset with all operations
- PrivateCreatorDictionary for private tag tracking
- Integration tests using generated DicomTag members
- Verification that generator output is usable
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-data-model-dictionary/01-CONTEXT.md
@.planning/phases/01-core-data-model-dictionary/01-03-SUMMARY.md
@.planning/phases/01-core-data-model-dictionary/01-04-SUMMARY.md
@.planning/phases/01-core-data-model-dictionary/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Complete DicomDataset implementation</name>
  <files>
    src/SharpDicom/Data/DicomDataset.cs
  </files>
  <action>
Complete the DicomDataset implementation following CONTEXT.md:

```csharp
public sealed partial class DicomDataset : IEnumerable<IDicomElement>
{
    private readonly Dictionary<DicomTag, IDicomElement> _elements = new();
    private readonly PrivateCreatorDictionary _privateCreators = new();
    private IDicomElement[]? _sortedCache;
    private bool _isDirty = true;

    // Constructors
    public DicomDataset() { }
    public DicomDataset(int capacity)
    {
        _elements = new Dictionary<DicomTag, IDicomElement>(capacity);
    }

    // Properties
    public int Count => _elements.Count;
    public PrivateCreatorDictionary PrivateCreators => _privateCreators;

    // Indexer - O(1) access
    public IDicomElement? this[DicomTag tag]
        => _elements.TryGetValue(tag, out var e) ? e : null;

    // Element access
    public bool Contains(DicomTag tag) => _elements.ContainsKey(tag);

    public bool TryGetElement(DicomTag tag, out IDicomElement element)
        => _elements.TryGetValue(tag, out element!);

    public T? GetElement<T>(DicomTag tag) where T : class, IDicomElement
        => this[tag] as T;

    // Mutation - invalidates cache
    public void Add(IDicomElement element)
    {
        _elements[element.Tag] = element;
        _isDirty = true;

        // Track private creators
        if (element.Tag.IsPrivateCreator && element is DicomStringElement se)
        {
            _privateCreators.Register(element.Tag, se.GetString() ?? "");
        }
    }

    public void AddOrUpdate(IDicomElement element) => Add(element);

    public void Update(IDicomElement element) => Add(element);

    public bool Remove(DicomTag tag)
    {
        if (_elements.Remove(tag))
        {
            _isDirty = true;
            return true;
        }
        return false;
    }

    public void Clear()
    {
        _elements.Clear();
        _privateCreators.Clear();
        _isDirty = true;
    }

    // Enumeration - sorted by tag
    public IEnumerator<IDicomElement> GetEnumerator()
    {
        if (_isDirty)
        {
            _sortedCache = _elements.Values.OrderBy(e => e.Tag).ToArray();
            _isDirty = false;
        }
        return ((IEnumerable<IDicomElement>)_sortedCache).GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    // Typed convenience accessors
    public string? GetString(DicomTag tag, DicomEncoding? encoding = null)
        => (this[tag] as DicomStringElement)?.GetString(encoding);

    public string GetStringOrThrow(DicomTag tag, DicomEncoding? encoding = null)
        => (this[tag] as DicomStringElement)?.GetString(encoding)
           ?? throw new DicomDataException($"Tag {tag} not found or not a string");

    public string[]? GetStrings(DicomTag tag, DicomEncoding? encoding = null)
        => (this[tag] as DicomStringElement)?.GetStrings(encoding);

    public int? GetInt32(DicomTag tag)
    {
        var element = this[tag];
        if (element is DicomNumericElement ne) return ne.GetInt32();
        if (element is DicomStringElement se) return se.GetInt32();
        return null;
    }

    public double? GetFloat64(DicomTag tag)
    {
        var element = this[tag];
        if (element is DicomNumericElement ne) return ne.GetFloat64();
        if (element is DicomStringElement se) return se.GetFloat64();
        return null;
    }

    public DateOnly? GetDate(DicomTag tag)
        => (this[tag] as DicomStringElement)?.GetDate();

    public TimeOnly? GetTime(DicomTag tag)
        => (this[tag] as DicomStringElement)?.GetTime();

    public DicomUID? GetUID(DicomTag tag)
    {
        var str = GetString(tag);
        return str != null ? new DicomUID(str.TrimEnd()) : null;
    }

    public DicomSequence? GetSequence(DicomTag tag)
        => this[tag] as DicomSequence;

    // Deep copy
    public DicomDataset ToOwned()
    {
        var copy = new DicomDataset(_elements.Count);
        foreach (var element in _elements.Values)
        {
            copy.Add(element.ToOwned());
        }
        return copy;
    }

    // Fluent API
    public DicomDataset WithElement(IDicomElement element)
    {
        Add(element);
        return this;
    }
}
```

Key implementation notes:
- Dictionary for O(1) lookup
- Sorted cache regenerated only when dirty
- Private creators tracked automatically
- Fluent API for chaining
- Typed accessors delegate to element types
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    DicomDataset compiles with full functionality
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement PrivateCreatorDictionary</name>
  <files>
    src/SharpDicom/Data/PrivateCreatorDictionary.cs
  </files>
  <action>
Implement PrivateCreatorDictionary for tracking private tag creators:

```csharp
public sealed class PrivateCreatorDictionary
{
    private readonly Dictionary<uint, string> _creators = new();

    /// <summary>
    /// Register a private creator element value during parsing.
    /// </summary>
    /// <param name="creatorTag">The private creator tag (odd group, element 0x00xx)</param>
    /// <param name="creator">The creator identifier string</param>
    public void Register(DicomTag creatorTag, string creator)
    {
        if (!creatorTag.IsPrivateCreator)
            throw new ArgumentException("Not a private creator tag", nameof(creatorTag));

        var key = ((uint)creatorTag.Group << 16) | creatorTag.Element;
        _creators[key] = creator;
    }

    /// <summary>
    /// Look up the creator for a private data element.
    /// </summary>
    /// <param name="tag">The private data element tag</param>
    /// <returns>The creator string, or null if not registered</returns>
    public string? GetCreator(DicomTag tag)
    {
        if (!tag.IsPrivate || tag.IsPrivateCreator)
            return null;

        var creatorKey = tag.PrivateCreatorKey;
        if (creatorKey == 0)
            return null;

        return _creators.TryGetValue(creatorKey, out var creator) ? creator : null;
    }

    /// <summary>
    /// Check if a creator is registered for the given private data element.
    /// </summary>
    public bool HasCreator(DicomTag tag)
        => GetCreator(tag) != null;

    /// <summary>
    /// Clear all registered creators.
    /// </summary>
    public void Clear() => _creators.Clear();

    /// <summary>
    /// Get all registered creators.
    /// </summary>
    public IEnumerable<(DicomTag Tag, string Creator)> GetAll()
        => _creators.Select(kvp => (new DicomTag(kvp.Key), kvp.Value));
}
```

Private tag structure reminder:
- (gggg,00xx) - Private creator element, where xx is the slot (0x10-0xFF)
- (gggg,xxyy) - Private data element, where xx matches a creator slot
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release
  </verify>
  <done>
    PrivateCreatorDictionary tracks private tag creators correctly
  </done>
</task>

<task type="auto">
  <name>Task 3: Write integration tests with generated code</name>
  <files>
    tests/SharpDicom.Tests/Data/DicomDatasetTests.cs
    tests/SharpDicom.Tests/Data/DicomDictionaryTests.cs
  </files>
  <action>
Write tests that verify the full integration including generated code:

**DicomDatasetTests.cs**:

Basic operations:
- Add element and retrieve by tag
- Contains returns true for existing tag
- Contains returns false for missing tag
- Remove element
- Clear removes all elements
- Count reflects element count

Typed accessors:
- GetString returns value for string element
- GetInt32 returns value for numeric element
- GetInt32 returns value for IS string element
- GetDate parses DA element
- GetUID returns DicomUID
- GetSequence returns sequence
- Missing tag returns null

Enumeration:
- Enumeration returns elements in tag order
- Adding element invalidates cache
- Removing element invalidates cache

Integration with generated tags:
```csharp
[Test]
public void CanUseGeneratedTags()
{
    var dataset = new DicomDataset();

    // Use generated static tag members
    dataset.Add(new DicomStringElement(DicomTag.PatientId, DicomVR.LO,
        Encoding.ASCII.GetBytes("12345678")));

    Assert.That(dataset.GetString(DicomTag.PatientId), Is.EqualTo("12345678"));
}

[Test]
public void CanLookupTagInDictionary()
{
    var entry = DicomDictionary.Default.GetEntry(DicomTag.PatientId);
    Assert.That(entry, Is.Not.Null);
    Assert.That(entry!.Value.Keyword, Is.EqualTo("PatientId"));
    Assert.That(entry.Value.DefaultVR, Is.EqualTo(DicomVR.LO));
}
```

**DicomDictionaryTests.cs**:
- Dictionary contains PatientId tag
- Dictionary contains common UIDs
- GetEntry returns correct metadata
- GetEntryByKeyword works
- Unknown tag returns null
- Multi-VR tag has multiple VRs
- Retired tags are marked
- FrozenDictionary used on .NET 8+ (conditional)

Private creator tests:
- Register and retrieve creator
- GetCreator for private data element
- HasCreator returns correct value
- Clear removes all creators

Deep copy:
- ToOwned creates independent dataset
- Modifying copy doesn't affect original
- Nested sequences are deep copied
  </action>
  <verify>
    dotnet test tests/SharpDicom.Tests --configuration Release --verbosity normal
  </verify>
  <done>
    All tests pass including integration with generated dictionary code
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Full solution builds without warnings:
   ```bash
   dotnet build SharpDicom.sln --configuration Release
   ```

2. All tests pass:
   ```bash
   dotnet test tests/SharpDicom.Tests --configuration Release
   ```

3. Generated tags are accessible:
   ```csharp
   // This should compile and work
   var tag = DicomTag.PatientId;
   var entry = DicomDictionary.Default.GetEntry(tag);
   ```

4. Dictionary contains expected number of entries (~4000 tags)
</verification>

<success_criteria>
- DicomDataset provides O(1) lookup and sorted enumeration
- PrivateCreatorDictionary tracks private tag creators
- Generated DicomTag static members are usable in tests
- DicomDictionary.Default provides lookup access
- All unit and integration tests pass
- Solution builds without warnings on all TFMs
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-data-model-dictionary/01-06-SUMMARY.md`
</output>
