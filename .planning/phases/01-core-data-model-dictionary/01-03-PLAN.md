---
phase: 01-core-data-model-dictionary
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/SharpDicom/Data/DicomUID.cs
  - src/SharpDicom/Data/TransferSyntax.cs
  - src/SharpDicom/Data/DicomDictionaryEntry.cs
  - src/SharpDicom/Data/DicomDictionary.cs
  - tests/SharpDicom.Tests/Data/DicomUIDTests.cs
  - tests/SharpDicom.Tests/Data/TransferSyntaxTests.cs
autonomous: true

must_haves:
  truths:
    - "DicomUID can store UIDs up to 64 characters with zero allocation"
    - "TransferSyntax provides encoding properties (IsExplicitVR, IsLittleEndian)"
    - "DicomDictionaryEntry holds tag metadata including multi-VR support"
    - "Unit tests pass for DicomUID and TransferSyntax"
  artifacts:
    - path: "src/SharpDicom/Data/DicomUID.cs"
      provides: "DicomUID readonly struct with inline 64-byte storage"
      min_lines: 80
    - path: "src/SharpDicom/Data/TransferSyntax.cs"
      provides: "TransferSyntax readonly struct"
      min_lines: 60
    - path: "src/SharpDicom/Data/DicomDictionaryEntry.cs"
      provides: "DicomDictionaryEntry for dictionary lookups"
      min_lines: 30
    - path: "tests/SharpDicom.Tests/Data/DicomUIDTests.cs"
      provides: "DicomUID unit tests"
      min_lines: 50
  key_links:
    - from: "src/SharpDicom/Data/TransferSyntax.cs"
      to: "src/SharpDicom/Data/DicomUID.cs"
      via: "UID property"
      pattern: "DicomUID.*UID"
---

<objective>
Implement DicomUID (with inline storage), TransferSyntax, and DicomDictionaryEntry types that build on the primitive types from Plan 01.

Purpose: Complete the secondary data model types needed before the source generator can emit dictionary code.

Output:
- DicomUID readonly struct with zero-allocation inline storage (64 bytes)
- TransferSyntax readonly struct with encoding properties
- DicomDictionaryEntry for dictionary metadata
- DicomDictionary class for runtime lookups
- Unit tests for new types
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-core-data-model-dictionary/01-CONTEXT.md
@.planning/phases/01-core-data-model-dictionary/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DicomUID with inline storage</name>
  <files>
    src/SharpDicom/Data/DicomUID.cs
    tests/SharpDicom.Tests/Data/DicomUIDTests.cs
  </files>
  <action>
Implement DicomUID following CLAUDE.md design:

**DicomUID** (src/SharpDicom/Data/DicomUID.cs):
- readonly struct (NOT record struct - custom layout needed)
- StructLayout(LayoutKind.Sequential) for predictable memory layout
- 64 bytes inline storage using 8 long fields (_p0 through _p7)
- byte _length field for actual length
- Total size: 65 bytes (will likely be padded to 72)

Constructor:
- DicomUID(string value): validates length <= 64, copies ASCII bytes inline
- DicomUID(ReadOnlySpan<byte> bytes): direct byte copy

Properties:
- Length: returns _length
- AsSpan(): returns ReadOnlySpan<byte> of the stored UID bytes
- IsEmpty: _length == 0

Methods:
- ToString(): Encoding.ASCII.GetString(AsSpan())
- Equals(DicomUID other): length match + span SequenceEqual
- GetHashCode(): Use HashCode.AddBytes on span
- IsValid: static method to validate UID format (0-9 and . only, component rules)

Static factory methods:
- Generate(): Creates UUID-based UID using 2.25.{uuid-as-decimal} format
- Generate(string root): Creates root.timestamp.random format
- GenerateFromName(string root, string name): Hash-based deterministic UID

IEquatable<DicomUID> implementation for type-safe equality.

Mark struct as partial (generator will add static UID members later).

Include XML documentation for all public members.

**DicomUIDTests.cs**:
- Construction from string
- Construction from bytes
- Length property correct
- AsSpan returns correct bytes
- ToString roundtrip
- Equality for same UID
- Inequality for different UIDs
- GetHashCode consistency
- Reject UID > 64 characters
- IsValid for valid UIDs
- IsValid false for invalid UIDs (special chars, leading zeros in components)
- Generate produces valid UIDs
- GenerateFromName is deterministic
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release && dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~DicomUIDTests" --configuration Release
  </verify>
  <done>
    DicomUID stores UIDs inline with zero allocation, all tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement TransferSyntax and DicomDictionaryEntry</name>
  <files>
    src/SharpDicom/Data/TransferSyntax.cs
    src/SharpDicom/Data/CompressionType.cs
    src/SharpDicom/Data/DicomDictionaryEntry.cs
    src/SharpDicom/Data/DicomDictionary.cs
    tests/SharpDicom.Tests/Data/TransferSyntaxTests.cs
  </files>
  <action>
Implement transfer syntax and dictionary entry types:

**CompressionType.cs** (src/SharpDicom/Data/):
Enum for compression types:
```csharp
public enum CompressionType
{
    None,
    JPEGBaseline,
    JPEGExtended,
    JPEGLossless,
    JPEG2000Lossless,
    JPEG2000Lossy,
    JPEGLSLossless,
    JPEGLSNearLossless,
    RLE
}
```

**TransferSyntax** (src/SharpDicom/Data/TransferSyntax.cs):
- readonly record struct
- Properties:
  - UID: DicomUID
  - IsExplicitVR: bool
  - IsLittleEndian: bool
  - IsEncapsulated: bool (compressed pixel data)
  - IsLossy: bool
  - Compression: CompressionType
  - IsKnown: bool (false for unrecognized UIDs)

Static well-known instances (hardcoded for now, generator will augment):
- ImplicitVRLittleEndian (1.2.840.10008.1.2)
- ExplicitVRLittleEndian (1.2.840.10008.1.2.1)
- ExplicitVRBigEndian (1.2.840.10008.1.2.2) [retired]
- JPEGBaseline (1.2.840.10008.1.2.4.50)
- JPEG2000Lossless (1.2.840.10008.1.2.4.90)
- RLELossless (1.2.840.10008.1.2.5)

Static FromUID(DicomUID uid) method that returns matching TransferSyntax or unknown.

Mark as partial (generator adds more instances).

**DicomDictionaryEntry** (src/SharpDicom/Data/DicomDictionaryEntry.cs):
- readonly record struct
- Properties:
  - Tag: DicomTag
  - Keyword: string
  - Name: string
  - ValueRepresentations: DicomVR[] (array for multi-VR tags)
  - VM: ValueMultiplicity
  - IsRetired: bool
- Computed properties:
  - DefaultVR: ValueRepresentations[0]
  - HasMultipleVRs: ValueRepresentations.Length > 1

**DicomDictionary** (src/SharpDicom/Data/DicomDictionary.cs):
- Class (not struct) for runtime dictionary
- Static Default property returning singleton instance
- GetEntry(DicomTag tag): DicomDictionaryEntry?
- GetEntryByKeyword(string keyword): DicomDictionaryEntry?
- Contains(DicomTag tag): bool
- Internal dictionary storage (will be populated by generated code)
- Mark as partial for generator augmentation

**TransferSyntaxTests.cs**:
- Well-known instances have correct properties
- ImplicitVRLittleEndian: IsExplicitVR=false, IsLittleEndian=true
- ExplicitVRLittleEndian: IsExplicitVR=true, IsLittleEndian=true
- JPEGBaseline: IsEncapsulated=true, IsLossy=true
- JPEG2000Lossless: IsEncapsulated=true, IsLossy=false
- FromUID returns correct TransferSyntax
- Unknown UID returns IsKnown=false
  </action>
  <verify>
    dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release && dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~TransferSyntaxTests" --configuration Release
  </verify>
  <done>
    TransferSyntax and DicomDictionaryEntry compile, tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. New types exist:
   ```
   src/SharpDicom/Data/
   ├── DicomUID.cs
   ├── TransferSyntax.cs
   ├── CompressionType.cs
   ├── DicomDictionaryEntry.cs
   └── DicomDictionary.cs
   ```

2. Solution builds:
   ```bash
   dotnet build SharpDicom.sln --configuration Release
   ```

3. All tests pass:
   ```bash
   dotnet test tests/SharpDicom.Tests --configuration Release
   ```

4. DicomUID inline storage works correctly (no heap allocation for < 64 char UIDs)
</verification>

<success_criteria>
- DicomUID stores UIDs inline with zero allocation
- TransferSyntax provides correct encoding properties for well-known syntaxes
- DicomDictionaryEntry supports multi-VR tags
- DicomDictionary is ready for generated population
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-data-model-dictionary/01-03-SUMMARY.md`
</output>
