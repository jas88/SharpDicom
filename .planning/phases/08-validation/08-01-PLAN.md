---
phase: 08-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SharpDicom/Validation/ValidationSeverity.cs
  - src/SharpDicom/Validation/ValidationCodes.cs
  - src/SharpDicom/Validation/ValidationIssue.cs
  - src/SharpDicom/Validation/ValidationResult.cs
  - src/SharpDicom/Validation/ElementValidationContext.cs
  - src/SharpDicom/Validation/IValidationRule.cs
  - tests/SharpDicom.Tests/Validation/ValidationIssueTests.cs
  - tests/SharpDicom.Tests/Validation/ValidationResultTests.cs
autonomous: true

must_haves:
  truths:
    - "ValidationIssue captures full diagnostic context (tag, VR, position, message, code)"
    - "ValidationResult aggregates issues with severity filtering"
    - "IValidationRule interface enables pluggable validation logic"
    - "ValidationCodes provides unique identifiers for each issue type"
  artifacts:
    - path: "src/SharpDicom/Validation/ValidationIssue.cs"
      provides: "Immutable issue record with all diagnostic information"
      exports: ["ValidationIssue"]
    - path: "src/SharpDicom/Validation/ValidationResult.cs"
      provides: "Collection of validation issues with filtering"
      exports: ["ValidationResult"]
    - path: "src/SharpDicom/Validation/IValidationRule.cs"
      provides: "Interface for pluggable validation rules"
      exports: ["IValidationRule"]
    - path: "tests/SharpDicom.Tests/Validation/ValidationResultTests.cs"
      provides: "Verification that issue collection and filtering works"
      min_lines: 50
  key_links:
    - from: "ValidationResult"
      to: "ValidationIssue"
      via: "Issues collection"
      pattern: "IReadOnlyList<ValidationIssue>"
    - from: "IValidationRule"
      to: "ElementValidationContext"
      via: "Validate method parameter"
      pattern: "Validate.*in ElementValidationContext"
---

<objective>
Create the core validation infrastructure: ValidationIssue record, ValidationResult collection, IValidationRule interface, and supporting types.

Purpose: Establish the foundation for all validation functionality. These types are referenced by all subsequent validation plans and by DicomReaderOptions integration.

Output: Validation folder with core types and comprehensive unit tests.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-validation/08-CONTEXT.md
@.planning/phases/08-validation/08-RESEARCH.md

# Key existing files
@src/SharpDicom/Data/DicomTag.cs
@src/SharpDicom/Data/DicomVR.cs
@src/SharpDicom/Data/DicomEncoding.cs
@src/SharpDicom/Data/Exceptions/DicomDataException.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation core types</name>
  <files>
    src/SharpDicom/Validation/ValidationSeverity.cs
    src/SharpDicom/Validation/ValidationCodes.cs
    src/SharpDicom/Validation/ValidationIssue.cs
    src/SharpDicom/Validation/ElementValidationContext.cs
    src/SharpDicom/Validation/IValidationRule.cs
  </files>
  <action>
Create Validation folder under src/SharpDicom/. Create the following types:

**ValidationSeverity.cs:**
```csharp
namespace SharpDicom.Validation;

/// <summary>
/// Severity level for validation issues.
/// </summary>
public enum ValidationSeverity
{
    /// <summary>Informational only (cosmetic issues like trailing spaces).</summary>
    Info = 0,

    /// <summary>Recoverable issue (VR mismatch, format issues).</summary>
    Warning = 1,

    /// <summary>Fatal issue (structural corruption, cannot proceed).</summary>
    Error = 2
}
```

**ValidationCodes.cs:**
Static class with string constants for all validation codes from RESEARCH.md (DICOM-001 through DICOM-025). Group by category with XML comments. Each code should have format "DICOM-NNN" where NNN is zero-padded.

**ValidationIssue.cs:**
```csharp
public readonly record struct ValidationIssue(
    string Code,                    // DICOM-001, DICOM-002, etc.
    ValidationSeverity Severity,
    DicomTag? Tag,
    DicomVR? DeclaredVR,
    DicomVR? ExpectedVR,
    long? Position,
    string Message,
    string? SuggestedFix,
    ReadOnlyMemory<byte> RawValue)
{
    // Static factory methods for common cases
    public static ValidationIssue Error(string code, DicomTag tag, string message, string? suggestedFix = null);
    public static ValidationIssue Warning(string code, DicomTag tag, string message, string? suggestedFix = null);
    public static ValidationIssue Info(string code, DicomTag tag, string message, string? suggestedFix = null);

    // Full factory with all context
    public static ValidationIssue Create(
        string code, ValidationSeverity severity, DicomTag? tag,
        DicomVR? declaredVR, DicomVR? expectedVR, long? position,
        string message, string? suggestedFix, ReadOnlyMemory<byte> rawValue);
}
```

**ElementValidationContext.cs:**
```csharp
public readonly struct ElementValidationContext
{
    public DicomTag Tag { get; init; }
    public DicomVR DeclaredVR { get; init; }
    public DicomVR? ExpectedVR { get; init; }  // From dictionary
    public ReadOnlyMemory<byte> RawValue { get; init; }
    public DicomDataset Dataset { get; init; }  // For conditional checks
    public DicomEncoding Encoding { get; init; }
    public long StreamPosition { get; init; }
    public bool IsPrivate { get; init; }
    public string? PrivateCreator { get; init; }
}
```

**IValidationRule.cs:**
```csharp
public interface IValidationRule
{
    /// <summary>Unique identifier for this rule.</summary>
    string RuleId { get; }

    /// <summary>Human-readable description of what this rule checks.</summary>
    string Description { get; }

    /// <summary>Validates an element in context.</summary>
    /// <returns>Issue if validation fails; null if valid.</returns>
    ValidationIssue? Validate(in ElementValidationContext context);
}
```

Ensure all types are in `namespace SharpDicom.Validation;` and have XML documentation comments.
  </action>
  <verify>
    - `dotnet build src/SharpDicom/SharpDicom.csproj` succeeds
    - All types exist in SharpDicom.Validation namespace
  </verify>
  <done>
    - ValidationSeverity enum with Info/Warning/Error levels
    - ValidationCodes static class with 25 code constants
    - ValidationIssue readonly record struct with factory methods
    - ElementValidationContext readonly struct with all context properties
    - IValidationRule interface with RuleId, Description, Validate
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ValidationResult and unit tests</name>
  <files>
    src/SharpDicom/Validation/ValidationResult.cs
    tests/SharpDicom.Tests/Validation/ValidationIssueTests.cs
    tests/SharpDicom.Tests/Validation/ValidationResultTests.cs
  </files>
  <action>
**ValidationResult.cs:**
```csharp
public sealed class ValidationResult
{
    private readonly List<ValidationIssue> _issues = new();

    /// <summary>True if no Error-level issues.</summary>
    public bool IsValid => !_issues.Any(i => i.Severity == ValidationSeverity.Error);

    /// <summary>True if any Warning-level issues.</summary>
    public bool HasWarnings => _issues.Any(i => i.Severity == ValidationSeverity.Warning);

    /// <summary>All collected issues.</summary>
    public IReadOnlyList<ValidationIssue> Issues => _issues;

    /// <summary>Error-level issues only.</summary>
    public IEnumerable<ValidationIssue> Errors =>
        _issues.Where(i => i.Severity == ValidationSeverity.Error);

    /// <summary>Warning-level issues only.</summary>
    public IEnumerable<ValidationIssue> Warnings =>
        _issues.Where(i => i.Severity == ValidationSeverity.Warning);

    /// <summary>Info-level issues only.</summary>
    public IEnumerable<ValidationIssue> Infos =>
        _issues.Where(i => i.Severity == ValidationSeverity.Info);

    /// <summary>Add an issue to the result.</summary>
    public void Add(ValidationIssue issue) => _issues.Add(issue);

    /// <summary>Add multiple issues to the result.</summary>
    public void AddRange(IEnumerable<ValidationIssue> issues) => _issues.AddRange(issues);

    /// <summary>Clear all issues.</summary>
    public void Clear() => _issues.Clear();

    /// <summary>Total count of issues at all severity levels.</summary>
    public int Count => _issues.Count;
}
```

**ValidationIssueTests.cs:**
Test factory methods, property initialization, default values, RawValue handling (empty vs populated).

**ValidationResultTests.cs:**
Test:
- IsValid when empty (true)
- IsValid with only Info/Warning (true)
- IsValid with Error (false)
- HasWarnings behavior
- Errors/Warnings/Infos filtering
- Add/AddRange/Clear/Count
- Multiple issues at different severity levels
  </action>
  <verify>
    - `dotnet build` succeeds
    - `dotnet test --filter "FullyQualifiedName~Validation"` passes
  </verify>
  <done>
    - ValidationResult class with issue aggregation and filtering
    - ValidationIssueTests covering factory methods and properties
    - ValidationResultTests covering all filtering and state
    - All tests pass
  </done>
</task>

</tasks>

<verification>
- `dotnet build` succeeds with no warnings
- `dotnet test` passes all existing tests (529+) plus new validation tests
- ValidationIssue can be created with all context fields
- ValidationResult correctly identifies valid vs invalid state
- IValidationRule interface compiles and can be implemented
</verification>

<success_criteria>
- Validation folder exists with 6 source files
- ValidationSeverity enum has 3 values (Info, Warning, Error)
- ValidationCodes has 25 string constants (DICOM-001 to DICOM-025)
- ValidationIssue is a readonly record struct with 9 properties and 4 factory methods
- ElementValidationContext is a readonly struct with 9 properties
- IValidationRule interface has 2 properties and 1 method
- ValidationResult class has 10 public members
- At least 15 unit tests for validation types
- All tests pass on all target frameworks
</success_criteria>

<output>
After completion, create `.planning/phases/08-validation/08-01-SUMMARY.md`
</output>
