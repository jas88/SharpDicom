---
phase: 11-dimse-services
plan: 06
type: execute
wave: 3
depends_on: ["11-03", "11-04"]
files_modified:
  - src/SharpDicom/Network/Dimse/Services/CGetScu.cs
  - src/SharpDicom/Network/Dimse/Services/CGetOptions.cs
  - src/SharpDicom/Network/Dimse/Services/CGetProgress.cs
  - src/SharpDicom/Network/Items/PresentationContext.cs
  - tests/SharpDicom.Tests/Network/Dimse/CGetScuTests.cs
autonomous: true

must_haves:
  truths:
    - "CGetScu can retrieve data directly on same association via C-STORE sub-ops"
    - "SCU role selection enabled for Storage SOP Classes during association"
    - "Handler invoked for each incoming C-STORE sub-operation"
    - "Progress yields SubOperationProgress with cumulative counts"
  artifacts:
    - path: "src/SharpDicom/Network/Dimse/Services/CGetScu.cs"
      provides: "C-GET SCU service class"
      contains: "class CGetScu"
    - path: "src/SharpDicom/Network/Dimse/Services/CGetProgress.cs"
      provides: "C-GET progress tracking"
      contains: "class CGetProgress"
  key_links:
    - from: "CGetScu"
      to: "C-STORE sub-operation handler"
      via: "storeHandler delegate"
      pattern: "storeHandler|OnCStore"
    - from: "CGetScu.GetAsync"
      to: "IAsyncEnumerable<CGetProgress>"
      via: "yield return"
      pattern: "IAsyncEnumerable<CGetProgress>"
---

<objective>
Implement C-GET SCU service for direct retrieval via C-STORE sub-operations on the same association.

Purpose: Enable SharpDicom to retrieve DICOM data directly without requiring a separate storage SCP. The SCP sends instances back via C-STORE sub-operations on the same association, and the SCU handles them inline.

Output: CGetScu class with GetAsync method that handles interleaved C-STORE sub-operations and C-GET responses, plus SCP role selection support for presentation contexts.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-dimse-services/11-CONTEXT.md
@.planning/phases/11-dimse-services/11-RESEARCH.md
@src/SharpDicom/Network/Items/PresentationContext.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CGetOptions and CGetProgress types</name>
  <files>
    src/SharpDicom/Network/Dimse/Services/CGetOptions.cs
    src/SharpDicom/Network/Dimse/Services/CGetProgress.cs
  </files>
  <action>
Create CGetOptions.cs:
```csharp
namespace SharpDicom.Network.Dimse.Services
{
    /// <summary>
    /// Options for C-GET SCU operations.
    /// </summary>
    public sealed class CGetOptions
    {
        /// <summary>Default C-GET options.</summary>
        public static CGetOptions Default { get; } = new();

        /// <summary>
        /// Gets or sets the operation timeout. Default is 120 seconds.
        /// </summary>
        public TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(120);

        /// <summary>
        /// Gets or sets the priority for the get operation. Default is MEDIUM (0).
        /// </summary>
        public ushort Priority { get; set; } = 0;

        /// <summary>
        /// Gets or sets whether to use Patient Root information model.
        /// When false, Study Root is used. Default is true.
        /// </summary>
        public bool UsePatientRoot { get; set; } = true;

        /// <summary>
        /// Gets or sets the cancellation behavior when CancellationToken is triggered.
        /// </summary>
        public CGetCancellationBehavior CancellationBehavior { get; set; } = CGetCancellationBehavior.RejectInFlight;
    }

    /// <summary>
    /// Specifies behavior when C-GET is cancelled.
    /// </summary>
    public enum CGetCancellationBehavior
    {
        /// <summary>
        /// Send C-CANCEL and reject incoming C-STORE sub-operations.
        /// Some data may be lost.
        /// </summary>
        RejectInFlight,

        /// <summary>
        /// Send C-CANCEL but accept already-started C-STORE sub-operations.
        /// Preserves data integrity for in-flight transfers.
        /// </summary>
        CompleteInFlight
    }
}
```

Create CGetProgress.cs:
```csharp
namespace SharpDicom.Network.Dimse.Services
{
    /// <summary>
    /// Progress update from a C-GET operation.
    /// </summary>
    public sealed class CGetProgress
    {
        public CGetProgress(SubOperationProgress subOperations, DicomStatus status, DicomDataset? receivedDataset = null)
        {
            SubOperations = subOperations;
            Status = status;
            ReceivedDataset = receivedDataset;
        }

        /// <summary>Gets the sub-operation progress counts.</summary>
        public SubOperationProgress SubOperations { get; }

        /// <summary>Gets the DIMSE status from this response.</summary>
        public DicomStatus Status { get; }

        /// <summary>
        /// Gets the dataset received in the most recent C-STORE sub-operation, if any.
        /// </summary>
        /// <remarks>
        /// Only populated when yielding after a C-STORE sub-operation completes.
        /// Null when yielding C-GET-RSP progress without associated dataset.
        /// </remarks>
        public DicomDataset? ReceivedDataset { get; }

        /// <summary>Gets whether this is the final C-GET response.</summary>
        public bool IsFinal => SubOperations.IsFinal || !Status.IsPending;

        /// <summary>Gets whether the overall operation completed successfully.</summary>
        public bool IsSuccess => IsFinal && Status.IsSuccess && !SubOperations.HasErrors;

        /// <summary>Gets whether a new dataset was received with this progress update.</summary>
        public bool HasReceivedDataset => ReceivedDataset != null;
    }
}
```
  </action>
  <verify>
`dotnet build src/SharpDicom/SharpDicom.csproj` compiles without errors
  </verify>
  <done>
CGetOptions with timeout, priority, and cancellation behavior. CGetProgress with sub-operation tracking and optional received dataset.
  </done>
</task>

<task type="auto">
  <name>Task 2: PresentationContext SCP role selection</name>
  <files>
    src/SharpDicom/Network/Items/PresentationContext.cs
  </files>
  <action>
Extend PresentationContext for SCP Role Selection per PS3.8:

Add to PresentationContext.cs:

```csharp
/// <summary>
/// Gets or sets whether SCU role is proposed/accepted for this context.
/// </summary>
/// <remarks>
/// Default is true (SCU). Set to true to request SCU role during negotiation.
/// </remarks>
public bool ScuRoleRequested { get; set; } = true;

/// <summary>
/// Gets or sets whether SCP role is proposed/accepted for this context.
/// </summary>
/// <remarks>
/// Default is false. Set to true to request SCP role during negotiation.
/// Required for C-GET to receive C-STORE sub-operations.
/// </remarks>
public bool ScpRoleRequested { get; set; } = false;

/// <summary>
/// Configures this presentation context to accept SCP role.
/// </summary>
/// <returns>This instance for fluent chaining.</returns>
/// <remarks>
/// Call this for Storage SOP Classes when using C-GET to enable
/// receiving C-STORE sub-operations on the same association.
/// </remarks>
public PresentationContext WithScpRole()
{
    ScpRoleRequested = true;
    return this;
}

/// <summary>
/// Configures this presentation context to accept both SCU and SCP roles.
/// </summary>
/// <returns>This instance for fluent chaining.</returns>
public PresentationContext WithBothRoles()
{
    ScuRoleRequested = true;
    ScpRoleRequested = true;
    return this;
}
```

Note: The A-ASSOCIATE-RQ/AC PDU building (in PduWriter) will need to include
SCP/SCU Role Selection Sub-Item (type 0x54) when ScpRoleRequested is true.
This may require updates to PduWriter in the integration task (11-07).
  </action>
  <verify>
`dotnet build src/SharpDicom/SharpDicom.csproj` compiles without errors
  </verify>
  <done>
PresentationContext supports SCP role selection for C-GET sub-operations.
  </done>
</task>

<task type="auto">
  <name>Task 3: CGetScu service class</name>
  <files>
    src/SharpDicom/Network/Dimse/Services/CGetScu.cs
  </files>
  <action>
Create CGetScu.cs implementing C-GET SCU per 11-RESEARCH.md:

```csharp
using System.Runtime.CompilerServices;

namespace SharpDicom.Network.Dimse.Services
{
    /// <summary>
    /// C-GET Service Class User (SCU) for direct retrieval via C-STORE sub-operations.
    /// </summary>
    /// <remarks>
    /// <para>
    /// Unlike C-MOVE, C-GET receives data directly on the same association via
    /// C-STORE sub-operations. The SCU must accept SCP role for Storage SOP Classes.
    /// </para>
    /// <para>
    /// Association negotiation must include Storage SOP Classes with SCP Role Selection
    /// (using PresentationContext.WithScpRole()) for C-GET to work.
    /// </para>
    /// </remarks>
    public sealed class CGetScu
    {
        private readonly DicomClient _client;
        private readonly CGetOptions _options;
        private readonly Func<DicomDataset, DicomDataset?, CancellationToken, ValueTask<DicomStatus>> _storeHandler;
        private int _messageIdCounter;

        /// <summary>
        /// Initializes a new instance of the <see cref="CGetScu"/> class.
        /// </summary>
        /// <param name="client">Connected DicomClient with Storage SOP Classes in SCP role.</param>
        /// <param name="storeHandler">
        /// Handler invoked for each received C-STORE sub-operation.
        /// Parameters: (command dataset, data dataset, cancellation token)
        /// Returns: Status to send in C-STORE-RSP.
        /// </param>
        /// <param name="options">Optional get options.</param>
        public CGetScu(
            DicomClient client,
            Func<DicomDataset, DicomDataset?, CancellationToken, ValueTask<DicomStatus>> storeHandler,
            CGetOptions? options = null)
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
            _storeHandler = storeHandler ?? throw new ArgumentNullException(nameof(storeHandler));
            _options = options ?? CGetOptions.Default;
        }

        /// <summary>
        /// Initiates a C-GET operation to retrieve instances directly.
        /// </summary>
        /// <param name="level">Query/Retrieve level.</param>
        /// <param name="identifier">Keys identifying instances to retrieve.</param>
        /// <param name="ct">Cancellation token.</param>
        /// <returns>Async enumerable of progress updates.</returns>
        /// <remarks>
        /// <para>
        /// The message loop handles interleaved C-STORE-RQ (sub-operations) and
        /// C-GET-RSP (progress/completion) messages.
        /// </para>
        /// <para>
        /// Each C-STORE sub-operation invokes the storeHandler and sends C-STORE-RSP.
        /// The storeHandler should save the received data and return success status.
        /// </para>
        /// </remarks>
        public async IAsyncEnumerable<CGetProgress> GetAsync(
            QueryRetrieveLevel level,
            DicomDataset identifier,
            [EnumeratorCancellation] CancellationToken ct = default)
        {
            var messageId = NextMessageId();
            var sopClassUid = GetSopClassUid(level);

            // Send C-GET-RQ
            var request = DicomCommand.CreateCGetRequest(messageId, sopClassUid, _options.Priority);
            await SendCGetRequestAsync(request, identifier, ct).ConfigureAwait(false);

            bool cancelled = false;

            // Message loop: handle interleaved C-STORE-RQ and C-GET-RSP
            while (true)
            {
                // Check for cancellation
                if (ct.IsCancellationRequested && !cancelled)
                {
                    await SendCCancelAsync(messageId, ct).ConfigureAwait(false);
                    cancelled = true;

                    if (_options.CancellationBehavior == CGetCancellationBehavior.RejectInFlight)
                    {
                        throw new OperationCanceledException(ct);
                    }
                    // CompleteInFlight: continue processing until final response
                }

                var (command, dataset) = await ReceiveMessageAsync(ct).ConfigureAwait(false);

                if (command.IsCStoreRequest)
                {
                    // Incoming C-STORE sub-operation
                    DicomStatus storeStatus;

                    if (cancelled && _options.CancellationBehavior == CGetCancellationBehavior.RejectInFlight)
                    {
                        // Reject with cancel status
                        storeStatus = new DicomStatus(0xFE00); // Cancel
                    }
                    else
                    {
                        // Delegate to handler
                        storeStatus = await _storeHandler(command.Dataset, dataset, ct).ConfigureAwait(false);

                        // Yield progress with received dataset
                        yield return new CGetProgress(
                            new SubOperationProgress(0, 0, 0, 0), // Will be updated in next C-GET-RSP
                            DicomStatus.Pending,
                            dataset);
                    }

                    // Send C-STORE-RSP
                    await SendCStoreResponseAsync(
                        command.MessageID,
                        command.AffectedSOPClassUID,
                        command.AffectedSOPInstanceUID,
                        storeStatus,
                        ct).ConfigureAwait(false);
                }
                else if (command.IsCGetResponse)
                {
                    // C-GET-RSP with progress
                    var progress = new CGetProgress(
                        command.GetSubOperationProgress(),
                        command.Status);

                    yield return progress;

                    if (!command.Status.IsPending)
                    {
                        // Final response
                        if (cancelled)
                            throw new OperationCanceledException(ct);
                        yield break;
                    }
                }
                else
                {
                    throw new DicomNetworkException($"Unexpected command: 0x{command.CommandFieldValue:X4}");
                }
            }
        }

        /// <summary>
        /// Initiates a C-GET operation using a fluent DicomQuery.
        /// </summary>
        public IAsyncEnumerable<CGetProgress> GetAsync(
            DicomQuery query,
            CancellationToken ct = default)
        {
            return GetAsync(query.Level, query.ToDataset(), ct);
        }

        private DicomUID GetSopClassUid(QueryRetrieveLevel level)
        {
            return _options.UsePatientRoot
                ? level.GetPatientRootGetSopClassUid()
                : level.GetStudyRootGetSopClassUid();
        }

        private ushort NextMessageId() => (ushort)Interlocked.Increment(ref _messageIdCounter);

        // Private helper methods for network I/O...
    }
}
```

Key implementation notes from 11-RESEARCH.md:
1. Association MUST include Storage SOP Classes with SCP Role Selection
2. Message loop handles BOTH C-STORE-RQ and C-GET-RSP
3. For each C-STORE-RQ: invoke handler, send C-STORE-RSP
4. Sub-operation counts come from C-GET-RSP, not C-STORE-RSP
5. CancellationBehavior controls whether in-flight stores complete
  </action>
  <verify>
`dotnet build src/SharpDicom/SharpDicom.csproj` compiles without errors
  </verify>
  <done>
CGetScu class with GetAsync handling interleaved C-STORE sub-operations.
  </done>
</task>

<task type="auto">
  <name>Task 4: Unit tests for CGetScu</name>
  <files>
    tests/SharpDicom.Tests/Network/Dimse/CGetScuTests.cs
  </files>
  <action>
Create CGetScuTests.cs with tests:

CGetOptions tests:
- Default timeout is 120 seconds
- Default priority is MEDIUM (0)
- Default uses Patient Root
- Default CancellationBehavior is RejectInFlight

CGetCancellationBehavior tests:
- Both enum values exist

CGetProgress tests:
- IsFinal true when Remaining=0
- IsFinal true when status not Pending
- IsSuccess true when IsFinal, Success status, no failures
- HasReceivedDataset true when dataset provided
- ReceivedDataset accessible

PresentationContext SCP role tests:
- ScpRoleRequested default is false
- WithScpRole sets ScpRoleRequested to true
- WithBothRoles sets both roles to true
- WithScpRole returns same instance (fluent)

CGetScu constructor tests:
- Null client throws ArgumentNullException
- Null storeHandler throws ArgumentNullException
- Default options used when null
- Custom options stored correctly

Command creation tests:
- C-GET-RQ includes correct SOP Class UID for Patient Root
- C-GET-RQ includes correct SOP Class UID for Study Root
- Message IDs increment

Note: Full network integration tests in Plan 11-07.
  </action>
  <verify>
`dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "CGetScuTests"` - all tests pass
  </verify>
  <done>
Unit tests verify CGetProgress properties, PresentationContext SCP role, and options defaults.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release` - builds without errors or warnings
2. `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "CGetScuTests"` - all new tests pass
3. `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj` - full test suite passes
</verification>

<success_criteria>
- CGetScu class with GetAsync returning IAsyncEnumerable<CGetProgress>
- PresentationContext supports WithScpRole() for SCP role selection
- CGetProgress includes optional ReceivedDataset from C-STORE sub-ops
- Interleaved message handling for C-STORE-RQ and C-GET-RSP
- CancellationBehavior option controls in-flight handling
- Unit tests verify role selection and progress tracking
</success_criteria>

<output>
After completion, create `.planning/phases/11-dimse-services/11-06-SUMMARY.md`
</output>
