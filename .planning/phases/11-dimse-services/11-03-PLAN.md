---
phase: 11-dimse-services
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - src/SharpDicom/Network/Dimse/Services/CFindScu.cs
  - src/SharpDicom/Network/Dimse/Services/CFindOptions.cs
  - src/SharpDicom/Network/Dimse/Services/DicomQuery.cs
  - tests/SharpDicom.Tests/Network/Dimse/CFindScuTests.cs
autonomous: true

must_haves:
  truths:
    - "CFindScu can query remote PACS for studies, series, and instances"
    - "CFindScu returns results via IAsyncEnumerable<DicomDataset>"
    - "DicomQuery provides fluent builder for common query parameters"
    - "Cancellation sends C-CANCEL and throws OperationCanceledException"
  artifacts:
    - path: "src/SharpDicom/Network/Dimse/Services/CFindScu.cs"
      provides: "C-FIND SCU service class"
      contains: "class CFindScu"
    - path: "src/SharpDicom/Network/Dimse/Services/DicomQuery.cs"
      provides: "Fluent query builder"
      contains: "class DicomQuery"
  key_links:
    - from: "CFindScu.QueryAsync"
      to: "IAsyncEnumerable<DicomDataset>"
      via: "yield return"
      pattern: "IAsyncEnumerable"
    - from: "DicomQuery"
      to: "CFindScu.QueryAsync"
      via: "ToDataset()"
      pattern: "QueryAsync.*DicomQuery"
---

<objective>
Implement C-FIND SCU service for querying remote PACS/RIS systems.

Purpose: Enable SharpDicom to query for studies, series, and instances from remote DICOM servers using standard Query/Retrieve information models.

Output: CFindScu class with IAsyncEnumerable-based QueryAsync method, DicomQuery fluent builder for constructing queries, and C-CANCEL support for in-progress queries.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-dimse-services/11-CONTEXT.md
@.planning/phases/11-dimse-services/11-RESEARCH.md
@src/SharpDicom/Network/Dimse/DicomCommand.cs
@src/SharpDicom/Network/DicomStatus.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CFindOptions and DicomQuery builder</name>
  <files>
    src/SharpDicom/Network/Dimse/Services/CFindOptions.cs
    src/SharpDicom/Network/Dimse/Services/DicomQuery.cs
  </files>
  <action>
Create CFindOptions.cs:
```csharp
namespace SharpDicom.Network.Dimse.Services
{
    /// <summary>
    /// Options for C-FIND SCU operations.
    /// </summary>
    public sealed class CFindOptions
    {
        /// <summary>Default C-FIND options.</summary>
        public static CFindOptions Default { get; } = new();

        /// <summary>
        /// Gets or sets the query timeout. Default is 10 seconds.
        /// </summary>
        public TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(10);

        /// <summary>
        /// Gets or sets the priority for the query operation. Default is MEDIUM (0).
        /// </summary>
        public ushort Priority { get; set; } = 0;

        /// <summary>
        /// Gets or sets whether to use Patient Root information model.
        /// When false, Study Root is used. Default is true.
        /// </summary>
        public bool UsePatientRoot { get; set; } = true;
    }
}
```

Create DicomQuery.cs per 11-RESEARCH.md:
```csharp
namespace SharpDicom.Network.Dimse.Services
{
    /// <summary>
    /// Fluent builder for DICOM C-FIND queries.
    /// </summary>
    public sealed class DicomQuery
    {
        private readonly DicomDataset _dataset = new();
        private readonly QueryRetrieveLevel _level;

        private DicomQuery(QueryRetrieveLevel level)
        {
            _level = level;
            _dataset.Add(DicomTag.QueryRetrieveLevel, level.ToDicomValue());
        }

        /// <summary>Creates a patient-level query.</summary>
        public static DicomQuery ForPatients() => new(QueryRetrieveLevel.Patient);

        /// <summary>Creates a study-level query.</summary>
        public static DicomQuery ForStudies() => new(QueryRetrieveLevel.Study);

        /// <summary>Creates a series-level query.</summary>
        public static DicomQuery ForSeries() => new(QueryRetrieveLevel.Series);

        /// <summary>Creates an image-level query.</summary>
        public static DicomQuery ForImages() => new(QueryRetrieveLevel.Image);

        /// <summary>Adds patient name matching criterion.</summary>
        public DicomQuery WithPatientName(string pattern)
        {
            AddString(DicomTag.PatientName, pattern);
            return this;
        }

        /// <summary>Adds patient ID matching criterion.</summary>
        public DicomQuery WithPatientId(string id)
        {
            AddString(DicomTag.PatientID, id);
            return this;
        }

        /// <summary>Adds study date matching criterion.</summary>
        public DicomQuery WithStudyDate(DateTime date)
        {
            AddString(DicomTag.StudyDate, date.ToString("yyyyMMdd"));
            return this;
        }

        /// <summary>Adds study date range matching criterion.</summary>
        public DicomQuery WithStudyDateRange(DateTime from, DateTime to)
        {
            AddString(DicomTag.StudyDate, $"{from:yyyyMMdd}-{to:yyyyMMdd}");
            return this;
        }

        /// <summary>Adds modality matching criterion (single or multiple).</summary>
        public DicomQuery WithModality(params string[] modalities)
        {
            AddString(DicomTag.ModalitiesInStudy, string.Join("\\", modalities));
            return this;
        }

        /// <summary>Adds accession number matching criterion.</summary>
        public DicomQuery WithAccessionNumber(string accession)
        {
            AddString(DicomTag.AccessionNumber, accession);
            return this;
        }

        /// <summary>Adds Study Instance UID matching criterion.</summary>
        public DicomQuery WithStudyInstanceUid(string uid)
        {
            AddString(DicomTag.StudyInstanceUID, uid);
            return this;
        }

        /// <summary>Adds Series Instance UID matching criterion.</summary>
        public DicomQuery WithSeriesInstanceUid(string uid)
        {
            AddString(DicomTag.SeriesInstanceUID, uid);
            return this;
        }

        /// <summary>Adds SOP Instance UID matching criterion.</summary>
        public DicomQuery WithSopInstanceUid(string uid)
        {
            AddString(DicomTag.SOPInstanceUID, uid);
            return this;
        }

        /// <summary>Requests a field to be returned in results (zero-length value).</summary>
        public DicomQuery ReturnField(DicomTag tag)
        {
            if (!_dataset.Contains(tag))
            {
                // Add zero-length element to request this field
                _dataset.Add(new DicomStringElement(tag, DicomVR.UN, Array.Empty<byte>()));
            }
            return this;
        }

        /// <summary>Gets the query/retrieve level.</summary>
        public QueryRetrieveLevel Level => _level;

        /// <summary>Converts the query to a DicomDataset.</summary>
        public DicomDataset ToDataset() => _dataset;

        private void AddString(DicomTag tag, string value)
        {
            var vr = DicomDictionary.TryLookup(tag, out var entry) ? entry.VR : DicomVR.LO;
            var bytes = System.Text.Encoding.ASCII.GetBytes(value);
            // Pad to even length
            if (bytes.Length % 2 != 0)
            {
                var padded = new byte[bytes.Length + 1];
                bytes.CopyTo(padded, 0);
                padded[padded.Length - 1] = (byte)(vr == DicomVR.UI ? '\0' : ' ');
                bytes = padded;
            }
            _dataset.Add(new DicomStringElement(tag, vr, bytes));
        }
    }
}
```
  </action>
  <verify>
`dotnet build src/SharpDicom/SharpDicom.csproj` compiles without errors
  </verify>
  <done>
CFindOptions with timeout and priority settings. DicomQuery fluent builder with common query parameters.
  </done>
</task>

<task type="auto">
  <name>Task 2: CFindScu service class with IAsyncEnumerable</name>
  <files>
    src/SharpDicom/Network/Dimse/Services/CFindScu.cs
  </files>
  <action>
Create CFindScu.cs implementing C-FIND SCU per 11-RESEARCH.md:

```csharp
using System.Runtime.CompilerServices;

namespace SharpDicom.Network.Dimse.Services
{
    /// <summary>
    /// C-FIND Service Class User (SCU) for querying remote PACS/RIS systems.
    /// </summary>
    public sealed class CFindScu
    {
        private readonly DicomClient _client;
        private readonly CFindOptions _options;
        private int _messageIdCounter;

        public CFindScu(DicomClient client, CFindOptions? options = null)
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
            _options = options ?? CFindOptions.Default;
        }

        /// <summary>
        /// Queries the remote AE using the specified query parameters.
        /// </summary>
        /// <param name="level">Query/Retrieve level.</param>
        /// <param name="identifier">Query identifier dataset.</param>
        /// <param name="ct">Cancellation token.</param>
        /// <returns>Async enumerable of matching datasets.</returns>
        public async IAsyncEnumerable<DicomDataset> QueryAsync(
            QueryRetrieveLevel level,
            DicomDataset identifier,
            [EnumeratorCancellation] CancellationToken ct = default)
        {
            var messageId = NextMessageId();
            var sopClassUid = GetSopClassUid(level);

            // Send C-FIND-RQ
            var request = DicomCommand.CreateCFindRequest(messageId, sopClassUid, _options.Priority);
            await SendCFindRequestAsync(request, identifier, ct).ConfigureAwait(false);

            // Receive responses until final
            while (true)
            {
                ct.ThrowIfCancellationRequested();

                // Check for cancellation and send C-CANCEL if needed
                if (ct.IsCancellationRequested)
                {
                    await SendCCancelAsync(messageId, ct).ConfigureAwait(false);
                    throw new OperationCanceledException(ct);
                }

                var (command, dataset) = await ReceiveCFindResponseAsync(ct).ConfigureAwait(false);

                // Verify it's a C-FIND-RSP
                if (!command.IsCFindResponse)
                    throw new DicomNetworkException($"Expected C-FIND-RSP, received 0x{command.CommandFieldValue:X4}");

                // Check status category
                if (command.Status.IsPending)
                {
                    // Pending - yield the identifier dataset
                    if (dataset != null)
                        yield return dataset;
                }
                else if (command.Status.IsSuccess)
                {
                    // Success - no more matches
                    yield break;
                }
                else if (command.Status.IsCancel)
                {
                    // Cancelled by SCP
                    throw new OperationCanceledException("C-FIND cancelled by remote AE");
                }
                else
                {
                    // Failure
                    throw new DicomNetworkException($"C-FIND failed with status 0x{command.Status.Code:X4}");
                }
            }
        }

        /// <summary>
        /// Queries the remote AE using a fluent DicomQuery.
        /// </summary>
        public IAsyncEnumerable<DicomDataset> QueryAsync(
            DicomQuery query,
            CancellationToken ct = default)
        {
            return QueryAsync(query.Level, query.ToDataset(), ct);
        }

        private DicomUID GetSopClassUid(QueryRetrieveLevel level)
        {
            // Use Patient Root or Study Root based on options
            return _options.UsePatientRoot
                ? level.GetPatientRootFindSopClassUid()
                : level.GetStudyRootFindSopClassUid();
        }

        private ushort NextMessageId() => (ushort)Interlocked.Increment(ref _messageIdCounter);

        private async Task SendCFindRequestAsync(DicomCommand command, DicomDataset identifier, CancellationToken ct)
        {
            // Serialize command (Implicit VR LE) and identifier (negotiated TS)
            // Send via P-DATA PDUs
            // Implementation uses _client internal methods
        }

        private async Task<(DicomCommand command, DicomDataset? dataset)> ReceiveCFindResponseAsync(CancellationToken ct)
        {
            // Receive P-DATA PDUs
            // Parse command and optional identifier dataset
            // Return parsed structures
        }

        private async Task SendCCancelAsync(ushort messageId, CancellationToken ct)
        {
            var cancel = DicomCommand.CreateCCancelRequest(messageId);
            // Send cancel command
        }
    }
}
```

Implementation notes:
1. C-FIND identifier uses negotiated transfer syntax, NOT Implicit VR LE
2. Response status 0xFF00 (Pending) means more results coming
3. Response status 0xFF01 (Pending with warnings) also yields results
4. Response status 0x0000 (Success) ends enumeration
5. Response status 0xFE00 (Cancel) throws OperationCanceledException
6. Failure statuses throw DicomNetworkException with status code
7. On CancellationToken cancellation, send C-CANCEL-RQ before throwing
  </action>
  <verify>
`dotnet build src/SharpDicom/SharpDicom.csproj` compiles without errors
  </verify>
  <done>
CFindScu class with QueryAsync returning IAsyncEnumerable<DicomDataset> and C-CANCEL support.
  </done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for CFindScu and DicomQuery</name>
  <files>
    tests/SharpDicom.Tests/Network/Dimse/CFindScuTests.cs
  </files>
  <action>
Create CFindScuTests.cs with tests:

CFindOptions tests:
- Default timeout is 10 seconds
- Default priority is MEDIUM (0)
- Default uses Patient Root

DicomQuery tests:
- ForStudies sets correct level
- ForSeries sets correct level
- ForImages sets correct level
- WithPatientName adds tag to dataset
- WithPatientId adds tag to dataset
- WithStudyDate formats correctly
- WithStudyDateRange formats as "YYYYMMDD-YYYYMMDD"
- WithModality joins multiple values with backslash
- ReturnField adds zero-length element
- ToDataset returns dataset with QueryRetrieveLevel

CFindScu constructor tests:
- Null client throws ArgumentNullException
- Default options used when null
- Custom options stored correctly

Command creation tests:
- C-FIND-RQ includes correct SOP Class UID for Patient Root
- C-FIND-RQ includes correct SOP Class UID for Study Root
- Message IDs increment
- C-CANCEL-RQ includes correct message ID

Note: Full network integration tests in Plan 11-07.
  </action>
  <verify>
`dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "CFindScuTests"` - all tests pass
  </verify>
  <done>
Unit tests verify DicomQuery builder, CFindOptions defaults, and command creation.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release` - builds without errors or warnings
2. `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "CFindScuTests"` - all new tests pass
3. `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj` - full test suite passes
</verification>

<success_criteria>
- CFindScu class with IAsyncEnumerable<DicomDataset> QueryAsync method
- DicomQuery fluent builder with common query parameters
- C-CANCEL support when CancellationToken cancelled
- Patient Root and Study Root information model support
- Unit tests verify query building and options
</success_criteria>

<output>
After completion, create `.planning/phases/11-dimse-services/11-03-SUMMARY.md`
</output>
