---
phase: 11-dimse-services
plan: 04
type: execute
wave: 3
depends_on: ["11-02"]
files_modified:
  - src/SharpDicom/Network/Dimse/Services/ICStoreHandler.cs
  - src/SharpDicom/Network/Dimse/Services/CStoreHandlerMode.cs
  - src/SharpDicom/Network/DicomServer.cs
  - src/SharpDicom/Network/DicomServerOptions.cs
  - tests/SharpDicom.Tests/Network/Dimse/CStoreScpTests.cs
autonomous: true

must_haves:
  truths:
    - "DicomServer can receive C-STORE requests from remote SCUs"
    - "Buffered mode delivers complete DicomDataset to handler"
    - "Streaming mode delivers metadata first, then pixel data stream"
    - "Handler can return success, warning, or failure status"
  artifacts:
    - path: "src/SharpDicom/Network/Dimse/Services/ICStoreHandler.cs"
      provides: "C-STORE SCP handler interfaces"
      contains: "interface ICStoreHandler"
    - path: "src/SharpDicom/Network/DicomServer.cs"
      provides: "Extended DicomServer with C-STORE SCP support"
      contains: "OnCStoreRequest"
  key_links:
    - from: "DicomServer"
      to: "ICStoreHandler"
      via: "OnCStoreRequest callback"
      pattern: "OnCStoreRequest|ICStoreHandler"
    - from: "DicomServerOptions.StoreHandlerMode"
      to: "Streaming|Buffered"
      via: "enum selection"
      pattern: "CStoreHandlerMode"
---

<objective>
Implement C-STORE SCP handler support for DicomServer to receive DICOM files.

Purpose: Enable SharpDicom to act as a Storage SCP - receive DICOM images from modalities, workstations, and other DICOM storage SCUs. Support both buffered (simple) and streaming (memory-efficient) modes.

Output: ICStoreHandler interface, IStreamingCStoreHandler interface, CStoreHandlerMode enum, and DicomServer extensions for handling incoming C-STORE requests.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-dimse-services/11-CONTEXT.md
@.planning/phases/11-dimse-services/11-RESEARCH.md
@.planning/phases/10-network-foundation/10-06-SUMMARY.md
@src/SharpDicom/Network/DicomServer.cs
@src/SharpDicom/Network/DicomServerOptions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: C-STORE handler interfaces and mode enum</name>
  <files>
    src/SharpDicom/Network/Dimse/Services/ICStoreHandler.cs
    src/SharpDicom/Network/Dimse/Services/CStoreHandlerMode.cs
  </files>
  <action>
Create CStoreHandlerMode.cs:
```csharp
namespace SharpDicom.Network.Dimse.Services
{
    /// <summary>
    /// Specifies how incoming C-STORE requests are handled.
    /// </summary>
    public enum CStoreHandlerMode
    {
        /// <summary>
        /// Full dataset buffered in memory before handler invoked.
        /// Simple but uses more memory for large datasets.
        /// </summary>
        Buffered,

        /// <summary>
        /// Metadata first, then pixel data streams via CopyToAsync pattern.
        /// Memory-efficient for large images.
        /// </summary>
        Streaming
    }
}
```

Create ICStoreHandler.cs per 11-RESEARCH.md:
```csharp
namespace SharpDicom.Network.Dimse.Services
{
    /// <summary>
    /// Handler for incoming C-STORE requests in buffered mode.
    /// </summary>
    public interface ICStoreHandler
    {
        /// <summary>
        /// Called when a C-STORE request is received with the complete dataset.
        /// </summary>
        /// <param name="context">Request context with association and command info.</param>
        /// <param name="dataset">The complete DICOM dataset including pixel data.</param>
        /// <param name="ct">Cancellation token.</param>
        /// <returns>Status to return in C-STORE-RSP.</returns>
        ValueTask<DicomStatus> OnCStoreAsync(
            CStoreRequestContext context,
            DicomDataset dataset,
            CancellationToken ct);
    }

    /// <summary>
    /// Handler for incoming C-STORE requests in streaming mode.
    /// </summary>
    public interface IStreamingCStoreHandler
    {
        /// <summary>
        /// Called when a C-STORE request is received with streaming pixel data.
        /// </summary>
        /// <param name="context">Request context with association and command info.</param>
        /// <param name="metadata">Dataset containing all elements except pixel data.</param>
        /// <param name="pixelDataStream">Stream for reading pixel data via CopyToAsync.</param>
        /// <param name="ct">Cancellation token.</param>
        /// <returns>Status to return in C-STORE-RSP.</returns>
        /// <remarks>
        /// The handler MUST read the pixelDataStream completely before returning.
        /// Incomplete reads will corrupt the association state.
        /// </remarks>
        ValueTask<DicomStatus> OnCStoreStreamingAsync(
            CStoreRequestContext context,
            DicomDataset metadata,
            Stream pixelDataStream,
            CancellationToken ct);
    }

    /// <summary>
    /// Context for C-STORE requests.
    /// </summary>
    public sealed class CStoreRequestContext
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CStoreRequestContext"/> class.
        /// </summary>
        public CStoreRequestContext(
            string callingAE,
            string calledAE,
            DicomUID sopClassUid,
            DicomUID sopInstanceUid,
            ushort messageId,
            byte presentationContextId)
        {
            CallingAE = callingAE;
            CalledAE = calledAE;
            SOPClassUID = sopClassUid;
            SOPInstanceUID = sopInstanceUid;
            MessageID = messageId;
            PresentationContextId = presentationContextId;
        }

        /// <summary>Gets the calling AE title.</summary>
        public string CallingAE { get; }

        /// <summary>Gets the called AE title.</summary>
        public string CalledAE { get; }

        /// <summary>Gets the SOP Class UID being stored.</summary>
        public DicomUID SOPClassUID { get; }

        /// <summary>Gets the SOP Instance UID being stored.</summary>
        public DicomUID SOPInstanceUID { get; }

        /// <summary>Gets the message ID.</summary>
        public ushort MessageID { get; }

        /// <summary>Gets the presentation context ID.</summary>
        public byte PresentationContextId { get; }
    }
}
```
  </action>
  <verify>
`dotnet build src/SharpDicom/SharpDicom.csproj` compiles without errors
  </verify>
  <done>
ICStoreHandler and IStreamingCStoreHandler interfaces defined with CStoreRequestContext and CStoreHandlerMode enum.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend DicomServerOptions for C-STORE SCP</name>
  <files>
    src/SharpDicom/Network/DicomServerOptions.cs
  </files>
  <action>
Add to DicomServerOptions.cs:

```csharp
/// <summary>
/// Gets or sets the C-STORE handler mode. Default is Buffered.
/// </summary>
public CStoreHandlerMode StoreHandlerMode { get; set; } = CStoreHandlerMode.Buffered;

/// <summary>
/// Gets or sets the C-STORE handler for buffered mode.
/// </summary>
/// <remarks>
/// Set this when StoreHandlerMode is Buffered.
/// Receives complete DicomDataset including pixel data.
/// </remarks>
public ICStoreHandler? CStoreHandler { get; set; }

/// <summary>
/// Gets or sets the C-STORE handler for streaming mode.
/// </summary>
/// <remarks>
/// Set this when StoreHandlerMode is Streaming.
/// Receives metadata first, then pixel data via stream.
/// </remarks>
public IStreamingCStoreHandler? StreamingCStoreHandler { get; set; }

/// <summary>
/// Gets or sets the C-STORE handler as a simple delegate (buffered mode shortcut).
/// </summary>
/// <remarks>
/// Alternative to implementing ICStoreHandler.
/// </remarks>
public Func<CStoreRequestContext, DicomDataset, CancellationToken, ValueTask<DicomStatus>>? OnCStoreRequest { get; set; }

/// <summary>
/// Gets or sets the maximum size for buffered datasets. Default is 512 MB.
/// </summary>
/// <remarks>
/// Datasets larger than this will be rejected if StoreHandlerMode is Buffered.
/// Use Streaming mode for larger datasets.
/// </remarks>
public long MaxBufferedDatasetSize { get; set; } = 512 * 1024 * 1024;
```

Update Validate() method to check handler consistency:
- If StoreHandlerMode is Buffered, at least one of CStoreHandler or OnCStoreRequest should be set
- If StoreHandlerMode is Streaming, StreamingCStoreHandler must be set
- Warn (or allow) if no handlers set - server will reject C-STORE requests
  </action>
  <verify>
`dotnet build src/SharpDicom/SharpDicom.csproj` compiles without errors
  </verify>
  <done>
DicomServerOptions extended with CStoreHandlerMode, handler properties, and validation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend DicomServer for C-STORE handling</name>
  <files>
    src/SharpDicom/Network/DicomServer.cs
  </files>
  <action>
Extend DicomServer.cs to handle C-STORE requests:

1. In association handling loop, detect C-STORE-RQ command (CommandField = 0x0001)

2. For Buffered mode:
   - Read complete dataset from P-DATA PDUs
   - Verify size against MaxBufferedDatasetSize
   - Build CStoreRequestContext from command
   - Call OnCStoreRequest or CStoreHandler.OnCStoreAsync
   - Send C-STORE-RSP with returned status

3. For Streaming mode:
   - Read metadata elements until pixel data tag (7FE0,0010)
   - Build CStoreRequestContext from command
   - Create wrapper stream over remaining P-DATA PDUs
   - Call StreamingCStoreHandler.OnCStoreStreamingAsync
   - Ensure all pixel data consumed from stream
   - Send C-STORE-RSP with returned status

4. Error handling:
   - If no handler configured: return status 0xA900 (SOPClassNotSupported)
   - If dataset too large for buffered mode: return status 0xA700 (OutOfResources)
   - If handler throws: return status 0xC000 (UnableToProcess)

5. Status codes for C-STORE-RSP per PS3.4:
   - 0x0000 = Success
   - 0xB000 = Warning: Coercion of Data Elements
   - 0xB007 = Warning: Data Set does not match SOP Class
   - 0xB006 = Warning: Element Discarded
   - 0xA7xx = Out of Resources
   - 0xA9xx = Data Set does not match SOP Class
   - 0xCxxx = Error: Cannot understand

Note: The existing DicomServer already handles P-DATA. Extend the DIMSE parsing to detect
C-STORE-RQ and route to appropriate handler. Reference inline C-ECHO handling as pattern.
  </action>
  <verify>
`dotnet build src/SharpDicom/SharpDicom.csproj` compiles without errors
  </verify>
  <done>
DicomServer handles incoming C-STORE requests in both buffered and streaming modes.
  </done>
</task>

<task type="auto">
  <name>Task 4: Unit tests for C-STORE SCP</name>
  <files>
    tests/SharpDicom.Tests/Network/Dimse/CStoreScpTests.cs
  </files>
  <action>
Create CStoreScpTests.cs with tests:

CStoreRequestContext tests:
- All properties set correctly from constructor
- SOPClassUID and SOPInstanceUID accessible

CStoreHandlerMode tests:
- Buffered is default value (0)
- Both enum values exist

DicomServerOptions C-STORE tests:
- StoreHandlerMode default is Buffered
- MaxBufferedDatasetSize default is 512 MB
- CStoreHandler property settable
- StreamingCStoreHandler property settable
- OnCStoreRequest delegate property settable

ICStoreHandler tests:
- Interface method signature correct
- Can create mock implementation

IStreamingCStoreHandler tests:
- Interface method signature correct
- Can create mock implementation

Note: Full integration tests with actual network traffic in Plan 11-07.
  </action>
  <verify>
`dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "CStoreScpTests"` - all tests pass
  </verify>
  <done>
Unit tests verify handler interfaces, context class, and options configuration.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release` - builds without errors or warnings
2. `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "CStoreScpTests"` - all new tests pass
3. `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj` - full test suite passes (no regressions)
</verification>

<success_criteria>
- ICStoreHandler interface for buffered mode
- IStreamingCStoreHandler interface for streaming mode
- CStoreHandlerMode enum with Buffered and Streaming values
- CStoreRequestContext with SOPClassUID, SOPInstanceUID, MessageID
- DicomServerOptions extended with C-STORE configuration
- DicomServer routes C-STORE-RQ to appropriate handler
- Handler return value becomes C-STORE-RSP status
</success_criteria>

<output>
After completion, create `.planning/phases/11-dimse-services/11-04-SUMMARY.md`
</output>
