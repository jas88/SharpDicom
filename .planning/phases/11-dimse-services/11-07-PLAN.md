---
phase: 11-dimse-services
plan: 07
type: execute
wave: 4
depends_on: ["11-02", "11-03", "11-04", "11-05", "11-06"]
files_modified:
  - tests/SharpDicom.Tests/Network/Dimse/CStoreIntegrationTests.cs
  - tests/SharpDicom.Tests/Network/Dimse/CFindIntegrationTests.cs
  - tests/SharpDicom.Tests/Network/Dimse/CMoveIntegrationTests.cs
  - tests/SharpDicom.Tests/Network/Dimse/CGetIntegrationTests.cs
  - tests/SharpDicom.Tests/Network/Dimse/DimseRoundtripTests.cs
  - tests/SharpDicom.Tests/Network/Dimse/DimseProtocolVerificationTests.cs
autonomous: true

must_haves:
  truths:
    - "C-STORE roundtrip works between SharpDicom client and server"
    - "C-FIND returns matching datasets"
    - "C-MOVE triggers sub-operations to destination"
    - "C-GET receives data via C-STORE sub-ops on same association"
    - "DCMTK interoperability verified for all DIMSE services"
  artifacts:
    - path: "tests/SharpDicom.Tests/Network/Dimse/DimseRoundtripTests.cs"
      provides: "Internal roundtrip tests"
      contains: "CStore_Roundtrip|CFind_Roundtrip"
    - path: "tests/SharpDicom.Tests/Network/Dimse/CStoreIntegrationTests.cs"
      provides: "DCMTK C-STORE integration tests"
      contains: "DCMTK|storescp"
  key_links:
    - from: "CStoreScu"
      to: "DicomServer C-STORE SCP"
      via: "network roundtrip"
      pattern: "CStoreScu.*DicomServer"
    - from: "Integration tests"
      to: "DCMTK"
      via: "storescp, storescu, findscp, movescu"
      pattern: "DCMTK|storescp|storescu"
---

<objective>
Create comprehensive integration tests for all DIMSE services with internal roundtrip and DCMTK interoperability.

Purpose: Verify that all DIMSE service implementations work correctly in real network scenarios - both between SharpDicom components and with standard DCMTK tools.

Output: Integration test suites for C-STORE, C-FIND, C-MOVE, and C-GET with both internal roundtrip tests and external DCMTK interoperability tests.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-dimse-services/11-CONTEXT.md
@.planning/phases/11-dimse-services/11-RESEARCH.md
@.planning/phases/10-network-foundation/10-07-SUMMARY.md
@tests/SharpDicom.Tests/Network/CEchoIntegrationTests.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Internal DIMSE roundtrip tests</name>
  <files>
    tests/SharpDicom.Tests/Network/Dimse/DimseRoundtripTests.cs
  </files>
  <action>
Create DimseRoundtripTests.cs following the pattern from CEchoIntegrationTests:

```csharp
[TestFixture]
public class DimseRoundtripTests
{
    private int _serverPort;
    private DicomServer? _server;

    [OneTimeSetUp]
    public async Task SetUp()
    {
        _serverPort = GetAvailablePort();
        // Configure server with all DIMSE handlers
        var options = new DicomServerOptions
        {
            Port = _serverPort,
            AETitle = "TEST_SCP",
            // C-ECHO handler from Phase 10
            OnCEcho = (ctx, ct) => ValueTask.FromResult(DicomStatus.Success),
            // C-STORE handler
            OnCStoreRequest = async (ctx, dataset, ct) =>
            {
                // Store to in-memory dictionary for verification
                ReceivedDatasets[ctx.SOPInstanceUID.ToString()] = dataset;
                return DicomStatus.Success;
            },
            // ... configure other handlers as needed
        };
        _server = new DicomServer(options);
        _server.Start();
    }

    [OneTimeTearDown]
    public async Task TearDown()
    {
        if (_server != null)
            await _server.DisposeAsync();
    }

    // C-STORE Tests
    [Test]
    public async Task CStore_SendFile_ReceivedByServer()
    {
        // Create test DICOM file
        // Connect client
        // Send via CStoreScu
        // Verify server received dataset
    }

    [Test]
    public async Task CStore_StreamSend_NoFullBuffering()
    {
        // Test streaming send doesn't load entire file
    }

    [Test]
    public async Task CStore_ProgressReported_DuringTransfer()
    {
        // Verify IProgress callbacks
    }

    [Test]
    public async Task CStore_Cancellation_AbortsTransfer()
    {
        // Test CancellationToken handling
    }

    // C-FIND Tests (if SCP implemented - may need mock)
    [Test]
    public async Task CFind_QueryStudies_ReturnsMatches()
    {
        // Query with DicomQuery builder
        // Verify IAsyncEnumerable yields results
    }

    [Test]
    public async Task CFind_Cancellation_SendsCCancel()
    {
        // Verify C-CANCEL sent when cancelled
    }

    // Note: C-MOVE and C-GET require more complex setup
    // May need to defer some tests to DCMTK integration
}
```

Test categories:
- C-STORE roundtrip (SharpDicom SCU -> SharpDicom SCP)
- Progress reporting verification
- Cancellation handling
- Error status handling
  </action>
  <verify>
`dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "DimseRoundtripTests"` - all tests pass
  </verify>
  <done>
Internal roundtrip tests verify C-STORE between SharpDicom client and server.
  </done>
</task>

<task type="auto">
  <name>Task 2: DCMTK C-STORE integration tests</name>
  <files>
    tests/SharpDicom.Tests/Network/Dimse/CStoreIntegrationTests.cs
  </files>
  <action>
Create CStoreIntegrationTests.cs for DCMTK interoperability:

```csharp
[TestFixture]
[Category("Integration")]
[Category("DCMTK")]
public class CStoreIntegrationTests
{
    // Test: SharpDicom SCU -> DCMTK storescp
    [Test]
    [Explicit("Requires DCMTK storescp")]
    public async Task CStoreScu_SendToDcmtkStorescp_Success()
    {
        // Start DCMTK storescp
        // storescp -v -od ./received 11113
        // Send DICOM file via CStoreScu
        // Verify file received
    }

    // Test: DCMTK storescu -> SharpDicom SCP
    [Test]
    [Explicit("Requires DCMTK storescu")]
    public async Task CStoreScp_ReceiveFromDcmtkStorescu_Success()
    {
        // Start SharpDicom server
        // Run: storescu localhost {port} test.dcm
        // Verify dataset received by handler
    }

    // Test: Large file transfer
    [Test]
    [Explicit("Requires DCMTK and large test file")]
    public async Task CStore_LargeFile_StreamingWorks()
    {
        // Test with multi-frame CT or MR
    }

    // Test: Multiple files in sequence
    [Test]
    [Explicit("Requires DCMTK")]
    public async Task CStore_MultipleFiles_AllReceived()
    {
        // Send multiple files on same association
    }
}
```

Follow pattern from Phase 10's CEchoIntegrationTests:
- [Explicit] attribute for tests requiring external tools
- [Category("Integration")] for CI filtering
- Helper methods for starting/stopping DCMTK processes
  </action>
  <verify>
`dotnet build tests/SharpDicom.Tests/SharpDicom.Tests.csproj` - compiles without errors
When DCMTK available: `dotnet test --filter "Category=DCMTK"` runs manually
  </verify>
  <done>
DCMTK C-STORE integration tests verify interoperability with storescp/storescu.
  </done>
</task>

<task type="auto">
  <name>Task 3: DCMTK C-FIND integration tests</name>
  <files>
    tests/SharpDicom.Tests/Network/Dimse/CFindIntegrationTests.cs
  </files>
  <action>
Create CFindIntegrationTests.cs:

```csharp
[TestFixture]
[Category("Integration")]
[Category("DCMTK")]
public class CFindIntegrationTests
{
    // Test: SharpDicom SCU -> DCMTK findscp
    [Test]
    [Explicit("Requires DCMTK findscp with test database")]
    public async Task CFindScu_QueryDcmtkFindscp_ReturnsMatches()
    {
        // Start DCMTK findscp with test database
        // findscp -v -aet FINDSCP -od ./db 11114
        // Query via CFindScu
        // Verify IAsyncEnumerable yields expected results
    }

    // Test: DicomQuery fluent builder
    [Test]
    [Explicit("Requires DCMTK findscp")]
    public async Task CFind_FluentQuery_FormatsCorrectly()
    {
        // DicomQuery.ForStudies().WithPatientName("Smith*")
        // Verify query sent correctly
    }

    // Test: C-CANCEL
    [Test]
    [Explicit("Requires DCMTK findscp")]
    public async Task CFind_Cancellation_SendsCCancel()
    {
        // Start query
        // Cancel after first result
        // Verify C-CANCEL sent
    }
}
```
  </action>
  <verify>
`dotnet build tests/SharpDicom.Tests/SharpDicom.Tests.csproj` - compiles without errors
  </verify>
  <done>
DCMTK C-FIND integration tests verify query operations with findscp.
  </done>
</task>

<task type="auto">
  <name>Task 4: Verify DIMSE protocol correctness</name>
  <files>
    tests/SharpDicom.Tests/Network/Dimse/DimseProtocolVerificationTests.cs
  </files>
  <action>
Create DimseProtocolVerificationTests.cs with specific verification checks from 11-RESEARCH.md.

Each check has explicit pass/fail criteria - no open-ended fixes.

```csharp
[TestFixture]
public class DimseProtocolVerificationTests
{
    // CHECK 1: Identifier uses negotiated TS not Implicit VR LE
    [Test]
    public void CFindRequest_IdentifierUsesNegotiatedTransferSyntax()
    {
        // Setup: Negotiate Explicit VR Little Endian
        // Action: Create C-FIND request with identifier
        // Verify: Captured PDV data is Explicit VR LE, NOT Implicit VR LE
        // Pass: VR bytes present in identifier element encoding
        // Fail: No VR bytes (Implicit VR encoding)
    }

    // CHECK 2: PDV fragmentation respects MaxPduLength
    [Test]
    public void CStoreRequest_LargeDataset_FragmentsRespectMaxPduLength()
    {
        // Setup: Set MaxPduLength to 16KB
        // Action: Send dataset larger than MaxPduLength
        // Verify: All P-DATA PDUs are <= MaxPduLength bytes
        // Pass: Every PDU length <= 16KB
        // Fail: Any PDU > MaxPduLength
    }

    // CHECK 3: Last fragment flag set correctly
    [Test]
    public void DataPdv_LastFragmentFlag_SetOnFinalPdv()
    {
        // Setup: Multi-PDV dataset transfer
        // Action: Capture PDV headers during send
        // Verify: Only final PDV has last fragment flag (0x02)
        // Pass: Intermediate PDVs have 0x00, final has 0x02
        // Fail: Flag missing on final or present on intermediate
    }

    // CHECK 4: Sub-op counts extracted correctly
    [Test]
    public void CMoveResponse_SubOperationCounts_ExtractedFromCommand()
    {
        // Setup: Mock C-MOVE-RSP with specific counts
        // Action: Parse response via ReceiveDimseResponseAsync
        // Verify: GetSubOperationProgress returns correct values
        // Pass: Remaining=5, Completed=3, Failed=1, Warning=0 matches mock
        // Fail: Any count differs from mock data
    }

    // CHECK 5: MoveDestination padded correctly
    [Test]
    public void CMoveRequest_MoveDestination_PaddedToEvenLength()
    {
        // Setup: Create C-MOVE-RQ with odd-length AE (e.g., "TEST")
        // Action: Serialize command
        // Verify: MoveDestination value has even byte length (space padded)
        // Pass: "TEST" becomes "TEST " (5 bytes -> 6 bytes with space pad)
        // Fail: Odd byte length in serialized command
    }

    // CHECK 6: SCP Role Selection for C-GET
    [Test]
    public void CGetAssociation_StorageSopClass_HasScpRoleSelection()
    {
        // Setup: Create presentation contexts for C-GET with Storage SOP Classes
        // Action: Build A-ASSOCIATE-RQ PDU
        // Verify: SCP/SCU Role Selection Sub-Item (0x54) present for Storage classes
        // Pass: Sub-Item 0x54 present with SCP role bit set
        // Fail: No Role Selection sub-item or SCP role not requested
    }
}
```

Verification criteria summary:
| Check | What | Pass Criteria | Fail Criteria |
|-------|------|---------------|---------------|
| 1 | Identifier TS | VR bytes present (Explicit VR) | No VR bytes (Implicit VR) |
| 2 | PDV fragmentation | All PDUs <= MaxPduLength | Any PDU > MaxPduLength |
| 3 | Last fragment flag | 0x02 on final PDV only | Wrong flag placement |
| 4 | Sub-op counts | Values match mock | Any mismatch |
| 5 | MoveDestination | Even byte length | Odd byte length |
| 6 | SCP Role Selection | Sub-Item 0x54 present | Missing sub-item |

If any check fails, fix in specific source file and add as regression test.
Do NOT create open-ended "fix issues" tasks.
  </action>
  <verify>
`dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "DimseProtocolVerificationTests"` - all 6 checks pass
  </verify>
  <done>
All 6 protocol correctness checks pass. Any failures were fixed with specific regression tests.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release` - builds without errors or warnings
2. `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "DimseRoundtripTests"` - internal tests pass
3. `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj` - full test suite passes
4. When DCMTK available: Manual verification of integration tests
</verification>

<success_criteria>
- C-STORE roundtrip works (SharpDicom SCU <-> SharpDicom SCP)
- C-STORE interops with DCMTK (storescp, storescu)
- C-FIND queries return results via IAsyncEnumerable
- Progress reporting works for all operations
- Cancellation sends C-CANCEL and throws OperationCanceledException
- All discovered bugs fixed with regression tests
</success_criteria>

<output>
After completion, create `.planning/phases/11-dimse-services/11-07-SUMMARY.md`
</output>
