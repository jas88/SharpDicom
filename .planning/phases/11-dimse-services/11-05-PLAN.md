---
phase: 11-dimse-services
plan: 05
type: execute
wave: 3
depends_on: ["11-03"]
files_modified:
  - src/SharpDicom/Network/Dimse/Services/CMoveScu.cs
  - src/SharpDicom/Network/Dimse/Services/CMoveOptions.cs
  - src/SharpDicom/Network/Dimse/Services/CMoveProgress.cs
  - tests/SharpDicom.Tests/Network/Dimse/CMoveScuTests.cs
autonomous: true

must_haves:
  truths:
    - "CMoveScu can initiate retrieval from PACS to third-party destination"
    - "MoveDestination specifies target AE for sub-operations"
    - "Progress yields SubOperationProgress with Remaining/Completed/Failed/Warning counts"
    - "Final response indicates completion with aggregate counts"
  artifacts:
    - path: "src/SharpDicom/Network/Dimse/Services/CMoveScu.cs"
      provides: "C-MOVE SCU service class"
      contains: "class CMoveScu"
    - path: "src/SharpDicom/Network/Dimse/Services/CMoveProgress.cs"
      provides: "C-MOVE progress tracking"
      contains: "class CMoveProgress"
  key_links:
    - from: "CMoveScu.MoveAsync"
      to: "IAsyncEnumerable<CMoveProgress>"
      via: "yield return"
      pattern: "IAsyncEnumerable<CMoveProgress>"
    - from: "CMoveProgress"
      to: "SubOperationProgress"
      via: "composition"
      pattern: "SubOperationProgress"
---

<objective>
Implement C-MOVE SCU service for retrieving DICOM data via third-party destination.

Purpose: Enable SharpDicom to trigger retrieval operations where the PACS sends images to another AE (not the requestor). This is the standard retrieval mechanism in most clinical PACS workflows.

Output: CMoveScu class with IAsyncEnumerable-based MoveAsync method that yields progress updates with sub-operation counts.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-dimse-services/11-CONTEXT.md
@.planning/phases/11-dimse-services/11-RESEARCH.md
@src/SharpDicom/Network/Dimse/DicomCommand.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: CMoveOptions and CMoveProgress types</name>
  <files>
    src/SharpDicom/Network/Dimse/Services/CMoveOptions.cs
    src/SharpDicom/Network/Dimse/Services/CMoveProgress.cs
  </files>
  <action>
Create CMoveOptions.cs:
```csharp
namespace SharpDicom.Network.Dimse.Services
{
    /// <summary>
    /// Options for C-MOVE SCU operations.
    /// </summary>
    public sealed class CMoveOptions
    {
        /// <summary>Default C-MOVE options.</summary>
        public static CMoveOptions Default { get; } = new();

        /// <summary>
        /// Gets or sets the operation timeout. Default is 120 seconds.
        /// </summary>
        /// <remarks>
        /// C-MOVE operations may take longer due to multiple sub-operations.
        /// </remarks>
        public TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(120);

        /// <summary>
        /// Gets or sets the priority for the move operation. Default is MEDIUM (0).
        /// </summary>
        public ushort Priority { get; set; } = 0;

        /// <summary>
        /// Gets or sets whether to use Patient Root information model.
        /// When false, Study Root is used. Default is true.
        /// </summary>
        public bool UsePatientRoot { get; set; } = true;
    }
}
```

Create CMoveProgress.cs:
```csharp
namespace SharpDicom.Network.Dimse.Services
{
    /// <summary>
    /// Progress update from a C-MOVE operation.
    /// </summary>
    public sealed class CMoveProgress
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CMoveProgress"/> class.
        /// </summary>
        public CMoveProgress(SubOperationProgress subOperations, DicomStatus status)
        {
            SubOperations = subOperations;
            Status = status;
        }

        /// <summary>Gets the sub-operation progress counts.</summary>
        public SubOperationProgress SubOperations { get; }

        /// <summary>Gets the DIMSE status from this response.</summary>
        public DicomStatus Status { get; }

        /// <summary>
        /// Gets whether this is the final response (no more sub-operations remaining).
        /// </summary>
        public bool IsFinal => SubOperations.IsFinal || !Status.IsPending;

        /// <summary>
        /// Gets whether the overall operation completed successfully.
        /// </summary>
        /// <remarks>
        /// True only if IsFinal and no failures or warnings.
        /// </remarks>
        public bool IsSuccess => IsFinal && Status.IsSuccess && !SubOperations.HasErrors;

        /// <summary>
        /// Gets whether the operation completed with partial success (some failures/warnings).
        /// </summary>
        public bool IsPartialSuccess => IsFinal &&
            (SubOperations.HasErrors || SubOperations.HasWarnings) &&
            SubOperations.Completed > 0;
    }
}
```
  </action>
  <verify>
`dotnet build src/SharpDicom/SharpDicom.csproj` compiles without errors
  </verify>
  <done>
CMoveOptions with timeout and priority. CMoveProgress wrapping SubOperationProgress with IsFinal and IsSuccess helpers.
  </done>
</task>

<task type="auto">
  <name>Task 2: CMoveScu service class</name>
  <files>
    src/SharpDicom/Network/Dimse/Services/CMoveScu.cs
  </files>
  <action>
Create CMoveScu.cs implementing C-MOVE SCU per 11-RESEARCH.md:

```csharp
using System.Runtime.CompilerServices;

namespace SharpDicom.Network.Dimse.Services
{
    /// <summary>
    /// C-MOVE Service Class User (SCU) for initiating retrieval to third-party destination.
    /// </summary>
    /// <remarks>
    /// <para>
    /// C-MOVE sends a retrieval request to the SCP, which then sends the matching
    /// instances to the specified MoveDestination AE via C-STORE sub-operations.
    /// </para>
    /// <para>
    /// The MoveDestination must be configured on the SCP - the SCP needs to know
    /// the network address of the destination AE to send the C-STORE operations.
    /// </para>
    /// </remarks>
    public sealed class CMoveScu
    {
        private readonly DicomClient _client;
        private readonly CMoveOptions _options;
        private int _messageIdCounter;

        public CMoveScu(DicomClient client, CMoveOptions? options = null)
        {
            _client = client ?? throw new ArgumentNullException(nameof(client));
            _options = options ?? CMoveOptions.Default;
        }

        /// <summary>
        /// Initiates a C-MOVE operation to send matching instances to the destination AE.
        /// </summary>
        /// <param name="level">Query/Retrieve level.</param>
        /// <param name="identifier">Keys identifying instances to retrieve.</param>
        /// <param name="destinationAE">AE Title where SCP will send via C-STORE.</param>
        /// <param name="ct">Cancellation token.</param>
        /// <returns>Async enumerable of progress updates.</returns>
        /// <remarks>
        /// <para>
        /// The destinationAE must be known to the SCP (configured in its AE table).
        /// If unknown, the SCP will return status 0xA801 (Move Destination Unknown).
        /// </para>
        /// <para>
        /// Each yielded CMoveProgress contains cumulative sub-operation counts.
        /// The final progress will have IsFinal=true and aggregate completion status.
        /// </para>
        /// </remarks>
        public async IAsyncEnumerable<CMoveProgress> MoveAsync(
            QueryRetrieveLevel level,
            DicomDataset identifier,
            string destinationAE,
            [EnumeratorCancellation] CancellationToken ct = default)
        {
            if (string.IsNullOrWhiteSpace(destinationAE))
                throw new ArgumentException("Destination AE is required", nameof(destinationAE));

            var messageId = NextMessageId();
            var sopClassUid = GetSopClassUid(level);

            // Send C-MOVE-RQ with MoveDestination
            var request = DicomCommand.CreateCMoveRequest(messageId, sopClassUid, destinationAE, _options.Priority);
            await SendCMoveRequestAsync(request, identifier, ct).ConfigureAwait(false);

            // Receive responses until final
            while (true)
            {
                ct.ThrowIfCancellationRequested();

                var command = await ReceiveCMoveResponseAsync(ct).ConfigureAwait(false);

                // Verify it's a C-MOVE-RSP
                if (!command.IsCMoveResponse)
                    throw new DicomNetworkException($"Expected C-MOVE-RSP, received 0x{command.CommandFieldValue:X4}");

                var progress = new CMoveProgress(
                    command.GetSubOperationProgress(),
                    command.Status);

                yield return progress;

                // Check for completion
                if (!command.Status.IsPending)
                {
                    // Final response received
                    if (command.Status.Code == 0xA801)
                        throw new DicomNetworkException($"Move destination '{destinationAE}' unknown to SCP");

                    yield break;
                }
            }
        }

        /// <summary>
        /// Initiates a C-MOVE operation using a fluent DicomQuery.
        /// </summary>
        public IAsyncEnumerable<CMoveProgress> MoveAsync(
            DicomQuery query,
            string destinationAE,
            CancellationToken ct = default)
        {
            return MoveAsync(query.Level, query.ToDataset(), destinationAE, ct);
        }

        private DicomUID GetSopClassUid(QueryRetrieveLevel level)
        {
            return _options.UsePatientRoot
                ? level.GetPatientRootMoveSopClassUid()
                : level.GetStudyRootMoveSopClassUid();
        }

        private ushort NextMessageId() => (ushort)Interlocked.Increment(ref _messageIdCounter);

        private async Task SendCMoveRequestAsync(DicomCommand command, DicomDataset identifier, CancellationToken ct)
        {
            // Get presentation context ID for C-MOVE SOP Class
            var pcid = GetPresentationContextId(command.AffectedSOPClassUID);

            // Send command + identifier using DicomClient DIMSE primitives (from 11-01 Task 4)
            // Command: Implicit VR LE, Identifier: negotiated transfer syntax
            await _client.SendDimseRequestAsync(pcid, command, identifier, ct).ConfigureAwait(false);
        }

        private async Task<DicomCommand> ReceiveCMoveResponseAsync(CancellationToken ct)
        {
            // Receive C-MOVE-RSP using DicomClient DIMSE primitives (from 11-01 Task 4)
            // C-MOVE-RSP has no dataset, just sub-operation counts in command
            var (command, _) = await _client.ReceiveDimseResponseAsync(ct).ConfigureAwait(false);
            return command;
        }
    }
}
```

Key implementation notes:
1. MoveDestination (0000,0600) MUST be in the C-MOVE-RQ command
2. Pending responses include NumberOfRemainingSuboperations (0000,1020)
3. Sub-operation counts are CUMULATIVE, not incremental per PS3.7
4. Status 0xA801 means destination AE unknown to SCP
5. Status 0xB000 indicates completion with warnings
6. C-CANCEL can be sent to abort (similar to C-FIND)
  </action>
  <verify>
`dotnet build src/SharpDicom/SharpDicom.csproj` compiles without errors
  </verify>
  <done>
CMoveScu class with IAsyncEnumerable<CMoveProgress> MoveAsync method.
  </done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for CMoveScu</name>
  <files>
    tests/SharpDicom.Tests/Network/Dimse/CMoveScuTests.cs
  </files>
  <action>
Create CMoveScuTests.cs with tests:

CMoveOptions tests:
- Default timeout is 120 seconds
- Default priority is MEDIUM (0)
- Default uses Patient Root

CMoveProgress tests:
- IsFinal true when Remaining=0
- IsFinal true when status not Pending
- IsSuccess true when IsFinal, Success status, no failures
- IsPartialSuccess true when failures but some completed
- SubOperations property accessible

CMoveScu constructor tests:
- Null client throws ArgumentNullException
- Default options used when null
- Custom options stored correctly

Command creation tests:
- C-MOVE-RQ includes MoveDestination field
- C-MOVE-RQ includes correct SOP Class UID for Patient Root
- C-MOVE-RQ includes correct SOP Class UID for Study Root
- Empty/null destinationAE throws ArgumentException

Note: Full network integration tests in Plan 11-07.
  </action>
  <verify>
`dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "CMoveScuTests"` - all tests pass
  </verify>
  <done>
Unit tests verify CMoveProgress properties, options defaults, and command creation with MoveDestination.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build src/SharpDicom/SharpDicom.csproj --configuration Release` - builds without errors or warnings
2. `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "CMoveScuTests"` - all new tests pass
3. `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj` - full test suite passes
</verification>

<success_criteria>
- CMoveScu class with MoveAsync returning IAsyncEnumerable<CMoveProgress>
- MoveDestination included in C-MOVE-RQ command
- CMoveProgress tracks sub-operation counts with IsFinal and IsSuccess helpers
- Patient Root and Study Root information model support
- Unit tests verify command creation and progress tracking
</success_criteria>

<output>
After completion, create `.planning/phases/11-dimse-services/11-05-SUMMARY.md`
</output>
