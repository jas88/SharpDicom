---
phase: 12-pure-csharp-codecs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SharpDicom/Data/TransferSyntax.cs
  - src/SharpDicom/Data/CompressionType.cs
  - src/SharpDicom/Codecs/Jpeg/JpegMarkers.cs
  - src/SharpDicom/Codecs/Jpeg/JpegFrameInfo.cs
  - src/SharpDicom/Codecs/Jpeg/HuffmanTable.cs
  - src/SharpDicom/Codecs/Jpeg/QuantizationTable.cs
  - src/SharpDicom/Codecs/ColorConversion.cs
autonomous: true

must_haves:
  truths:
    - "TransferSyntax.JPEGLossless exists with correct UID 1.2.840.10008.1.2.4.70"
    - "TransferSyntax.JPEG2000Lossy exists with correct UID 1.2.840.10008.1.2.4.91"
    - "JPEG markers can be parsed from byte streams"
    - "Standard JPEG Huffman tables are available for baseline encoding"
    - "YCbCr to RGB color conversion produces correct output per ITU-R BT.601"
  artifacts:
    - path: "src/SharpDicom/Data/TransferSyntax.cs"
      provides: "JPEGLossless and JPEG2000Lossy transfer syntax definitions"
      contains: "JPEGLossless"
    - path: "src/SharpDicom/Codecs/Jpeg/JpegMarkers.cs"
      provides: "JPEG marker constants and parsing utilities"
      exports: ["JpegMarkers", "JpegMarker"]
    - path: "src/SharpDicom/Codecs/Jpeg/HuffmanTable.cs"
      provides: "Huffman encoding/decoding tables"
      exports: ["HuffmanTable", "HuffmanDecoder"]
    - path: "src/SharpDicom/Codecs/ColorConversion.cs"
      provides: "YCbCr/RGB color space conversions"
      exports: ["ColorConversion"]
  key_links:
    - from: "JpegMarkers.cs"
      to: "JpegFrameInfo"
      via: "marker parsing"
      pattern: "TryParse.*SOF"
    - from: "ColorConversion.cs"
      to: "ITU-R BT.601"
      via: "standard coefficients"
      pattern: "0\\.299|0\\.587|0\\.114"
---

<objective>
Establish JPEG codec infrastructure with TransferSyntax definitions, marker parsing, Huffman tables, and color conversion utilities.

Purpose: Create the foundation types and utilities required by all JPEG-family codecs (Baseline, Lossless) and color space handling shared across codecs.
Output: TransferSyntax additions, JpegMarkers, HuffmanTable, QuantizationTable, JpegFrameInfo, ColorConversion types.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-pure-csharp-codecs/12-RESEARCH.md
@src/SharpDicom/Data/TransferSyntax.cs
@src/SharpDicom/Data/CompressionType.cs
@src/SharpDicom/Codecs/Rle/RleSegmentHeader.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add missing TransferSyntax definitions</name>
  <files>
    src/SharpDicom/Data/TransferSyntax.cs
    src/SharpDicom/Data/CompressionType.cs
  </files>
  <action>
Add the missing JPEG transfer syntax definitions to TransferSyntax.cs:

1. Add JPEGLossless (Process 14, Selection Value 1):
   - UID: 1.2.840.10008.1.2.4.70
   - IsExplicitVR: true, IsLittleEndian: true, IsEncapsulated: true, IsLossy: false
   - Compression: CompressionType.JPEGLossless

2. Add JPEG2000Lossy:
   - UID: 1.2.840.10008.1.2.4.91
   - IsExplicitVR: true, IsLittleEndian: true, IsEncapsulated: true, IsLossy: true
   - Compression: CompressionType.JPEG2000Lossy

3. Update FromUID() to recognize both new transfer syntaxes

Ensure CompressionType enum already has JPEGLossless and JPEG2000Lossy (verify from existing code).
  </action>
  <verify>Build succeeds: `dotnet build src/SharpDicom`</verify>
  <done>TransferSyntax.JPEGLossless and TransferSyntax.JPEG2000Lossy are defined and recognized by FromUID</done>
</task>

<task type="auto">
  <name>Task 2: Create JPEG marker parsing infrastructure</name>
  <files>
    src/SharpDicom/Codecs/Jpeg/JpegMarkers.cs
    src/SharpDicom/Codecs/Jpeg/JpegFrameInfo.cs
  </files>
  <action>
Create src/SharpDicom/Codecs/Jpeg/ directory and implement:

**JpegMarkers.cs** - Static class with JPEG marker constants:
```csharp
public static class JpegMarkers
{
    public const byte Prefix = 0xFF;
    public const byte SOI = 0xD8;   // Start of Image
    public const byte EOI = 0xD9;   // End of Image
    public const byte SOF0 = 0xC0;  // Baseline DCT
    public const byte SOF1 = 0xC1;  // Extended sequential DCT
    public const byte SOF2 = 0xC2;  // Progressive DCT
    public const byte SOF3 = 0xC3;  // Lossless (sequential)
    public const byte SOF7 = 0xC7;  // Lossless (differential)
    public const byte DHT = 0xC4;   // Define Huffman Table
    public const byte DAC = 0xCC;   // Define Arithmetic Coding
    public const byte DQT = 0xDB;   // Define Quantization Table
    public const byte DRI = 0xDD;   // Define Restart Interval
    public const byte SOS = 0xDA;   // Start of Scan
    public const byte RST0 = 0xD0;  // Restart marker 0
    public const byte APP0 = 0xE0;  // JFIF marker
    public const byte APP14 = 0xEE; // Adobe marker
    public const byte COM = 0xFE;   // Comment

    public static bool IsSOF(byte marker) => marker >= 0xC0 && marker <= 0xCF && marker != DHT && marker != 0xC8 && marker != DAC;
    public static bool IsRST(byte marker) => marker >= 0xD0 && marker <= 0xD7;
    public static bool IsAPP(byte marker) => marker >= 0xE0 && marker <= 0xEF;
}
```

**JpegFrameInfo.cs** - Parsed frame header information:
```csharp
public readonly record struct JpegFrameInfo(
    byte Precision,         // Sample precision (8, 12, or 16 bits)
    ushort Height,          // Image height
    ushort Width,           // Image width
    byte ComponentCount,    // Number of components
    bool IsBaseline,        // True for SOF0
    bool IsLossless,        // True for SOF3/SOF7
    bool IsProgressive);    // True for SOF2

// Include TryParse method for SOF segments
public static bool TryParse(ReadOnlySpan<byte> data, out JpegFrameInfo info);
```

Use BinaryPrimitives.ReadUInt16BigEndian for JPEG's big-endian format (per RESEARCH.md pitfall).
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>JpegMarkers constants and JpegFrameInfo.TryParse can extract frame dimensions from SOF segments</done>
</task>

<task type="auto">
  <name>Task 3: Create Huffman table and color conversion utilities</name>
  <files>
    src/SharpDicom/Codecs/Jpeg/HuffmanTable.cs
    src/SharpDicom/Codecs/Jpeg/QuantizationTable.cs
    src/SharpDicom/Codecs/ColorConversion.cs
  </files>
  <action>
**HuffmanTable.cs** - Huffman coding structures:
```csharp
public sealed class HuffmanTable
{
    // Standard JPEG tables (ITU-T.81 Annex K)
    public static readonly HuffmanTable LuminanceDC;
    public static readonly HuffmanTable LuminanceAC;
    public static readonly HuffmanTable ChrominanceDC;
    public static readonly HuffmanTable ChrominanceAC;

    private readonly int[] _maxCode;   // Max code value for each bit length
    private readonly int[] _valPtr;    // Index to values for each bit length
    private readonly byte[] _values;   // Symbol values

    // For encoding
    private readonly ushort[] _codeTable;  // Huffman codes indexed by symbol
    private readonly byte[] _sizeTable;    // Code lengths indexed by symbol

    public static bool TryParseDHT(ReadOnlySpan<byte> segment, out HuffmanTable table);
    public int DecodeSymbol(ref BitReader reader);  // For decoding
    public (ushort code, byte size) GetCode(byte symbol);  // For encoding
}
```

Include static initializer with ITU-T.81 Annex K standard tables. These are the default tables used when no DHT segment is present (allowed in JPEG Baseline).

**QuantizationTable.cs** - Quantization matrix:
```csharp
public sealed class QuantizationTable
{
    public static readonly QuantizationTable LuminanceDefault;
    public static readonly QuantizationTable ChrominanceDefault;
    public static readonly int[] ZigZagOrder; // 64-element array for 8x8 zigzag scan

    private readonly int[] _table;  // 64 quantization values

    public static bool TryParseDQT(ReadOnlySpan<byte> segment, out QuantizationTable table);
    public int this[int index] { get; }
}
```

**ColorConversion.cs** - Color space utilities:
```csharp
public static class ColorConversion
{
    // ITU-R BT.601 YCbCr to RGB (per DICOM PS3.3 C.7.6.3.1.2)
    public static void YCbCrToRgb(
        ReadOnlySpan<byte> y, ReadOnlySpan<byte> cb, ReadOnlySpan<byte> cr,
        Span<byte> rgb);

    // RGB to YCbCr (for encoding)
    public static void RgbToYCbCr(
        ReadOnlySpan<byte> rgb,
        Span<byte> y, Span<byte> cb, Span<byte> cr);

    // JPEG 2000 RCT (Reversible Color Transform) - lossless
    public static void ForwardRct(Span<int> r, Span<int> g, Span<int> b);
    public static void InverseRct(Span<int> y, Span<int> cb, Span<int> cr);

    // JPEG 2000 ICT (Irreversible Color Transform) - lossy
    public static void ForwardIct(Span<float> r, Span<float> g, Span<float> b);
    public static void InverseIct(Span<float> y, Span<float> cb, Span<float> cr);
}
```

Use the coefficient values from RESEARCH.md code examples. Ensure clamping to [0, 255] for 8-bit output.
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds and `dotnet test` passes</verify>
  <done>HuffmanTable can decode symbols, QuantizationTable provides zigzag scan, ColorConversion converts between YCbCr and RGB</done>
</task>

</tasks>

<verification>
1. `dotnet build src/SharpDicom` compiles without warnings
2. `dotnet test tests/SharpDicom.Tests` passes all existing tests (no regressions)
3. TransferSyntax.FromUID recognizes all four JPEG transfer syntaxes (Baseline, Lossless, J2K Lossless, J2K Lossy)
4. JpegFrameInfo.TryParse extracts correct dimensions from a test SOF segment
5. ColorConversion.YCbCrToRgb produces correct output for known test values
</verification>

<success_criteria>
- TransferSyntax.JPEGLossless.UID equals "1.2.840.10008.1.2.4.70"
- TransferSyntax.JPEG2000Lossy.UID equals "1.2.840.10008.1.2.4.91"
- JpegMarkers.SOF0 equals 0xC0
- HuffmanTable.LuminanceDC is not null
- ColorConversion.YCbCrToRgb converts (128, 128, 128) to approximately (128, 128, 128) gray
</success_criteria>

<output>
After completion, create `.planning/phases/12-pure-csharp-codecs/12-01-SUMMARY.md`
</output>
