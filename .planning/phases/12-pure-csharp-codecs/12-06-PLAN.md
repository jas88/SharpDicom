---
phase: 12-pure-csharp-codecs
plan: 06
type: execute
wave: 3
depends_on: ["12-05"]
files_modified:
  - src/SharpDicom/Codecs/Jpeg2000/Tier1/EbcotEncoder.cs
  - src/SharpDicom/Codecs/Jpeg2000/Tier1/EbcotDecoder.cs
  - src/SharpDicom/Codecs/Jpeg2000/Tier2/PacketEncoder.cs
  - src/SharpDicom/Codecs/Jpeg2000/Tier2/PacketDecoder.cs
  - src/SharpDicom/Codecs/Jpeg2000/J2kEncoder.cs
  - src/SharpDicom/Codecs/Jpeg2000/J2kDecoder.cs
autonomous: true

must_haves:
  truths:
    - "EBCOT bitplane coding produces correct code-block streams"
    - "Packet encoding creates valid JPEG 2000 packets"
    - "J2kDecoder can reconstruct images from JPEG 2000 codestreams"
    - "J2kEncoder can create valid JPEG 2000 codestreams"
  artifacts:
    - path: "src/SharpDicom/Codecs/Jpeg2000/Tier1/EbcotEncoder.cs"
      provides: "Bitplane coding for encoding"
      exports: ["EbcotEncoder"]
    - path: "src/SharpDicom/Codecs/Jpeg2000/Tier1/EbcotDecoder.cs"
      provides: "Bitplane decoding"
      exports: ["EbcotDecoder"]
    - path: "src/SharpDicom/Codecs/Jpeg2000/J2kDecoder.cs"
      provides: "Main JPEG 2000 decode entry"
      exports: ["J2kDecoder"]
    - path: "src/SharpDicom/Codecs/Jpeg2000/J2kEncoder.cs"
      provides: "Main JPEG 2000 encode entry"
      exports: ["J2kEncoder"]
  key_links:
    - from: "EbcotEncoder.cs"
      to: "MqCoder"
      via: "arithmetic coding"
      pattern: "MqEncoder"
    - from: "J2kDecoder.cs"
      to: "DwtTransform"
      via: "inverse wavelet"
      pattern: "DwtTransform\\.Inverse"
---

<objective>
Complete JPEG 2000 codec implementation with EBCOT tier-1 coding and tier-2 packet organization.

Purpose: EBCOT (Embedded Block Coding with Optimal Truncation) is the core of JPEG 2000 compression. Tier-2 organizes code-blocks into packets and layers for progressive transmission.
Output: Full J2kEncoder and J2kDecoder that produce/consume valid JPEG 2000 codestreams.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-pure-csharp-codecs/12-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement EBCOT bitplane coding</name>
  <files>
    src/SharpDicom/Codecs/Jpeg2000/Tier1/EbcotEncoder.cs
    src/SharpDicom/Codecs/Jpeg2000/Tier1/EbcotDecoder.cs
  </files>
  <action>
**EbcotEncoder.cs** - Tier-1 encoding (ITU-T T.800 Annex D):

```csharp
/// <summary>
/// EBCOT (Embedded Block Coding with Optimal Truncation) encoder.
/// </summary>
/// <remarks>
/// Encodes wavelet coefficients in code-blocks (typically 64x64) using
/// three coding passes per bitplane: significance, refinement, and cleanup.
/// </remarks>
public sealed class EbcotEncoder
{
    /// <summary>
    /// Default code-block size (64x64).
    /// </summary>
    public const int DefaultCodeBlockSize = 64;

    /// <summary>
    /// Encodes a single code-block.
    /// </summary>
    /// <param name="coefficients">Wavelet coefficients for this code-block.</param>
    /// <param name="width">Code-block width.</param>
    /// <param name="height">Code-block height.</param>
    /// <returns>Encoded data with pass information.</returns>
    public CodeBlockData EncodeCodeBlock(ReadOnlySpan<int> coefficients, int width, int height);
}

/// <summary>
/// Encoded code-block data.
/// </summary>
public readonly struct CodeBlockData
{
    public ReadOnlyMemory<byte> Data { get; init; }
    public int NumPasses { get; init; }
    public int[] PassLengths { get; init; }  // Cumulative lengths for truncation
    public int MsbPosition { get; init; }    // Most significant bitplane
}
```

EBCOT encoding algorithm:
1. Determine MSB position (find max magnitude)
2. For each bitplane from MSB to 0:
   - **Significance Propagation Pass**: Code bits that can become significant
   - **Refinement Pass**: Refine already-significant coefficients
   - **Cleanup Pass**: Handle remaining bits with run-length coding
3. Context determination based on neighbor significance/sign

Context modeling (19 contexts):
- Contexts 0-8: Significance coding (based on neighbor pattern)
- Context 9: Sign coding
- Contexts 10-13: Magnitude refinement
- Contexts 14-17: Run-length coding
- Context 18: Uniform distribution

**EbcotDecoder.cs** - Tier-1 decoding:

```csharp
/// <summary>
/// EBCOT decoder for code-block reconstruction.
/// </summary>
public sealed class EbcotDecoder
{
    /// <summary>
    /// Decodes a code-block given its encoded passes.
    /// </summary>
    /// <param name="data">Encoded data.</param>
    /// <param name="numPasses">Number of coding passes to decode.</param>
    /// <param name="width">Code-block width.</param>
    /// <param name="height">Code-block height.</param>
    /// <param name="msbPosition">MSB bitplane position.</param>
    /// <returns>Decoded wavelet coefficients.</returns>
    public int[] DecodeCodeBlock(
        ReadOnlySpan<byte> data,
        int numPasses,
        int width, int height,
        int msbPosition);
}
```

Decode mirrors encode: process bitplanes with three passes, building up coefficient magnitudes.
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>EbcotEncoder produces code-block streams with pass boundaries, EbcotDecoder reconstructs coefficients</done>
</task>

<task type="auto">
  <name>Task 2: Implement tier-2 packet organization</name>
  <files>
    src/SharpDicom/Codecs/Jpeg2000/Tier2/PacketEncoder.cs
    src/SharpDicom/Codecs/Jpeg2000/Tier2/PacketDecoder.cs
  </files>
  <action>
**PacketEncoder.cs** - Tier-2 encoding:

```csharp
/// <summary>
/// JPEG 2000 packet encoder for organizing code-blocks into layers.
/// </summary>
/// <remarks>
/// Packets organize code-block contributions by resolution, component,
/// layer, and position according to the progression order.
/// </remarks>
public sealed class PacketEncoder
{
    /// <summary>
    /// Creates packets from encoded code-blocks.
    /// </summary>
    /// <param name="codeBlocks">All encoded code-blocks.</param>
    /// <param name="numLayers">Number of quality layers.</param>
    /// <param name="progression">Progression order.</param>
    /// <returns>Packets organized by layer.</returns>
    public PacketData[] EncodePackets(
        CodeBlockData[,] codeBlocks,
        int numLayers,
        ProgressionOrder progression);
}

/// <summary>
/// A JPEG 2000 packet containing code-block contributions.
/// </summary>
public readonly struct PacketData
{
    public int Layer { get; init; }
    public int Resolution { get; init; }
    public int Component { get; init; }
    public int Position { get; init; }
    public ReadOnlyMemory<byte> Data { get; init; }
}
```

Packet structure:
1. Packet header (tag tree coding for inclusion/zero-bit-plane info)
2. Code-block contributions (variable length based on truncation)

Tag tree coding:
- Efficiently signals first layer where code-block contributes
- Signals number of leading zero bitplanes

**PacketDecoder.cs** - Tier-2 decoding:

```csharp
/// <summary>
/// JPEG 2000 packet decoder for extracting code-block data.
/// </summary>
public sealed class PacketDecoder
{
    /// <summary>
    /// Decodes packet headers and extracts code-block segments.
    /// </summary>
    /// <param name="data">Packet data.</param>
    /// <param name="numCodeBlocks">Number of code-blocks in this packet.</param>
    /// <returns>Code-block segments for this layer.</returns>
    public CodeBlockSegment[] DecodePacket(ReadOnlySpan<byte> data, int numCodeBlocks);
}

/// <summary>
/// A segment of code-block data from one layer.
/// </summary>
public readonly struct CodeBlockSegment
{
    public int CodeBlockIndex { get; init; }
    public int NumNewPasses { get; init; }
    public ReadOnlyMemory<byte> Data { get; init; }
}
```
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>PacketEncoder creates valid JPEG 2000 packets, PacketDecoder extracts code-block segments</done>
</task>

<task type="auto">
  <name>Task 3: Integrate into J2kEncoder and J2kDecoder</name>
  <files>
    src/SharpDicom/Codecs/Jpeg2000/J2kEncoder.cs
    src/SharpDicom/Codecs/Jpeg2000/J2kDecoder.cs
  </files>
  <action>
**J2kDecoder.cs** - Main decode entry point:

```csharp
/// <summary>
/// Decodes JPEG 2000 codestreams to raw pixel data.
/// </summary>
public static class J2kDecoder
{
    /// <summary>
    /// Decodes a JPEG 2000 codestream.
    /// </summary>
    public static DecodeResult DecodeFrame(
        ReadOnlySpan<byte> codestream,
        PixelDataInfo info,
        Span<byte> output,
        int frameIndex)
    {
        // 1. Parse codestream header (SOC, SIZ, COD, QCD)
        if (!J2kCodestream.TryParse(codestream, out var header, out var error))
            return DecodeResult.Fail(frameIndex, 0, error ?? "Invalid J2K header");

        // 2. Validate against PixelDataInfo
        if (header.ImageWidth != info.Columns || header.ImageHeight != info.Rows)
            return DecodeResult.Fail(frameIndex, 0, "Dimension mismatch");

        // 3. For each tile:
        //    a. Parse tile header (SOT)
        //    b. Decode packets (tier-2)
        //    c. Decode code-blocks (tier-1 with EBCOT)
        //    d. Inverse DWT

        // 4. If color image with ICT/RCT, apply inverse color transform

        // 5. Write to output buffer
    }
}
```

**J2kEncoder.cs** - Main encode entry point:

```csharp
/// <summary>
/// Encodes raw pixel data to JPEG 2000 codestreams.
/// </summary>
public static class J2kEncoder
{
    /// <summary>
    /// Encodes to JPEG 2000 format.
    /// </summary>
    public static ReadOnlyMemory<byte> EncodeFrame(
        ReadOnlySpan<byte> pixelData,
        PixelDataInfo info,
        bool lossless)
    {
        // 1. If color image, apply forward color transform (RCT for lossless, ICT for lossy)

        // 2. Forward DWT (5/3 for lossless, 9/7 for lossy)
        //    - Decompose each component
        //    - Multiple resolution levels (typically 5)

        // 3. Quantization (skip for lossless 5/3)
        //    - For lossy: apply dead-zone quantizer per QCD marker

        // 4. EBCOT encoding (tier-1)
        //    - Divide subbands into code-blocks (64x64)
        //    - Encode each code-block

        // 5. Packet organization (tier-2)
        //    - Organize code-blocks by progression order
        //    - Rate control / layer formation

        // 6. Write codestream
        //    - SOC, SIZ, COD, QCD markers
        //    - SOT, SOD, packet data
        //    - EOC
    }
}
```

Single-tile encoding (simplest case for medical imaging):
- One tile covering entire image
- LRCP progression (layer-resolution-component-position)
- Single quality layer for lossless

For lossy, support rate control:
- Target bits-per-pixel or file size
- Truncate code-block passes to achieve target
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>J2kDecoder.DecodeFrame produces raw pixels from J2K codestreams, J2kEncoder.EncodeFrame produces valid J2K codestreams</done>
</task>

</tasks>

<verification>
1. `dotnet build src/SharpDicom` compiles without warnings
2. `dotnet test tests/SharpDicom.Tests` passes all existing tests
3. EBCOT encode-decode roundtrip preserves coefficient values
4. Packet structure is valid (can be parsed by decoder)
5. J2kDecoder produces pixels from a simple test codestream
</verification>

<success_criteria>
- EbcotEncoder produces non-empty code-block data
- EbcotDecoder reconstructs coefficients from encoded data
- J2kDecoder.DecodeFrame returns Success for valid input
- J2kEncoder.EncodeFrame produces output starting with SOC marker (0xFF4F)
- Full encode-decode pipeline compiles and links correctly
</success_criteria>

<output>
After completion, create `.planning/phases/12-pure-csharp-codecs/12-06-SUMMARY.md`
</output>
