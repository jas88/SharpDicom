---
phase: 12-pure-csharp-codecs
plan: 05
type: execute
wave: 3
depends_on: ["12-01"]
files_modified:
  - src/SharpDicom/Codecs/Jpeg2000/J2kCodestream.cs
  - src/SharpDicom/Codecs/Jpeg2000/Wavelet/DwtTransform.cs
  - src/SharpDicom/Codecs/Jpeg2000/Wavelet/Dwt53.cs
  - src/SharpDicom/Codecs/Jpeg2000/Wavelet/Dwt97.cs
  - src/SharpDicom/Codecs/Jpeg2000/Tier1/MqCoder.cs
autonomous: true

must_haves:
  truths:
    - "JPEG 2000 codestream markers can be parsed"
    - "5/3 reversible wavelet transform produces bit-exact results"
    - "9/7 irreversible wavelet transform is implemented"
    - "MQ arithmetic coder can encode and decode bit sequences"
  artifacts:
    - path: "src/SharpDicom/Codecs/Jpeg2000/J2kCodestream.cs"
      provides: "JPEG 2000 marker parsing"
      exports: ["J2kCodestream", "J2kMarkers"]
    - path: "src/SharpDicom/Codecs/Jpeg2000/Wavelet/DwtTransform.cs"
      provides: "DWT coordination"
      exports: ["DwtTransform"]
    - path: "src/SharpDicom/Codecs/Jpeg2000/Wavelet/Dwt53.cs"
      provides: "Reversible 5/3 lifting"
      exports: ["Dwt53"]
    - path: "src/SharpDicom/Codecs/Jpeg2000/Tier1/MqCoder.cs"
      provides: "MQ arithmetic coding"
      exports: ["MqCoder", "MqEncoder", "MqDecoder"]
  key_links:
    - from: "DwtTransform.cs"
      to: "Dwt53/Dwt97"
      via: "lifting scheme selection"
      pattern: "lossless.*Dwt53|lossy.*Dwt97"
---

<objective>
Implement JPEG 2000 infrastructure: codestream parsing, wavelet transforms, and MQ arithmetic coding.

Purpose: JPEG 2000 is the most complex codec in this phase. This plan establishes the foundational components: DWT for spatial-frequency decomposition and MQ-coder for bitplane coding.
Output: J2kCodestream parser, Dwt53/Dwt97 transforms, MqCoder for arithmetic coding.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-pure-csharp-codecs/12-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JPEG 2000 codestream parser</name>
  <files>src/SharpDicom/Codecs/Jpeg2000/J2kCodestream.cs</files>
  <action>
Create src/SharpDicom/Codecs/Jpeg2000/ directory.

**J2kCodestream.cs** - JPEG 2000 marker parsing (ITU-T T.800):

```csharp
/// <summary>
/// JPEG 2000 codestream marker constants per ITU-T T.800.
/// </summary>
public static class J2kMarkers
{
    // Delimiting markers
    public const ushort SOC = 0xFF4F;  // Start of codestream
    public const ushort SOT = 0xFF90;  // Start of tile-part
    public const ushort SOD = 0xFF93;  // Start of data
    public const ushort EOC = 0xFFD9;  // End of codestream

    // Fixed information markers
    public const ushort SIZ = 0xFF51;  // Image and tile size
    public const ushort COD = 0xFF52;  // Coding style default
    public const ushort COC = 0xFF53;  // Coding style component
    public const ushort QCD = 0xFF5C;  // Quantization default
    public const ushort QCC = 0xFF5D;  // Quantization component

    // Functional markers
    public const ushort RGN = 0xFF5E;  // Region of interest
    public const ushort POC = 0xFF5F;  // Progression order change
    public const ushort PPM = 0xFF60;  // Packed packet headers (main)
    public const ushort PPT = 0xFF61;  // Packed packet headers (tile)
    public const ushort TLM = 0xFF55;  // Tile-part lengths
    public const ushort PLM = 0xFF57;  // Packet length (main)
    public const ushort PLT = 0xFF58;  // Packet length (tile)
    public const ushort COM = 0xFF64;  // Comment
}

/// <summary>
/// Parsed JPEG 2000 codestream header information.
/// </summary>
public sealed class J2kCodestream
{
    // From SIZ marker
    public int ImageWidth { get; init; }
    public int ImageHeight { get; init; }
    public int TileWidth { get; init; }
    public int TileHeight { get; init; }
    public int ComponentCount { get; init; }
    public int BitDepth { get; init; }
    public bool IsSigned { get; init; }

    // From COD marker
    public int DecompositionLevels { get; init; }
    public int CodeBlockWidth { get; init; }  // Typically 64
    public int CodeBlockHeight { get; init; } // Typically 64
    public bool UsesReversibleTransform { get; init; }  // 5/3 vs 9/7
    public ProgressionOrder Progression { get; init; }

    /// <summary>
    /// Parses a JPEG 2000 codestream header.
    /// </summary>
    public static bool TryParse(ReadOnlySpan<byte> data, out J2kCodestream header, out string? error);

    /// <summary>
    /// Finds the start of tile data (after SOD marker).
    /// </summary>
    public int FindTileDataOffset(ReadOnlySpan<byte> data, int tileIndex);
}

/// <summary>
/// JPEG 2000 progression orders.
/// </summary>
public enum ProgressionOrder
{
    LRCP = 0,  // Layer-Resolution-Component-Position
    RLCP = 1,  // Resolution-Layer-Component-Position
    RPCL = 2,  // Resolution-Position-Component-Layer
    PCRL = 3,  // Position-Component-Resolution-Layer
    CPRL = 4   // Component-Position-Resolution-Layer
}
```

Key parsing details:
- All markers are 2 bytes, big-endian
- Most markers are followed by 2-byte length (excluding marker bytes)
- SIZ is mandatory and first marker after SOC
- COD contains wavelet transform type (bit 6 of Scod: 0=9/7, 1=5/3)
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>J2kCodestream.TryParse extracts image dimensions, bit depth, and transform type from JPEG 2000 headers</done>
</task>

<task type="auto">
  <name>Task 2: Implement DWT 5/3 and 9/7 transforms</name>
  <files>
    src/SharpDicom/Codecs/Jpeg2000/Wavelet/DwtTransform.cs
    src/SharpDicom/Codecs/Jpeg2000/Wavelet/Dwt53.cs
    src/SharpDicom/Codecs/Jpeg2000/Wavelet/Dwt97.cs
  </files>
  <action>
Create src/SharpDicom/Codecs/Jpeg2000/Wavelet/ directory.

**DwtTransform.cs** - Coordination layer:

```csharp
/// <summary>
/// Discrete Wavelet Transform operations for JPEG 2000.
/// </summary>
public static class DwtTransform
{
    /// <summary>
    /// Performs forward 2D DWT decomposition.
    /// </summary>
    /// <param name="data">Image data (modified in-place).</param>
    /// <param name="width">Image width.</param>
    /// <param name="height">Image height.</param>
    /// <param name="levels">Number of decomposition levels.</param>
    /// <param name="reversible">True for 5/3 (lossless), false for 9/7 (lossy).</param>
    public static void Forward(Span<int> data, int width, int height, int levels, bool reversible);

    /// <summary>
    /// Performs inverse 2D DWT reconstruction.
    /// </summary>
    public static void Inverse(Span<int> data, int width, int height, int levels, bool reversible);
}
```

**Dwt53.cs** - Reversible 5/3 lifting (per ITU-T T.800 Annex F.3.3):

```csharp
/// <summary>
/// Reversible 5/3 wavelet transform using lifting scheme.
/// </summary>
/// <remarks>
/// The Le Gall 5/3 filter is used for lossless compression.
/// Lifting steps ensure bit-exact reconstruction.
/// </remarks>
public static class Dwt53
{
    /// <summary>
    /// Forward horizontal 1D transform (in-place).
    /// </summary>
    public static void ForwardHorizontal(Span<int> row);

    /// <summary>
    /// Forward vertical 1D transform (in-place).
    /// </summary>
    public static void ForwardVertical(Span<int> data, int width, int height);

    /// <summary>
    /// Inverse horizontal 1D transform.
    /// </summary>
    public static void InverseHorizontal(Span<int> row);

    /// <summary>
    /// Inverse vertical 1D transform.
    /// </summary>
    public static void InverseVertical(Span<int> data, int width, int height);
}
```

5/3 Lifting steps (forward):
```csharp
// Step 1: Update odd samples (high-pass)
// y[2n+1] = x[2n+1] - floor((x[2n] + x[2n+2]) / 2)

// Step 2: Update even samples (low-pass)
// y[2n] = x[2n] + floor((y[2n-1] + y[2n+1] + 2) / 4)
```

**Dwt97.cs** - Irreversible 9/7 lifting (per ITU-T T.800 Annex F.3.4):

```csharp
/// <summary>
/// Irreversible 9/7 wavelet transform using lifting scheme.
/// </summary>
/// <remarks>
/// The Daubechies 9/7 filter is used for lossy compression.
/// Floating-point arithmetic means reconstruction is not bit-exact.
/// </remarks>
public static class Dwt97
{
    // Lifting coefficients (ITU-T T.800)
    private const float Alpha = -1.586134342f;
    private const float Beta  = -0.052980118f;
    private const float Gamma =  0.882911075f;
    private const float Delta =  0.443506852f;
    private const float K     =  1.230174105f;

    public static void ForwardHorizontal(Span<float> row);
    public static void ForwardVertical(Span<float> data, int width, int height);
    public static void InverseHorizontal(Span<float> row);
    public static void InverseVertical(Span<float> data, int width, int height);
}
```

9/7 has 4 lifting steps:
```csharp
// Step 1: y[2n+1] += alpha * (y[2n] + y[2n+2])
// Step 2: y[2n] += beta * (y[2n-1] + y[2n+1])
// Step 3: y[2n+1] += gamma * (y[2n] + y[2n+2])
// Step 4: y[2n] += delta * (y[2n-1] + y[2n+1])
// Finally: scale by K and 1/K
```

Handle boundaries with symmetric extension.
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>Dwt53 provides reversible 5/3 transform (bit-exact roundtrip), Dwt97 provides irreversible 9/7 transform</done>
</task>

<task type="auto">
  <name>Task 3: Implement MQ arithmetic coder</name>
  <files>src/SharpDicom/Codecs/Jpeg2000/Tier1/MqCoder.cs</files>
  <action>
Create src/SharpDicom/Codecs/Jpeg2000/Tier1/ directory.

**MqCoder.cs** - MQ arithmetic coder (ITU-T T.800 Annex C):

```csharp
/// <summary>
/// MQ arithmetic coder for JPEG 2000 bitplane coding.
/// </summary>
/// <remarks>
/// The MQ-coder is a context-adaptive binary arithmetic coder based on QM-coder.
/// It maintains probability estimates for each context and adapts based on coded symbols.
/// </remarks>
public static class MqCoder
{
    /// <summary>
    /// Number of coding contexts (typically 19 for EBCOT).
    /// </summary>
    public const int NumContexts = 19;
}

/// <summary>
/// MQ arithmetic encoder.
/// </summary>
public sealed class MqEncoder : IDisposable
{
    private uint _a;           // Interval register (normalized to [0x8000, 0x10000))
    private uint _c;           // Code register
    private int _ct;           // Counter for output shift
    private int _bp;           // Current byte position
    private byte[] _buffer;
    private readonly byte[] _cx;  // Context index for each context

    public MqEncoder(int bufferSize = 4096);

    /// <summary>
    /// Encodes a single bit with the given context.
    /// </summary>
    /// <param name="context">Context index (0-18).</param>
    /// <param name="bit">Bit to encode (0 or 1).</param>
    public void Encode(int context, int bit);

    /// <summary>
    /// Flushes remaining bits and returns the encoded data.
    /// </summary>
    public ReadOnlySpan<byte> Flush();

    /// <summary>
    /// Resets the encoder state.
    /// </summary>
    public void Reset();
}

/// <summary>
/// MQ arithmetic decoder.
/// </summary>
public sealed class MqDecoder
{
    private uint _a;
    private uint _c;
    private int _ct;
    private int _bp;
    private readonly ReadOnlyMemory<byte> _data;
    private readonly byte[] _cx;

    public MqDecoder(ReadOnlyMemory<byte> data);

    /// <summary>
    /// Decodes a single bit using the given context.
    /// </summary>
    /// <param name="context">Context index (0-18).</param>
    /// <returns>The decoded bit (0 or 1).</returns>
    public int Decode(int context);

    /// <summary>
    /// Resets the decoder state for a new segment.
    /// </summary>
    public void Reset();
}
```

MQ-coder probability table (from ITU-T T.800 Table C.2):
```csharp
// Probability values (Qe) and transitions (NMPS, NLPS, SWITCH)
// 47 states total, initialized to specific probabilities
private static readonly (ushort Qe, byte NMPS, byte NLPS, byte Switch)[] States = new[]
{
    (0x5601, 1, 1, 1),   // State 0
    (0x3401, 2, 6, 0),   // State 1
    // ... 45 more states
    (0x0001, 46, 46, 0)  // State 46
};
```

Encoding algorithm:
1. Look up Qe value for current context state
2. Reduce interval: A -= Qe
3. If coding MPS: if A < 0x8000, renormalize
4. If coding LPS: C += A, A = Qe, then renormalize
5. Update context state based on coded symbol
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>MqEncoder and MqDecoder can encode/decode bit sequences with context-adaptive probability estimation</done>
</task>

</tasks>

<verification>
1. `dotnet build src/SharpDicom` compiles without warnings
2. `dotnet test tests/SharpDicom.Tests` passes all existing tests
3. Dwt53 forward then inverse produces identical values (bit-exact)
4. MqEncoder/MqDecoder roundtrip produces identical bit sequence
5. J2kCodestream.TryParse extracts correct dimensions from a test header
</verification>

<success_criteria>
- J2kCodestream parses SIZ marker to extract width/height
- Dwt53 forward then inverse on test data produces original values exactly
- Dwt97 forward then inverse on test data produces approximately original values
- MqEncoder.Encode followed by MqDecoder.Decode reproduces the same bits
- All code compiles on netstandard2.0, net8.0, and net9.0
</success_criteria>

<output>
After completion, create `.planning/phases/12-pure-csharp-codecs/12-05-SUMMARY.md`
</output>
