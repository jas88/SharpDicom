---
phase: 12-pure-csharp-codecs
plan: 04
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/SharpDicom/Codecs/JpegLossless/Predictor.cs
  - src/SharpDicom/Codecs/JpegLossless/LosslessHuffman.cs
  - src/SharpDicom/Codecs/JpegLossless/JpegLosslessDecoder.cs
  - src/SharpDicom/Codecs/JpegLossless/JpegLosslessEncoder.cs
  - src/SharpDicom/Codecs/JpegLossless/JpegLosslessCodec.cs
  - tests/SharpDicom.Tests/Codecs/JpegLosslessCodecTests.cs
autonomous: true

must_haves:
  truths:
    - "JPEG Lossless files can be decoded with bit-perfect accuracy"
    - "Raw pixel data can be encoded to JPEG Lossless format"
    - "Selection Value 1 predictor (horizontal) is correctly implemented"
    - "2-16 bit samples are supported per DICOM requirement"
  artifacts:
    - path: "src/SharpDicom/Codecs/JpegLossless/JpegLosslessCodec.cs"
      provides: "IPixelDataCodec for JPEG Lossless P14 SV1"
      exports: ["JpegLosslessCodec"]
    - path: "src/SharpDicom/Codecs/JpegLossless/Predictor.cs"
      provides: "DPCM predictors 1-7"
      exports: ["Predictor"]
    - path: "src/SharpDicom/Codecs/JpegLossless/LosslessHuffman.cs"
      provides: "Huffman coding for prediction residuals"
      exports: ["LosslessHuffman"]
  key_links:
    - from: "JpegLosslessCodec.cs"
      to: "TransferSyntax.JPEGLossless"
      via: "transfer syntax"
      pattern: "TransferSyntax\\.JPEGLossless"
    - from: "Predictor.cs"
      to: "ITU-T.81 Table H.1"
      via: "predictor formulas"
      pattern: "selectionValue switch"
---

<objective>
Implement the JPEG Lossless (Process 14, Selection Value 1) codec for diagnostic-quality lossless image compression.

Purpose: JPEG Lossless preserves exact pixel values, essential for diagnostic imaging. DICOM mandates Selection Value 1 (horizontal prediction) for transfer syntax 1.2.840.10008.1.2.4.70.
Output: JpegLosslessCodec implementing IPixelDataCodec with DPCM prediction and Huffman coding.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-pure-csharp-codecs/12-RESEARCH.md
@src/SharpDicom/Codecs/Rle/RleCodec.cs
@src/SharpDicom/Codecs/IPixelDataCodec.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement DPCM predictors and lossless Huffman coding</name>
  <files>
    src/SharpDicom/Codecs/JpegLossless/Predictor.cs
    src/SharpDicom/Codecs/JpegLossless/LosslessHuffman.cs
  </files>
  <action>
Create src/SharpDicom/Codecs/JpegLossless/ directory.

**Predictor.cs** - DPCM prediction per ITU-T.81 Table H.1:

```csharp
/// <summary>
/// JPEG Lossless DPCM predictors per ITU-T.81 Table H.1.
/// </summary>
public static class Predictor
{
    /// <summary>
    /// Computes the predicted value using the specified selection value.
    /// </summary>
    /// <param name="selectionValue">Predictor selection (1-7).</param>
    /// <param name="a">Sample immediately to the left (Ra).</param>
    /// <param name="b">Sample immediately above (Rb).</param>
    /// <param name="c">Sample above and to the left (Rc).</param>
    /// <returns>The predicted value.</returns>
    /// <remarks>
    /// DICOM Transfer Syntax 1.2.840.10008.1.2.4.70 MUST use Selection Value 1.
    /// </remarks>
    public static int Predict(int selectionValue, int a, int b, int c)
    {
        return selectionValue switch
        {
            0 => 0,                    // No prediction (hierarchical only)
            1 => a,                    // Ra (horizontal)
            2 => b,                    // Rb (vertical)
            3 => c,                    // Rc (diagonal)
            4 => a + b - c,           // Ra + Rb - Rc
            5 => a + ((b - c) >> 1),  // Ra + (Rb - Rc) / 2
            6 => b + ((a - c) >> 1),  // Rb + (Ra - Rc) / 2
            7 => (a + b) >> 1,        // (Ra + Rb) / 2
            _ => throw new ArgumentOutOfRangeException(nameof(selectionValue),
                $"Selection value must be 0-7, got {selectionValue}")
        };
    }

    /// <summary>
    /// Gets the neighboring samples for prediction.
    /// </summary>
    /// <param name="data">Image data array.</param>
    /// <param name="x">Current column.</param>
    /// <param name="y">Current row.</param>
    /// <param name="width">Image width.</param>
    /// <param name="a">Output: left neighbor.</param>
    /// <param name="b">Output: above neighbor.</param>
    /// <param name="c">Output: above-left neighbor.</param>
    public static void GetNeighbors(
        ReadOnlySpan<int> data, int x, int y, int width,
        out int a, out int b, out int c)
    {
        // Handle boundary conditions per ITU-T.81
        a = x > 0 ? data[y * width + x - 1] : 0;
        b = y > 0 ? data[(y - 1) * width + x] : 0;
        c = (x > 0 && y > 0) ? data[(y - 1) * width + x - 1] : 0;

        // First row, first column uses 2^(P-Pt-1) where P is precision
        // This is handled in the codec by initializing with the appropriate value
    }
}
```

**LosslessHuffman.cs** - Huffman coding for prediction residuals:

```csharp
/// <summary>
/// Huffman coding for JPEG Lossless prediction residuals.
/// </summary>
public sealed class LosslessHuffman
{
    /// <summary>
    /// Default DC Huffman table for lossless JPEG.
    /// </summary>
    public static readonly LosslessHuffman Default;

    private readonly int[] _maxCode;
    private readonly int[] _minCode;
    private readonly int[] _valPtr;
    private readonly byte[] _values;
    private readonly ushort[] _encodeCode;
    private readonly byte[] _encodeSize;

    /// <summary>
    /// Decodes a difference value from the bitstream.
    /// </summary>
    /// <param name="reader">The bit reader.</param>
    /// <returns>The signed difference value.</returns>
    public int DecodeDifference(ref BitReader reader)
    {
        // 1. Decode SSSS (category) using Huffman
        int ssss = DecodeCategory(ref reader);
        if (ssss == 0) return 0;

        // 2. Read SSSS additional bits
        int additional = reader.ReadBits(ssss);

        // 3. Extend sign
        return ExtendSign(additional, ssss);
    }

    /// <summary>
    /// Encodes a difference value to the bitstream.
    /// </summary>
    public void EncodeDifference(ref BitWriter writer, int diff)
    {
        // 1. Compute category SSSS
        int ssss = GetCategory(diff);

        // 2. Write Huffman code for category
        WriteCategory(ref writer, ssss);

        // 3. Write additional bits
        if (ssss > 0)
        {
            int additional = diff < 0 ? diff + (1 << ssss) - 1 : diff;
            writer.WriteBits(additional, ssss);
        }
    }

    private static int ExtendSign(int value, int category)
    {
        // If high bit is 0, value is negative
        int threshold = 1 << (category - 1);
        return value < threshold ? value - (1 << category) + 1 : value;
    }

    private static int GetCategory(int value)
    {
        if (value == 0) return 0;
        int absValue = Math.Abs(value);
        return (int)Math.Ceiling(Math.Log2(absValue + 1));
    }

    public static bool TryParseDHT(ReadOnlySpan<byte> segment, out LosslessHuffman table);
}
```
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>Predictor.Predict implements all 7 selection values, LosslessHuffman can encode/decode signed difference values</done>
</task>

<task type="auto">
  <name>Task 2: Implement JPEG Lossless decoder and encoder</name>
  <files>
    src/SharpDicom/Codecs/JpegLossless/JpegLosslessDecoder.cs
    src/SharpDicom/Codecs/JpegLossless/JpegLosslessEncoder.cs
  </files>
  <action>
**JpegLosslessDecoder.cs**:

```csharp
/// <summary>
/// Decodes JPEG Lossless (Process 14) compressed pixel data.
/// </summary>
public static class JpegLosslessDecoder
{
    /// <summary>
    /// Decodes a single JPEG Lossless frame.
    /// </summary>
    public static DecodeResult DecodeFrame(
        ReadOnlySpan<byte> compressedFrame,
        PixelDataInfo info,
        Span<byte> output,
        int frameIndex);
}
```

Decoding algorithm:
1. Find SOI marker
2. Parse markers until SOS:
   - SOF3 (lossless): Extract precision, dimensions, component info
   - DHT: Load Huffman table
   - SOS: Extract selection value (Ss parameter), point transform (Al)
3. Initialize first pixel with 2^(P-Pt-1) where P is precision, Pt is point transform
4. For each pixel:
   - Get neighbors (a, b, c)
   - Compute prediction using Predictor.Predict(selectionValue, a, b, c)
   - Decode difference using LosslessHuffman
   - Reconstruct: pixel = prediction + difference
   - Handle point transform if Pt > 0: pixel <<= Pt
5. Store to output (handle 8-bit, 12-bit, 16-bit precision)

**JpegLosslessEncoder.cs**:

```csharp
/// <summary>
/// Encodes raw pixel data to JPEG Lossless (Process 14) format.
/// </summary>
public static class JpegLosslessEncoder
{
    /// <summary>
    /// Encodes a single frame to JPEG Lossless format.
    /// </summary>
    public static ReadOnlyMemory<byte> EncodeFrame(
        ReadOnlySpan<byte> pixelData,
        PixelDataInfo info,
        int selectionValue = 1);  // DICOM requires SV1
}
```

Encoding algorithm:
1. Write SOI
2. Write DHT with Huffman table
3. Write SOF3 (lossless frame header)
   - Precision from BitsStored
   - Dimensions from Rows/Columns
4. Write SOS with selection value and point transform
5. For each pixel:
   - Get neighbors
   - Compute prediction
   - Compute difference = pixel - prediction
   - Encode difference using LosslessHuffman
6. Write EOI
7. Pad to even length

Handle multi-byte samples:
- 8-bit: 1 byte per sample
- 12-bit: 2 bytes per sample (high nibble unused)
- 16-bit: 2 bytes per sample (little-endian input, big-endian in JPEG)
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>JpegLosslessDecoder.DecodeFrame and JpegLosslessEncoder.EncodeFrame implement DPCM-based lossless compression</done>
</task>

<task type="auto">
  <name>Task 3: Create JpegLosslessCodec and tests</name>
  <files>
    src/SharpDicom/Codecs/JpegLossless/JpegLosslessCodec.cs
    tests/SharpDicom.Tests/Codecs/JpegLosslessCodecTests.cs
  </files>
  <action>
**JpegLosslessCodec.cs**:

```csharp
/// <summary>
/// JPEG Lossless (Process 14, Selection Value 1) codec implementing IPixelDataCodec.
/// </summary>
/// <remarks>
/// This codec implements DICOM Transfer Syntax 1.2.840.10008.1.2.4.70.
/// It uses DPCM prediction with Selection Value 1 (horizontal predictor)
/// and Huffman coding of prediction residuals.
/// </remarks>
public sealed class JpegLosslessCodec : IPixelDataCodec
{
    public TransferSyntax TransferSyntax => TransferSyntax.JPEGLossless;
    public string Name => "JPEG Lossless (Process 14, First-Order Prediction)";

    public CodecCapabilities Capabilities { get; } = new(
        CanEncode: true,
        CanDecode: true,
        IsLossy: false,  // Key difference from baseline
        SupportsMultiFrame: true,
        SupportsParallelEncode: true,
        SupportedBitDepths: new[] { 8, 12, 16 },  // 2-16 bit per DICOM
        SupportedSamplesPerPixel: new[] { 1, 3 });

    // Implement IPixelDataCodec methods...
}
```

**JpegLosslessCodecTests.cs**:

```csharp
[TestFixture]
public class JpegLosslessCodecTests
{
    private JpegLosslessCodec _codec = null!;

    [SetUp]
    public void Setup() => _codec = new JpegLosslessCodec();

    [Test]
    public void Capabilities_IndicatesLossless()
    {
        Assert.That(_codec.Capabilities.IsLossy, Is.False);
    }

    [Test]
    public void EncodeAndDecode_Grayscale8_BitPerfectRoundtrip()
    {
        var info = PixelDataInfo.Grayscale8(16, 16);
        var original = new byte[256];
        for (int i = 0; i < 256; i++) original[i] = (byte)i;

        var fragments = _codec.Encode(original, info);
        var decoded = new byte[256];
        var result = _codec.Decode(fragments, info, 0, decoded);

        Assert.That(result.Success, Is.True);
        Assert.That(decoded, Is.EqualTo(original), "Lossless roundtrip must be bit-perfect");
    }

    [Test]
    public void EncodeAndDecode_Grayscale16_BitPerfectRoundtrip()
    {
        var info = PixelDataInfo.Grayscale16(16, 16);
        var original = new byte[512];  // 256 pixels * 2 bytes
        for (int i = 0; i < 256; i++)
        {
            // Little-endian 16-bit values
            original[i * 2] = (byte)(i * 256);
            original[i * 2 + 1] = (byte)(i);
        }

        var fragments = _codec.Encode(original, info);
        var decoded = new byte[512];
        var result = _codec.Decode(fragments, info, 0, decoded);

        Assert.That(result.Success, Is.True);
        Assert.That(decoded, Is.EqualTo(original), "16-bit lossless roundtrip must be bit-perfect");
    }

    [Test]
    public void Predictor_SelectionValue1_ReturnsLeftNeighbor()
    {
        int predicted = Predictor.Predict(1, a: 100, b: 50, c: 75);
        Assert.That(predicted, Is.EqualTo(100));
    }
}
```
  </action>
  <verify>`dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~JpegLosslessCodecTests"` passes</verify>
  <done>JpegLosslessCodec passes bit-perfect roundtrip tests for 8-bit and 16-bit grayscale images</done>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds for entire solution
2. `dotnet test` passes all tests including new JpegLosslessCodecTests
3. 8-bit roundtrip produces identical bytes
4. 16-bit roundtrip produces identical bytes
5. Predictor.Predict(1, 100, 50, 75) returns 100 (horizontal prediction)
</verification>

<success_criteria>
- _codec.TransferSyntax.UID equals "1.2.840.10008.1.2.4.70"
- _codec.Capabilities.IsLossy is false
- _codec.Capabilities.SupportedBitDepths contains 8, 12, and 16
- Grayscale 8-bit roundtrip is bit-perfect (original == decoded)
- Grayscale 16-bit roundtrip is bit-perfect
- Encoded data is smaller than original (compression works)
</success_criteria>

<output>
After completion, create `.planning/phases/12-pure-csharp-codecs/12-04-SUMMARY.md`
</output>
