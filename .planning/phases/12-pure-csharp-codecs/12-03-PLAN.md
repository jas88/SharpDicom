---
phase: 12-pure-csharp-codecs
plan: 03
type: execute
wave: 2
depends_on: ["12-01", "12-02"]
files_modified:
  - src/SharpDicom/Codecs/Jpeg/JpegBaselineDecoder.cs
  - src/SharpDicom/Codecs/Jpeg/JpegBaselineEncoder.cs
  - src/SharpDicom/Codecs/Jpeg/JpegBaselineCodec.cs
  - tests/SharpDicom.Tests/Codecs/JpegBaselineCodecTests.cs
autonomous: true

must_haves:
  truths:
    - "JPEG Baseline files can be decoded to raw pixel data"
    - "Raw pixel data can be encoded to JPEG Baseline format"
    - "Codec integrates with IPixelDataCodec and CodecRegistry"
    - "8-bit grayscale and RGB images are supported"
  artifacts:
    - path: "src/SharpDicom/Codecs/Jpeg/JpegBaselineCodec.cs"
      provides: "IPixelDataCodec implementation for JPEG Baseline"
      exports: ["JpegBaselineCodec"]
    - path: "src/SharpDicom/Codecs/Jpeg/JpegBaselineDecoder.cs"
      provides: "Static decode methods for JPEG Baseline"
      exports: ["JpegBaselineDecoder"]
    - path: "src/SharpDicom/Codecs/Jpeg/JpegBaselineEncoder.cs"
      provides: "Static encode methods for JPEG Baseline"
      exports: ["JpegBaselineEncoder"]
  key_links:
    - from: "JpegBaselineCodec.cs"
      to: "IPixelDataCodec"
      via: "implements"
      pattern: "class JpegBaselineCodec.*IPixelDataCodec"
    - from: "JpegBaselineDecoder.cs"
      to: "DctTransform"
      via: "IDCT"
      pattern: "DctTransform\\.Inverse"
---

<objective>
Implement the JPEG Baseline (Process 1) codec for 8-bit lossy image compression.

Purpose: JPEG Baseline is the most common compressed transfer syntax in DICOM. This provides the foundation for reading and writing JPEG-compressed medical images.
Output: JpegBaselineCodec implementing IPixelDataCodec, with decoder and encoder components.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-pure-csharp-codecs/12-RESEARCH.md
@src/SharpDicom/Codecs/Rle/RleCodec.cs
@src/SharpDicom/Codecs/Rle/RleDecoder.cs
@src/SharpDicom/Codecs/Rle/RleEncoder.cs
@src/SharpDicom/Codecs/IPixelDataCodec.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JPEG Baseline decoder</name>
  <files>src/SharpDicom/Codecs/Jpeg/JpegBaselineDecoder.cs</files>
  <action>
Create JpegBaselineDecoder.cs following the pattern from RleDecoder:

```csharp
/// <summary>
/// Decodes JPEG Baseline (Process 1) compressed pixel data.
/// </summary>
public static class JpegBaselineDecoder
{
    /// <summary>
    /// Decodes a single JPEG frame to raw pixel data.
    /// </summary>
    public static DecodeResult DecodeFrame(
        ReadOnlySpan<byte> compressedFrame,
        PixelDataInfo info,
        Span<byte> output,
        int frameIndex);
}
```

Decoding algorithm:
1. Find SOI marker (0xFFD8)
2. Parse markers until SOS:
   - DQT: Load quantization tables
   - DHT: Load Huffman tables (or use defaults if absent)
   - SOF0: Validate frame info matches PixelDataInfo
   - SOS: Begin scan data decoding
3. For each 8x8 MCU:
   - Huffman decode DC coefficient (differential from previous)
   - Huffman decode AC coefficients (zigzag order)
   - Dequantize coefficients
   - Perform IDCT
   - Level shift (+128 for 8-bit)
   - Store to output
4. Handle restart markers if present
5. For color images: convert YCbCr to RGB using ColorConversion

Error handling:
- Return DecodeResult.Fail on truncated data
- Return DecodeResult.Fail on unsupported SOF type (not SOF0)
- Return DecodeResult.Fail on dimension mismatch

Use ArrayPool for temporary buffers during decode.
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>JpegBaselineDecoder.DecodeFrame can parse JPEG markers and decode 8x8 MCUs using Huffman decoding and IDCT</done>
</task>

<task type="auto">
  <name>Task 2: Implement JPEG Baseline encoder</name>
  <files>src/SharpDicom/Codecs/Jpeg/JpegBaselineEncoder.cs</files>
  <action>
Create JpegBaselineEncoder.cs following the pattern from RleEncoder:

```csharp
/// <summary>
/// Encodes raw pixel data to JPEG Baseline (Process 1) format.
/// </summary>
public static class JpegBaselineEncoder
{
    /// <summary>
    /// Encodes a single frame to JPEG Baseline format.
    /// </summary>
    public static ReadOnlyMemory<byte> EncodeFrame(
        ReadOnlySpan<byte> pixelData,
        PixelDataInfo info,
        JpegCodecOptions options);
}
```

Encoding algorithm:
1. Write SOI marker
2. For color images: convert RGB to YCbCr
3. Write DQT marker with quantization tables (scaled by quality)
4. Write SOF0 marker with frame dimensions
5. Write DHT markers with Huffman tables
6. Write SOS marker
7. For each 8x8 MCU:
   - Level shift (-128 for 8-bit)
   - Forward DCT
   - Quantize coefficients
   - Huffman encode DC (differential) and AC (zigzag)
   - Write to bitstream with byte stuffing
8. Write EOI marker
9. Ensure even length (DICOM requirement)

Quantization table scaling (quality -> scale factor):
```csharp
int scale = quality < 50 ? 5000 / quality : 200 - quality * 2;
// Apply scale to standard quantization table values
```

Handle subsampling per JpegCodecOptions:
- None (4:4:4): 1 Y MCU + 1 Cb MCU + 1 Cr MCU
- Horizontal (4:2:2): 2 Y MCUs + 1 Cb MCU + 1 Cr MCU
- Both (4:2:0): 4 Y MCUs + 1 Cb MCU + 1 Cr MCU
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>JpegBaselineEncoder.EncodeFrame produces valid JPEG bitstream with proper marker structure</done>
</task>

<task type="auto">
  <name>Task 3: Create JpegBaselineCodec and tests</name>
  <files>
    src/SharpDicom/Codecs/Jpeg/JpegBaselineCodec.cs
    tests/SharpDicom.Tests/Codecs/JpegBaselineCodecTests.cs
  </files>
  <action>
**JpegBaselineCodec.cs** - IPixelDataCodec implementation:

```csharp
/// <summary>
/// JPEG Baseline (Process 1) codec implementing IPixelDataCodec.
/// </summary>
public sealed class JpegBaselineCodec : IPixelDataCodec
{
    public TransferSyntax TransferSyntax => TransferSyntax.JPEGBaseline;
    public string Name => "JPEG Baseline (Process 1)";

    public CodecCapabilities Capabilities { get; } = new(
        CanEncode: true,
        CanDecode: true,
        IsLossy: true,
        SupportsMultiFrame: true,
        SupportsParallelEncode: true,
        SupportedBitDepths: new[] { 8 },  // Baseline is 8-bit only
        SupportedSamplesPerPixel: new[] { 1, 3 });  // Grayscale or RGB

    public DecodeResult Decode(
        DicomFragmentSequence fragments,
        PixelDataInfo info,
        int frameIndex,
        Memory<byte> destination);

    public ValueTask<DecodeResult> DecodeAsync(...);

    public DicomFragmentSequence Encode(
        ReadOnlySpan<byte> pixelData,
        PixelDataInfo info,
        object? options = null);

    public ValueTask<DicomFragmentSequence> EncodeAsync(...);

    public ValidationResult ValidateCompressedData(
        DicomFragmentSequence fragments,
        PixelDataInfo info);
}
```

Implement ValidateCompressedData to check:
- SOI marker present
- SOF0 dimensions match PixelDataInfo
- EOI marker present

**JpegBaselineCodecTests.cs** - Test suite:

```csharp
[TestFixture]
public class JpegBaselineCodecTests
{
    private JpegBaselineCodec _codec = null!;

    [SetUp]
    public void Setup() => _codec = new JpegBaselineCodec();

    [Test]
    public void TransferSyntax_ReturnsJpegBaseline()
    {
        Assert.That(_codec.TransferSyntax, Is.EqualTo(TransferSyntax.JPEGBaseline));
    }

    [Test]
    public void Capabilities_IndicatesLossy()
    {
        Assert.That(_codec.Capabilities.IsLossy, Is.True);
        Assert.That(_codec.Capabilities.SupportedBitDepths, Contains.Item(8));
    }

    [Test]
    public void EncodeAndDecode_Grayscale8_RoundtripSucceeds()
    {
        // Create test 8x8 grayscale image
        var info = PixelDataInfo.Grayscale8(8, 8);
        var original = new byte[64];
        for (int i = 0; i < 64; i++) original[i] = (byte)(i * 4);

        // Encode
        var options = new JpegCodecOptions { Quality = 100 };
        var fragments = _codec.Encode(original, info, options);

        // Decode
        var decoded = new byte[64];
        var result = _codec.Decode(fragments, info, 0, decoded);

        Assert.That(result.Success, Is.True);
        // Note: JPEG is lossy, so we check approximate equality
        for (int i = 0; i < 64; i++)
        {
            Assert.That(Math.Abs(decoded[i] - original[i]), Is.LessThanOrEqualTo(5),
                $"Pixel {i}: expected ~{original[i]}, got {decoded[i]}");
        }
    }

    [Test]
    public void EncodeAndDecode_Rgb8_RoundtripSucceeds()
    {
        // Create test 8x8 RGB image
        var info = PixelDataInfo.Rgb8(8, 8);
        var original = new byte[64 * 3];
        // Fill with gradient
        for (int i = 0; i < 64; i++)
        {
            original[i * 3 + 0] = (byte)(i * 4);     // R
            original[i * 3 + 1] = (byte)(128);       // G
            original[i * 3 + 2] = (byte)(255 - i * 4); // B
        }

        var options = new JpegCodecOptions { Quality = 100 };
        var fragments = _codec.Encode(original, info, options);
        var decoded = new byte[64 * 3];
        var result = _codec.Decode(fragments, info, 0, decoded);

        Assert.That(result.Success, Is.True);
    }
}
```
  </action>
  <verify>`dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~JpegBaselineCodecTests"` passes</verify>
  <done>JpegBaselineCodec implements IPixelDataCodec and passes roundtrip tests for 8-bit grayscale and RGB images</done>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds for entire solution
2. `dotnet test` passes all tests including new JpegBaselineCodecTests
3. JpegBaselineCodec can be registered with CodecRegistry
4. Encode/decode roundtrip produces visually similar image (PSNR > 30 dB for quality 90+)
5. Encoded JPEG contains valid marker structure (SOI, DQT, SOF0, DHT, SOS, EOI)
</verification>

<success_criteria>
- _codec.TransferSyntax.UID equals "1.2.840.10008.1.2.4.50"
- _codec.Capabilities.IsLossy is true
- _codec.Capabilities.SupportedBitDepths contains 8
- Grayscale 8x8 roundtrip test passes with max pixel error <= 5 at quality 100
- RGB 8x8 roundtrip test completes without exception
- ValidateCompressedData returns valid for properly encoded frames
</success_criteria>

<output>
After completion, create `.planning/phases/12-pure-csharp-codecs/12-03-SUMMARY.md`
</output>
