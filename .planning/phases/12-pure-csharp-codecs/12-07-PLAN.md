---
phase: 12-pure-csharp-codecs
plan: 07
type: execute
wave: 4
depends_on: ["12-03", "12-04", "12-06"]
files_modified:
  - src/SharpDicom/Codecs/Jpeg2000/Jpeg2000LosslessCodec.cs
  - src/SharpDicom/Codecs/Jpeg2000/Jpeg2000LossyCodec.cs
  - src/SharpDicom/Codecs/Jpeg2000/Jpeg2000CodecOptions.cs
  - src/SharpDicom/Codecs/CodecInitializer.cs
  - tests/SharpDicom.Tests/Codecs/Jpeg2000CodecTests.cs
  - tests/SharpDicom.Tests/Codecs/CodecRegistryIntegrationTests.cs
autonomous: true

must_haves:
  truths:
    - "JPEG 2000 Lossless codec provides bit-perfect roundtrip"
    - "JPEG 2000 Lossy codec produces valid compressed output"
    - "All codecs can be registered with CodecRegistry"
    - "CodecRegistry.GetCodec returns correct codec for each transfer syntax"
    - "All codecs pass AOT compilation test"
  artifacts:
    - path: "src/SharpDicom/Codecs/Jpeg2000/Jpeg2000LosslessCodec.cs"
      provides: "IPixelDataCodec for J2K lossless"
      exports: ["Jpeg2000LosslessCodec"]
    - path: "src/SharpDicom/Codecs/Jpeg2000/Jpeg2000LossyCodec.cs"
      provides: "IPixelDataCodec for J2K lossy"
      exports: ["Jpeg2000LossyCodec"]
    - path: "src/SharpDicom/Codecs/CodecInitializer.cs"
      provides: "AOT-compatible codec registration"
      exports: ["CodecInitializer"]
  key_links:
    - from: "CodecInitializer.cs"
      to: "CodecRegistry"
      via: "explicit registration"
      pattern: "CodecRegistry\\.Register"
    - from: "Jpeg2000LosslessCodec.cs"
      to: "TransferSyntax.JPEG2000Lossless"
      via: "transfer syntax"
      pattern: "TransferSyntax\\.JPEG2000Lossless"
---

<objective>
Complete JPEG 2000 codec integration and create unified AOT-compatible registration for all Phase 12 codecs.

Purpose: Wrap the JPEG 2000 infrastructure into IPixelDataCodec implementations and provide a clean registration mechanism for all codecs that works with AOT/trimming.
Output: Jpeg2000LosslessCodec, Jpeg2000LossyCodec, CodecInitializer, and comprehensive test suite.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-pure-csharp-codecs/12-RESEARCH.md
@src/SharpDicom/Codecs/IPixelDataCodec.cs
@src/SharpDicom/Codecs/CodecRegistry.cs
@src/SharpDicom/Codecs/Rle/RleCodec.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JPEG 2000 codec implementations</name>
  <files>
    src/SharpDicom/Codecs/Jpeg2000/Jpeg2000LosslessCodec.cs
    src/SharpDicom/Codecs/Jpeg2000/Jpeg2000LossyCodec.cs
    src/SharpDicom/Codecs/Jpeg2000/Jpeg2000CodecOptions.cs
  </files>
  <action>
**Jpeg2000LosslessCodec.cs**:

```csharp
/// <summary>
/// JPEG 2000 Lossless codec implementing IPixelDataCodec.
/// </summary>
/// <remarks>
/// Uses reversible 5/3 wavelet transform and reversible color transform (RCT).
/// Provides bit-perfect reconstruction.
/// </remarks>
public sealed class Jpeg2000LosslessCodec : IPixelDataCodec
{
    public TransferSyntax TransferSyntax => TransferSyntax.JPEG2000Lossless;
    public string Name => "JPEG 2000 Image Compression (Lossless Only)";

    public CodecCapabilities Capabilities { get; } = new(
        CanEncode: true,
        CanDecode: true,
        IsLossy: false,
        SupportsMultiFrame: true,
        SupportsParallelEncode: true,
        SupportedBitDepths: new[] { 8, 12, 16 },
        SupportedSamplesPerPixel: new[] { 1, 3 });

    public DecodeResult Decode(
        DicomFragmentSequence fragments,
        PixelDataInfo info,
        int frameIndex,
        Memory<byte> destination)
    {
        ThrowHelpers.ThrowIfNull(fragments, nameof(fragments));
        if (frameIndex < 0 || frameIndex >= fragments.Fragments.Count)
            return DecodeResult.Fail(frameIndex, 0, $"Frame index out of range");

        var fragment = fragments.Fragments[frameIndex];
        return J2kDecoder.DecodeFrame(fragment.Span, info, destination.Span, frameIndex);
    }

    public ValueTask<DecodeResult> DecodeAsync(
        DicomFragmentSequence fragments,
        PixelDataInfo info,
        int frameIndex,
        Memory<byte> destination,
        CancellationToken cancellationToken = default)
    {
        cancellationToken.ThrowIfCancellationRequested();
        return new ValueTask<DecodeResult>(Decode(fragments, info, frameIndex, destination));
    }

    public DicomFragmentSequence Encode(
        ReadOnlySpan<byte> pixelData,
        PixelDataInfo info,
        object? options = null)
    {
        int frameSize = info.FrameSize;
        int frameCount = pixelData.Length / frameSize;
        var fragments = new List<ReadOnlyMemory<byte>>(frameCount);

        for (int i = 0; i < frameCount; i++)
        {
            var frameData = pixelData.Slice(i * frameSize, frameSize);
            var encoded = J2kEncoder.EncodeFrame(frameData, info, lossless: true);
            fragments.Add(encoded);
        }

        return new DicomFragmentSequence(DicomTag.PixelData, DicomVR.OB,
            ReadOnlyMemory<byte>.Empty, fragments);
    }

    public ValueTask<DicomFragmentSequence> EncodeAsync(
        ReadOnlyMemory<byte> pixelData,
        PixelDataInfo info,
        object? options = null,
        CancellationToken cancellationToken = default)
    {
        cancellationToken.ThrowIfCancellationRequested();
        return new ValueTask<DicomFragmentSequence>(Encode(pixelData.Span, info, options));
    }

    public ValidationResult ValidateCompressedData(DicomFragmentSequence fragments, PixelDataInfo info)
    {
        if (fragments == null)
            return ValidationResult.Invalid(0, 0, "Fragments cannot be null");

        var issues = new List<CodecDiagnostic>();
        foreach (var (fragment, index) in fragments.Fragments.Select((f, i) => (f, i)))
        {
            if (!J2kCodestream.TryParse(fragment.Span, out var header, out var error))
            {
                issues.Add(new CodecDiagnostic(index, 0, error ?? "Invalid J2K header", null, null));
                continue;
            }

            if (!header.UsesReversibleTransform)
            {
                issues.Add(new CodecDiagnostic(index, 0,
                    "Lossless codec received lossy codestream (9/7 transform)",
                    "5/3 reversible", "9/7 irreversible"));
            }
        }

        return issues.Count == 0 ? ValidationResult.Valid() : ValidationResult.Invalid(issues);
    }
}
```

**Jpeg2000LossyCodec.cs** - Similar structure but with lossy:

```csharp
public sealed class Jpeg2000LossyCodec : IPixelDataCodec
{
    public TransferSyntax TransferSyntax => TransferSyntax.JPEG2000Lossy;
    public string Name => "JPEG 2000 Image Compression";

    public CodecCapabilities Capabilities { get; } = new(
        CanEncode: true,
        CanDecode: true,
        IsLossy: true,  // Key difference
        SupportsMultiFrame: true,
        SupportsParallelEncode: true,
        SupportedBitDepths: new[] { 8, 12, 16 },
        SupportedSamplesPerPixel: new[] { 1, 3 });

    // Encode calls J2kEncoder.EncodeFrame(..., lossless: false)
    // Options: Jpeg2000CodecOptions with compression ratio or target size
}
```

**Jpeg2000CodecOptions.cs**:

```csharp
/// <summary>
/// Options for JPEG 2000 encoding.
/// </summary>
public sealed class Jpeg2000CodecOptions
{
    /// <summary>
    /// Target compression ratio for lossy encoding (e.g., 10 = 10:1 compression).
    /// </summary>
    public int CompressionRatio { get; set; } = 10;

    /// <summary>
    /// Number of decomposition levels (typically 5).
    /// </summary>
    public int DecompositionLevels { get; set; } = 5;

    /// <summary>
    /// Number of quality layers (1 for single quality, more for progressive).
    /// </summary>
    public int QualityLayers { get; set; } = 1;

    /// <summary>
    /// Code-block size (default 64x64).
    /// </summary>
    public int CodeBlockSize { get; set; } = 64;

    /// <summary>
    /// Default options for medical imaging.
    /// </summary>
    public static Jpeg2000CodecOptions MedicalImaging { get; } = new()
    {
        CompressionRatio = 5,  // Conservative for medical
        DecompositionLevels = 5,
        QualityLayers = 1
    };

    public static Jpeg2000CodecOptions Default { get; } = new();
}
```
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>Jpeg2000LosslessCodec and Jpeg2000LossyCodec implement IPixelDataCodec with appropriate capabilities</done>
</task>

<task type="auto">
  <name>Task 2: Create AOT-compatible codec registration</name>
  <files>src/SharpDicom/Codecs/CodecInitializer.cs</files>
  <action>
**CodecInitializer.cs** - Explicit registration for AOT compatibility:

```csharp
using System.Runtime.CompilerServices;

namespace SharpDicom.Codecs
{
    /// <summary>
    /// Provides explicit codec registration for AOT/trimming compatibility.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This class registers all built-in codecs explicitly without reflection.
    /// For AOT-compiled applications, call <see cref="RegisterAll"/> at startup.
    /// </para>
    /// <para>
    /// For non-AOT scenarios, the ModuleInitializer will register codecs automatically
    /// when this assembly is loaded.
    /// </para>
    /// </remarks>
    public static class CodecInitializer
    {
        private static bool _initialized;
        private static readonly object _lock = new();

        /// <summary>
        /// Registers all built-in codecs with the CodecRegistry.
        /// </summary>
        /// <remarks>
        /// This method is idempotent - calling it multiple times has no effect.
        /// </remarks>
        public static void RegisterAll()
        {
            if (_initialized) return;

            lock (_lock)
            {
                if (_initialized) return;

                // RLE Lossless (from Phase 9)
                CodecRegistry.Register(new Rle.RleCodec());

                // JPEG Baseline (8-bit lossy)
                CodecRegistry.Register(new Jpeg.JpegBaselineCodec());

                // JPEG Lossless (Process 14, SV1)
                CodecRegistry.Register(new JpegLossless.JpegLosslessCodec());

                // JPEG 2000 Lossless
                CodecRegistry.Register(new Jpeg2000.Jpeg2000LosslessCodec());

                // JPEG 2000 Lossy
                CodecRegistry.Register(new Jpeg2000.Jpeg2000LossyCodec());

                _initialized = true;
            }
        }

        /// <summary>
        /// Module initializer that automatically registers codecs when the assembly loads.
        /// </summary>
        /// <remarks>
        /// This runs automatically in non-AOT scenarios. For AOT, call RegisterAll() explicitly.
        /// </remarks>
#if NET5_0_OR_GREATER
        [ModuleInitializer]
#endif
        internal static void Initialize()
        {
            RegisterAll();
        }

        /// <summary>
        /// Gets a value indicating whether codecs have been registered.
        /// </summary>
        public static bool IsInitialized
        {
            get
            {
                lock (_lock)
                {
                    return _initialized;
                }
            }
        }

        /// <summary>
        /// Resets the registration state. For testing purposes only.
        /// </summary>
        internal static void Reset()
        {
            lock (_lock)
            {
                _initialized = false;
            }
            CodecRegistry.Reset();
        }
    }
}
```

For netstandard2.0 (no ModuleInitializer), the static constructor pattern:

```csharp
#if !NET5_0_OR_GREATER
    // For older targets, use a static class that triggers on first access
    static CodecInitializer()
    {
        // Will be called when any member of this class is accessed
    }
#endif
```

Note: ModuleInitializer attribute requires .NET 5+. For netstandard2.0, users must call RegisterAll() explicitly or access a codec type to trigger the static constructor.
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds on all target frameworks</verify>
  <done>CodecInitializer.RegisterAll() registers all codecs without reflection, ModuleInitializer auto-registers on .NET 5+</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive codec tests</name>
  <files>
    tests/SharpDicom.Tests/Codecs/Jpeg2000CodecTests.cs
    tests/SharpDicom.Tests/Codecs/CodecRegistryIntegrationTests.cs
  </files>
  <action>
**Jpeg2000CodecTests.cs**:

```csharp
[TestFixture]
public class Jpeg2000CodecTests
{
    [Test]
    public void Jpeg2000Lossless_Capabilities_IndicatesLossless()
    {
        var codec = new Jpeg2000LosslessCodec();
        Assert.That(codec.Capabilities.IsLossy, Is.False);
        Assert.That(codec.TransferSyntax.UID.Value, Is.EqualTo("1.2.840.10008.1.2.4.90"));
    }

    [Test]
    public void Jpeg2000Lossy_Capabilities_IndicatesLossy()
    {
        var codec = new Jpeg2000LossyCodec();
        Assert.That(codec.Capabilities.IsLossy, Is.True);
        Assert.That(codec.TransferSyntax.UID.Value, Is.EqualTo("1.2.840.10008.1.2.4.91"));
    }

    [Test]
    public void Jpeg2000Lossless_EncodeAndDecode_Grayscale8_BitPerfect()
    {
        var codec = new Jpeg2000LosslessCodec();
        var info = PixelDataInfo.Grayscale8(32, 32);
        var original = CreateGradientImage(32, 32);

        var fragments = codec.Encode(original, info);
        var decoded = new byte[original.Length];
        var result = codec.Decode(fragments, info, 0, decoded);

        Assert.That(result.Success, Is.True);
        Assert.That(decoded, Is.EqualTo(original), "Lossless J2K must be bit-perfect");
    }

    [Test]
    public void Jpeg2000Lossless_EncodeAndDecode_Grayscale16_BitPerfect()
    {
        var codec = new Jpeg2000LosslessCodec();
        var info = PixelDataInfo.Grayscale16(32, 32);
        var original = CreateGradient16Image(32, 32);

        var fragments = codec.Encode(original, info);
        var decoded = new byte[original.Length];
        var result = codec.Decode(fragments, info, 0, decoded);

        Assert.That(result.Success, Is.True);
        Assert.That(decoded, Is.EqualTo(original));
    }

    [Test]
    public void Jpeg2000Lossy_EncodeAndDecode_ProducesValidOutput()
    {
        var codec = new Jpeg2000LossyCodec();
        var info = PixelDataInfo.Grayscale8(32, 32);
        var original = CreateGradientImage(32, 32);

        var fragments = codec.Encode(original, info);
        var decoded = new byte[original.Length];
        var result = codec.Decode(fragments, info, 0, decoded);

        Assert.That(result.Success, Is.True);
        // Lossy: check approximate equality
        double mse = CalculateMSE(original, decoded);
        Assert.That(mse, Is.LessThan(100), "MSE should be reasonable for lossy compression");
    }

    private static byte[] CreateGradientImage(int width, int height)
    {
        var data = new byte[width * height];
        for (int i = 0; i < data.Length; i++)
            data[i] = (byte)(i % 256);
        return data;
    }

    private static byte[] CreateGradient16Image(int width, int height)
    {
        var data = new byte[width * height * 2];
        for (int i = 0; i < width * height; i++)
        {
            ushort value = (ushort)(i % 65536);
            data[i * 2] = (byte)(value & 0xFF);
            data[i * 2 + 1] = (byte)(value >> 8);
        }
        return data;
    }

    private static double CalculateMSE(byte[] a, byte[] b)
    {
        double sum = 0;
        for (int i = 0; i < a.Length; i++)
        {
            double diff = a[i] - b[i];
            sum += diff * diff;
        }
        return sum / a.Length;
    }
}
```

**CodecRegistryIntegrationTests.cs**:

```csharp
[TestFixture]
public class CodecRegistryIntegrationTests
{
    [SetUp]
    public void Setup()
    {
        CodecInitializer.Reset();
    }

    [Test]
    public void RegisterAll_RegistersAllBuiltInCodecs()
    {
        CodecInitializer.RegisterAll();

        Assert.That(CodecRegistry.GetCodec(TransferSyntax.RLELossless), Is.Not.Null);
        Assert.That(CodecRegistry.GetCodec(TransferSyntax.JPEGBaseline), Is.Not.Null);
        Assert.That(CodecRegistry.GetCodec(TransferSyntax.JPEGLossless), Is.Not.Null);
        Assert.That(CodecRegistry.GetCodec(TransferSyntax.JPEG2000Lossless), Is.Not.Null);
        Assert.That(CodecRegistry.GetCodec(TransferSyntax.JPEG2000Lossy), Is.Not.Null);
    }

    [Test]
    public void GetCodec_ReturnsCorrectCodecType()
    {
        CodecInitializer.RegisterAll();

        Assert.That(CodecRegistry.GetCodec(TransferSyntax.JPEGBaseline), Is.InstanceOf<JpegBaselineCodec>());
        Assert.That(CodecRegistry.GetCodec(TransferSyntax.JPEGLossless), Is.InstanceOf<JpegLosslessCodec>());
        Assert.That(CodecRegistry.GetCodec(TransferSyntax.JPEG2000Lossless), Is.InstanceOf<Jpeg2000LosslessCodec>());
    }

    [Test]
    public void CanDecode_ReturnsTrueForRegisteredCodecs()
    {
        CodecInitializer.RegisterAll();

        Assert.That(CodecRegistry.CanDecode(TransferSyntax.JPEGBaseline), Is.True);
        Assert.That(CodecRegistry.CanDecode(TransferSyntax.JPEGLossless), Is.True);
        Assert.That(CodecRegistry.CanDecode(TransferSyntax.JPEG2000Lossless), Is.True);
        Assert.That(CodecRegistry.CanDecode(TransferSyntax.JPEG2000Lossy), Is.True);
    }

    [Test]
    public void CanEncode_ReturnsTrueForRegisteredCodecs()
    {
        CodecInitializer.RegisterAll();

        Assert.That(CodecRegistry.CanEncode(TransferSyntax.JPEGBaseline), Is.True);
        Assert.That(CodecRegistry.CanEncode(TransferSyntax.JPEGLossless), Is.True);
        Assert.That(CodecRegistry.CanEncode(TransferSyntax.JPEG2000Lossless), Is.True);
        Assert.That(CodecRegistry.CanEncode(TransferSyntax.JPEG2000Lossy), Is.True);
    }

    [Test]
    public void GetRegisteredTransferSyntaxes_IncludesAllCodecs()
    {
        CodecInitializer.RegisterAll();

        var syntaxes = CodecRegistry.GetRegisteredTransferSyntaxes();

        Assert.That(syntaxes, Contains.Item(TransferSyntax.RLELossless));
        Assert.That(syntaxes, Contains.Item(TransferSyntax.JPEGBaseline));
        Assert.That(syntaxes, Contains.Item(TransferSyntax.JPEGLossless));
        Assert.That(syntaxes, Contains.Item(TransferSyntax.JPEG2000Lossless));
        Assert.That(syntaxes, Contains.Item(TransferSyntax.JPEG2000Lossy));
    }
}
```
  </action>
  <verify>`dotnet test tests/SharpDicom.Tests --filter "FullyQualifiedName~Jpeg2000CodecTests or FullyQualifiedName~CodecRegistryIntegrationTests"` passes</verify>
  <done>All codec tests pass including roundtrip tests and registry integration tests</done>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds for entire solution
2. `dotnet test` passes all tests including new codec tests
3. All 5 codecs registered via CodecInitializer.RegisterAll()
4. Lossless codecs (RLE, JPEG Lossless, J2K Lossless) produce bit-perfect roundtrips
5. Lossy codecs (JPEG Baseline, J2K Lossy) produce valid compressed output
6. No AOT/trimming warnings when building with `<IsAotCompatible>true</IsAotCompatible>`
</verification>

<success_criteria>
- CodecInitializer.RegisterAll() registers 5 codecs
- CodecRegistry.GetCodec(TransferSyntax.JPEG2000Lossless) returns Jpeg2000LosslessCodec
- Jpeg2000LosslessCodec.Capabilities.IsLossy is false
- Jpeg2000LossyCodec.Capabilities.IsLossy is true
- J2K Lossless 32x32 grayscale roundtrip is bit-perfect
- All tests pass on netstandard2.0, net8.0, and net9.0
</success_criteria>

<output>
After completion, create `.planning/phases/12-pure-csharp-codecs/12-07-SUMMARY.md`
</output>
