---
phase: 12-pure-csharp-codecs
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SharpDicom/Codecs/Jpeg/DctTransform.cs
  - src/SharpDicom/Codecs/Jpeg/BitReader.cs
  - src/SharpDicom/Codecs/Jpeg/BitWriter.cs
  - src/SharpDicom/Codecs/Jpeg/JpegCodecOptions.cs
autonomous: true

must_haves:
  truths:
    - "DCT transform produces correct 8x8 frequency domain coefficients"
    - "IDCT transform reconstructs spatial domain from DCT coefficients"
    - "BitReader can extract variable-length bits from JPEG bitstream"
    - "BitWriter can emit variable-length bits for JPEG encoding"
  artifacts:
    - path: "src/SharpDicom/Codecs/Jpeg/DctTransform.cs"
      provides: "8x8 DCT and IDCT transformations"
      exports: ["DctTransform"]
    - path: "src/SharpDicom/Codecs/Jpeg/BitReader.cs"
      provides: "Variable-length bit reading"
      exports: ["BitReader"]
    - path: "src/SharpDicom/Codecs/Jpeg/BitWriter.cs"
      provides: "Variable-length bit writing"
      exports: ["BitWriter"]
  key_links:
    - from: "DctTransform.cs"
      to: "AAN algorithm"
      via: "fast DCT"
      pattern: "0\\.98078|cos.*pi"
---

<objective>
Implement DCT transforms and bit-level I/O required for JPEG baseline encoding and decoding.

Purpose: The 8x8 DCT is the core of JPEG baseline compression. BitReader/BitWriter handle the variable-length Huffman-coded bitstream. These are compute-intensive hot paths.
Output: DctTransform (forward/inverse), BitReader, BitWriter ref structs for efficient bit manipulation.
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-pure-csharp-codecs/12-RESEARCH.md
@src/SharpDicom/Codecs/Rle/RleEncoder.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement 8x8 DCT and IDCT transforms</name>
  <files>src/SharpDicom/Codecs/Jpeg/DctTransform.cs</files>
  <action>
Create DctTransform.cs with forward and inverse 8x8 DCT implementations:

```csharp
public static class DctTransform
{
    /// <summary>
    /// Performs forward 8x8 DCT on a block (in-place).
    /// </summary>
    /// <param name="block">64-element float array representing 8x8 block in row-major order.</param>
    public static void Forward(Span<float> block);

    /// <summary>
    /// Performs inverse 8x8 DCT on a block (in-place).
    /// </summary>
    /// <param name="block">64-element float array of DCT coefficients.</param>
    public static void Inverse(Span<float> block);
}
```

Implementation approach (per RESEARCH.md):
1. Use separable 2D DCT: process rows, then columns
2. Implement 1D DCT using AAN algorithm (Arai, Agui, Nakajima) or Loeffler algorithm
3. AAN is slightly faster; Loeffler produces exactly scaled results

Constants needed (cosine values):
```csharp
private const float C1 = 0.980785280f; // cos(1*pi/16)
private const float C2 = 0.923879533f; // cos(2*pi/16)
private const float C3 = 0.831469612f; // cos(3*pi/16)
private const float C5 = 0.555570233f; // cos(5*pi/16)
private const float C6 = 0.382683432f; // cos(6*pi/16)
private const float C7 = 0.195090322f; // cos(7*pi/16)
```

For .NET 8+, include a SIMD-accelerated path using Vector256 for processing multiple rows in parallel:

```csharp
#if NET8_0_OR_GREATER
private static void ForwardSimd(Span<float> block)
{
    if (Avx2.IsSupported)
    {
        // Process 8 values at once using AVX2
    }
}
#endif
```

Include scalar fallback for all platforms.

Apply the DCT normalization factor: multiply by 0.125 (1/8) for forward DCT, or handle scaling in quantization.
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>DctTransform.Forward and DctTransform.Inverse compile and can be called with 64-element float spans</done>
</task>

<task type="auto">
  <name>Task 2: Implement BitReader for Huffman decoding</name>
  <files>src/SharpDicom/Codecs/Jpeg/BitReader.cs</files>
  <action>
Create BitReader.cs as a ref struct for efficient bit-level reading from JPEG bitstreams:

```csharp
/// <summary>
/// Reads variable-length bit sequences from a JPEG bitstream.
/// </summary>
/// <remarks>
/// Handles JPEG byte stuffing: 0xFF bytes are followed by 0x00 (which is skipped).
/// Marker bytes (0xFF followed by non-zero) indicate end of scan data.
/// </remarks>
public ref struct BitReader
{
    private readonly ReadOnlySpan<byte> _data;
    private int _bytePosition;
    private int _bitPosition;  // 0-7, bits remaining in current byte
    private uint _buffer;      // Bit buffer for efficient reading

    public BitReader(ReadOnlySpan<byte> data);

    /// <summary>
    /// Gets the current byte position in the stream.
    /// </summary>
    public int BytePosition => _bytePosition;

    /// <summary>
    /// Reads the specified number of bits (1-16) from the stream.
    /// </summary>
    public int ReadBits(int count);

    /// <summary>
    /// Peeks at the next bits without advancing the position.
    /// </summary>
    public int PeekBits(int count);

    /// <summary>
    /// Skips the specified number of bits.
    /// </summary>
    public void SkipBits(int count);

    /// <summary>
    /// Reads a single bit.
    /// </summary>
    public int ReadBit();

    /// <summary>
    /// Aligns to the next byte boundary.
    /// </summary>
    public void AlignToByte();

    /// <summary>
    /// Returns true if there are no more bits available.
    /// </summary>
    public bool IsEmpty { get; }

    /// <summary>
    /// Refills the internal bit buffer from the byte stream.
    /// </summary>
    private void Refill();
}
```

Critical JPEG byte stuffing handling:
- When reading, if byte is 0xFF, check next byte
- If next byte is 0x00, skip it (stuffed byte) and use 0xFF
- If next byte is non-zero, it's a marker - stop reading

Use a 32-bit or 64-bit buffer for efficient multi-bit reads. Refill when buffer has fewer than 16 bits.
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>BitReader can read variable-length bits and handles JPEG byte stuffing (0xFF 0x00 sequences)</done>
</task>

<task type="auto">
  <name>Task 3: Implement BitWriter and JpegCodecOptions</name>
  <files>
    src/SharpDicom/Codecs/Jpeg/BitWriter.cs
    src/SharpDicom/Codecs/Jpeg/JpegCodecOptions.cs
  </files>
  <action>
**BitWriter.cs** - Complement to BitReader for encoding:

```csharp
/// <summary>
/// Writes variable-length bit sequences to a JPEG bitstream.
/// </summary>
public ref struct BitWriter
{
    private readonly Span<byte> _output;
    private int _bytePosition;
    private int _bitPosition;  // 0-7, bits filled in current byte
    private uint _buffer;

    public BitWriter(Span<byte> output);

    /// <summary>
    /// Gets the number of bytes written.
    /// </summary>
    public int BytesWritten { get; }

    /// <summary>
    /// Writes the specified number of bits (1-16).
    /// </summary>
    public void WriteBits(int value, int count);

    /// <summary>
    /// Writes a single bit.
    /// </summary>
    public void WriteBit(int bit);

    /// <summary>
    /// Flushes any remaining bits, padding with 1s.
    /// </summary>
    public void Flush();
}
```

Byte stuffing on write:
- After writing 0xFF, insert 0x00 to prevent accidental marker sequences

**JpegCodecOptions.cs** - Codec configuration:

```csharp
/// <summary>
/// Options for JPEG baseline encoding.
/// </summary>
public sealed class JpegCodecOptions
{
    /// <summary>
    /// Gets or sets the quality level (1-100, default 75).
    /// </summary>
    /// <remarks>
    /// Quality affects quantization table scaling. Higher = less compression, better quality.
    /// For medical imaging, consider using 90-95 (conservative lossy per CONTEXT.md).
    /// </remarks>
    public int Quality { get; set; } = 75;

    /// <summary>
    /// Gets or sets the chroma subsampling mode.
    /// </summary>
    /// <remarks>
    /// Default is None (4:4:4) for medical imaging quality.
    /// 4:2:2 and 4:2:0 provide better compression but may lose fine color details.
    /// </remarks>
    public ChromaSubsampling Subsampling { get; set; } = ChromaSubsampling.None;

    /// <summary>
    /// Gets or sets whether to generate JFIF APP0 marker.
    /// </summary>
    public bool IncludeJfifMarker { get; set; } = false;

    /// <summary>
    /// Gets or sets whether to generate optimized Huffman tables.
    /// </summary>
    /// <remarks>
    /// True = scan image and build optimal tables (slower, better compression).
    /// False = use standard tables from ITU-T.81 Annex K (faster).
    /// </remarks>
    public bool OptimizeHuffmanTables { get; set; } = false;

    /// <summary>
    /// Default options for medical imaging (quality 90, no subsampling).
    /// </summary>
    public static JpegCodecOptions MedicalImaging { get; } = new() { Quality = 90, Subsampling = ChromaSubsampling.None };

    /// <summary>
    /// Default options (quality 75, no subsampling).
    /// </summary>
    public static JpegCodecOptions Default { get; } = new();
}

/// <summary>
/// Chroma subsampling modes for JPEG encoding.
/// </summary>
public enum ChromaSubsampling
{
    /// <summary>No subsampling (4:4:4) - full color resolution.</summary>
    None,
    /// <summary>Horizontal 2:1 subsampling (4:2:2).</summary>
    Horizontal,
    /// <summary>Horizontal and vertical 2:1 subsampling (4:2:0).</summary>
    Both
}
```
  </action>
  <verify>`dotnet build src/SharpDicom` succeeds</verify>
  <done>BitWriter can emit variable-length bits with byte stuffing, JpegCodecOptions provides quality and subsampling settings</done>
</task>

</tasks>

<verification>
1. `dotnet build src/SharpDicom` compiles without warnings
2. `dotnet test tests/SharpDicom.Tests` passes all existing tests
3. DctTransform.Forward followed by DctTransform.Inverse produces approximately original values (within floating-point tolerance)
4. BitReader can read bits from a test sequence with byte stuffing
5. BitWriter output matches expected byte sequence for known bit patterns
</verification>

<success_criteria>
- DCT forward transform of a uniform block produces DC coefficient only (AC coefficients near zero)
- BitReader.ReadBits(8) from [0x12, 0x34] returns 0x12, then 0x34
- BitReader handles [0xFF, 0x00, 0x12] correctly (reads 0xFF, then 0x12)
- BitWriter.WriteBits(0xFF, 8) produces [0xFF, 0x00] due to byte stuffing
- JpegCodecOptions.MedicalImaging.Quality equals 90
</success_criteria>

<output>
After completion, create `.planning/phases/12-pure-csharp-codecs/12-02-SUMMARY.md`
</output>
