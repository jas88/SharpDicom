---
phase: 05-pixel-data
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/SharpDicom/IO/IPixelDataSource.cs
  - src/SharpDicom/IO/ImmediatePixelDataSource.cs
  - src/SharpDicom/IO/LazyPixelDataSource.cs
  - src/SharpDicom/IO/SkippedPixelDataSource.cs
  - src/SharpDicom/Data/DicomPixelDataElement.cs
  - src/SharpDicom/IO/DicomReaderOptions.cs
  - src/SharpDicom/Data/PixelDataContext.cs
  - tests/SharpDicom.Tests/IO/PixelDataSourceTests.cs
  - tests/SharpDicom.Tests/Data/DicomPixelDataElementTests.cs
autonomous: true

must_haves:
  truths:
    - "ImmediatePixelDataSource provides instant access to loaded data"
    - "LazyPixelDataSource loads data from stream on first access"
    - "SkippedPixelDataSource throws on access if stream is disposed"
    - "DicomPixelDataElement provides frame-level access to pixel data"
    - "DicomReaderOptions has PixelDataHandling configuration"
  artifacts:
    - path: "src/SharpDicom/IO/IPixelDataSource.cs"
      provides: "Interface for pixel data source abstraction"
      contains: "interface IPixelDataSource"
    - path: "src/SharpDicom/IO/LazyPixelDataSource.cs"
      provides: "Lazy loading from seekable stream"
      contains: "class LazyPixelDataSource"
    - path: "src/SharpDicom/Data/DicomPixelDataElement.cs"
      provides: "Unified pixel data element wrapper"
      contains: "class DicomPixelDataElement"
    - path: "src/SharpDicom/IO/DicomReaderOptions.cs"
      provides: "Pixel data handling configuration"
      contains: "PixelDataHandling"
  key_links:
    - from: "src/SharpDicom/Data/DicomPixelDataElement.cs"
      to: "src/SharpDicom/IO/IPixelDataSource.cs"
      via: "Uses source for data access"
      pattern: "IPixelDataSource"
    - from: "src/SharpDicom/IO/LazyPixelDataSource.cs"
      to: "System.IO.Stream"
      via: "Reads from stream on demand"
      pattern: "_stream\\.Read"
---

<objective>
Implement lazy loading infrastructure for efficient pixel data handling.

Purpose: Enable configurable pixel data loading strategies - immediate loading for small files, lazy loading for large files, and skip mode for metadata-only use cases. This is critical for performance with large multi-frame datasets.

Output:
- IPixelDataSource interface for data access abstraction
- ImmediatePixelDataSource for data already in memory
- LazyPixelDataSource for deferred loading from seekable streams
- SkippedPixelDataSource for metadata-only mode
- DicomPixelDataElement for unified pixel data access
- Extended DicomReaderOptions with PixelDataHandling
- PixelDataContext for callback decisions
- Unit tests for all sources and element
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pixel-data/05-CONTEXT.md
@.planning/phases/05-pixel-data/05-RESEARCH.md
@.planning/phases/05-pixel-data/05-01-SUMMARY.md

# Key existing files
@src/SharpDicom/IO/DicomReaderOptions.cs
@src/SharpDicom/Data/IDicomElement.cs
@src/SharpDicom/Data/DicomFragmentSequence.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create IPixelDataSource interface and implementations</name>
  <files>
    src/SharpDicom/IO/IPixelDataSource.cs
    src/SharpDicom/IO/ImmediatePixelDataSource.cs
    src/SharpDicom/IO/LazyPixelDataSource.cs
    src/SharpDicom/IO/SkippedPixelDataSource.cs
  </files>
  <action>
1. **Create IPixelDataSource.cs**:
   ```csharp
   public interface IPixelDataSource : IDisposable
   {
       bool IsLoaded { get; }
       long Length { get; }
       PixelDataLoadState State { get; }

       ReadOnlyMemory<byte> GetData();
       ValueTask<ReadOnlyMemory<byte>> GetDataAsync(CancellationToken ct = default);
       ValueTask CopyToAsync(Stream destination, CancellationToken ct = default);

       /// <summary>Create a copy that owns its data (detached from stream).</summary>
       IPixelDataSource ToOwned();
   }
   ```

2. **Create ImmediatePixelDataSource.cs**:
   - Constructor takes `ReadOnlyMemory<byte> data`
   - `IsLoaded` always returns true
   - `State` always returns `PixelDataLoadState.Loaded`
   - `Length` returns data length
   - `GetData()` returns the data directly (no copy)
   - `GetDataAsync()` returns completed ValueTask with data
   - `CopyToAsync()` writes data to stream
   - `ToOwned()` returns self if data is array-backed, otherwise copies
   - `Dispose()` is a no-op (data is owned by caller)

3. **Create LazyPixelDataSource.cs**:
   - Constructor takes `Stream stream, long offset, long length`
   - Store stream reference, offset, and length
   - Private field `ReadOnlyMemory<byte>? _cached` for loaded data
   - Private field `SemaphoreSlim _loadLock = new(1, 1)` for thread safety
   - `IsLoaded` returns `_cached.HasValue`
   - `State` returns NotLoaded, Loading, Loaded, or Failed appropriately
   - `GetData()`:
     - If cached, return cached data
     - Otherwise, call GetDataAsync().GetAwaiter().GetResult() (sync over async is acceptable for this fallback)
   - `GetDataAsync()`:
     - If cached, return cached
     - Acquire lock, check disposed, seek to offset, read length bytes, cache, release lock
     - Handle ObjectDisposedException if stream is disposed
     - Return cached data
   - `CopyToAsync()`:
     - If loaded, write cached data
     - Otherwise, seek and stream directly without caching (for streaming scenarios)
   - `ToOwned()`:
     - Force load if not loaded, return new ImmediatePixelDataSource with copy
   - `Dispose()`:
     - Set disposed flag, release semaphore
     - Do NOT dispose the stream (managed externally)
   - Track disposed state with `_disposed` flag
   - Throw ObjectDisposedException if accessing after dispose

4. **Create SkippedPixelDataSource.cs**:
   - Constructor takes `long offset, long length` (for metadata only)
   - `IsLoaded` always false
   - `State` always `PixelDataLoadState.NotLoaded`
   - `Length` returns stored length
   - `GetData()` throws InvalidOperationException("Pixel data was skipped during parsing. Use ToOwned() on the source DicomFile before disposing the stream.")
   - `GetDataAsync()` throws same exception
   - `CopyToAsync()` throws same exception
   - `ToOwned()` throws same exception (cannot recover skipped data)
   - `Dispose()` is a no-op

All classes in `SharpDicom.IO` namespace.
Use ConfigureAwait(false) on all awaits.
  </action>
  <verify>
    - `dotnet build src/SharpDicom/SharpDicom.csproj` succeeds
    - All three implementations compile without warnings
    - Interface and implementations have XML documentation
  </verify>
  <done>
    - IPixelDataSource interface defined with all methods
    - ImmediatePixelDataSource provides synchronous access to in-memory data
    - LazyPixelDataSource loads from stream with thread-safe locking
    - SkippedPixelDataSource throws descriptive errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DicomPixelDataElement and PixelDataContext</name>
  <files>
    src/SharpDicom/Data/DicomPixelDataElement.cs
    src/SharpDicom/Data/PixelDataContext.cs
  </files>
  <action>
1. **Create PixelDataContext.cs**:
   - Readonly struct for callback context:
   ```csharp
   public readonly struct PixelDataContext
   {
       public ushort? Rows { get; init; }
       public ushort? Columns { get; init; }
       public ushort? BitsAllocated { get; init; }
       public int? NumberOfFrames { get; init; }
       public TransferSyntax TransferSyntax { get; init; }
       public bool IsEncapsulated { get; init; }
       public long ValueLength { get; init; }  // Declared length in element header

       public long? EstimatedSize => (Rows.HasValue && Columns.HasValue &&
           BitsAllocated.HasValue && NumberOfFrames.HasValue)
           ? (long)Rows.Value * Columns.Value * ((BitsAllocated.Value + 7) / 8) * NumberOfFrames.Value
           : null;

       public bool HasImageDimensions => Rows.HasValue && Columns.HasValue;

       public static PixelDataContext FromDataset(DicomDataset dataset, TransferSyntax ts, bool isEncapsulated, long valueLength);
   }
   ```

2. **Create DicomPixelDataElement.cs**:
   - Sealed class implementing IDicomElement
   - Properties:
     - `Tag` always returns DicomTag.PixelData
     - `VR` - OB or OW based on context
     - `RawValue` - returns empty if not loaded, data if loaded
     - `Length` - returns actual length or -1 for undefined
     - `IsEmpty` - based on source
   - Additional properties:
     - `PixelDataInfo Info { get; }` - metadata about the pixel data
     - `PixelDataLoadState LoadState => _source.State`
     - `bool IsEncapsulated { get; }` - true for compressed transfer syntaxes
     - `DicomFragmentSequence? Fragments { get; }` - for encapsulated data
   - Constructor:
     - Takes IPixelDataSource, DicomVR, PixelDataInfo, bool isEncapsulated, DicomFragmentSequence? fragments
   - Methods:
     - `ReadOnlySpan<byte> GetFrameSpan(int frameIndex)`:
       - For native: calculate offset from FrameSize, return slice
       - For encapsulated: throw NotSupportedException("Use Fragments property for encapsulated data")
     - `T[] GetFrame<T>(int frameIndex) where T : unmanaged`:
       - Get frame span, cast to T[] (MemoryMarshal.Cast)
       - Validate frame index against NumberOfFrames
     - `ValueTask<ReadOnlyMemory<byte>> LoadAsync(CancellationToken ct = default)`:
       - Delegate to source.GetDataAsync()
     - `ValueTask CopyToAsync(Stream destination, CancellationToken ct = default)`:
       - Delegate to source.CopyToAsync()
   - `ToOwned()`:
     - Create new DicomPixelDataElement with source.ToOwned()
     - Copy all metadata

   Handle null Info.NumberOfFrames by defaulting to 1.
   Validate frame index in GetFrameSpan/GetFrame.
  </action>
  <verify>
    - `dotnet build src/SharpDicom/SharpDicom.csproj` succeeds
    - DicomPixelDataElement implements IDicomElement correctly
    - PixelDataContext.FromDataset compiles
  </verify>
  <done>
    - PixelDataContext provides callback context with estimated size
    - DicomPixelDataElement wraps pixel data with frame-level access
    - Both native and encapsulated pixel data are supported
    - ToOwned() creates independent copy
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend DicomReaderOptions and create tests</name>
  <files>
    src/SharpDicom/IO/DicomReaderOptions.cs
    tests/SharpDicom.Tests/IO/PixelDataSourceTests.cs
    tests/SharpDicom.Tests/Data/DicomPixelDataElementTests.cs
  </files>
  <action>
1. **Extend DicomReaderOptions.cs**:
   Add the following properties:
   ```csharp
   /// <summary>How to handle pixel data during parsing.</summary>
   public PixelDataHandling PixelDataHandling { get; init; } = PixelDataHandling.LoadInMemory;

   /// <summary>
   /// Callback to determine pixel data handling per instance.
   /// Only called when PixelDataHandling is Callback.
   /// </summary>
   public Func<PixelDataContext, PixelDataHandling>? PixelDataCallback { get; init; }

   /// <summary>
   /// Directory for temporary files when buffering non-seekable streams.
   /// Defaults to system temp directory if null.
   /// </summary>
   public string? TempDirectory { get; init; }
   ```

   Add using statement for SharpDicom.Data at top of file.

   Update the preset instances (Strict, Lenient, Permissive) to include PixelDataHandling = PixelDataHandling.LoadInMemory (keep current behavior).

2. **Create PixelDataSourceTests.cs**:
   - Test ImmediatePixelDataSource:
     - GetData returns provided data
     - IsLoaded is always true
     - CopyToAsync writes to stream
     - ToOwned returns equivalent source
   - Test LazyPixelDataSource:
     - Create with MemoryStream containing test data
     - GetData returns correct data after seek
     - Multiple GetData calls return same cached data
     - CopyToAsync works for both loaded and unloaded state
     - Thread-safe concurrent access (use Task.WhenAll with multiple GetDataAsync)
     - After Dispose, GetData throws ObjectDisposedException
   - Test SkippedPixelDataSource:
     - GetData throws InvalidOperationException
     - GetDataAsync throws InvalidOperationException
     - ToOwned throws InvalidOperationException
     - Length returns stored value

3. **Create DicomPixelDataElementTests.cs**:
   - Test with native pixel data:
     - Create 4x4 8-bit image (16 bytes)
     - GetFrameSpan(0) returns all bytes
     - GetFrame<byte>(0) returns byte array
   - Test with multi-frame native:
     - Create 2 frames of 4x4 8-bit (32 bytes total)
     - GetFrameSpan(0) returns first 16 bytes
     - GetFrameSpan(1) returns second 16 bytes
     - GetFrameSpan(2) throws ArgumentOutOfRangeException
   - Test with 16-bit data:
     - Create 4x4 16-bit image (32 bytes)
     - GetFrame<ushort>(0) returns ushort array
   - Test IsEncapsulated property:
     - Native data returns false
     - Encapsulated returns true with Fragments
   - Test ToOwned creates independent copy

Use NUnit with [Test] and [TestCase] attributes.
  </action>
  <verify>
    - `dotnet build` succeeds for entire solution
    - `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~PixelDataSource|FullyQualifiedName~DicomPixelDataElement"` passes
    - All edge cases covered
  </verify>
  <done>
    - DicomReaderOptions extended with pixel data configuration
    - PixelDataSourceTests covers all three source types
    - DicomPixelDataElementTests covers frame access and multi-frame
    - Thread safety tested for LazyPixelDataSource
    - All tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `dotnet build` succeeds for entire solution
2. `dotnet test` passes all tests including new ones
3. ImmediatePixelDataSource provides O(1) data access
4. LazyPixelDataSource correctly seeks and reads from stream
5. SkippedPixelDataSource fails fast with helpful error message
6. DicomPixelDataElement provides frame-level access to native data
7. Thread safety verified for concurrent access
</verification>

<success_criteria>
- IPixelDataSource provides clean abstraction for data access
- LazyPixelDataSource correctly loads data on demand with thread safety
- SkippedPixelDataSource throws descriptive errors
- DicomPixelDataElement.GetFrameSpan returns correct frame slice
- DicomPixelDataElement.GetFrame<T> returns correctly typed array
- DicomReaderOptions.PixelDataHandling configures loading behavior
- PixelDataContext.EstimatedSize correctly calculates size
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-pixel-data/05-02-SUMMARY.md`
</output>
