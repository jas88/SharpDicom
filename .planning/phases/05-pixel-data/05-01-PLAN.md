---
phase: 05-pixel-data
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/SharpDicom/Data/PixelDataInfo.cs
  - src/SharpDicom/Data/PixelDataHandling.cs
  - src/SharpDicom/Data/PixelDataLoadState.cs
  - src/SharpDicom/Data/DicomFragmentSequence.cs
  - src/SharpDicom/Data/DicomTag.WellKnown.cs
  - src/SharpDicom/IO/FragmentParser.cs
  - tests/SharpDicom.Tests/Data/PixelDataInfoTests.cs
  - tests/SharpDicom.Tests/IO/FragmentParserTests.cs
autonomous: true

must_haves:
  truths:
    - "PixelDataInfo correctly calculates frame size from image dimensions"
    - "PixelDataInfo correctly calculates total pixel data size"
    - "DicomFragmentSequence stores offset table and fragments"
    - "FragmentParser parses encapsulated pixel data with Item tags"
    - "FragmentParser handles empty Basic Offset Table"
  artifacts:
    - path: "src/SharpDicom/Data/PixelDataInfo.cs"
      provides: "Pixel data metadata struct with frame size calculation"
      contains: "FrameSize"
    - path: "src/SharpDicom/Data/PixelDataHandling.cs"
      provides: "Enum for pixel data loading strategies"
      contains: "enum PixelDataHandling"
    - path: "src/SharpDicom/Data/PixelDataLoadState.cs"
      provides: "Enum for pixel data load state tracking"
      contains: "enum PixelDataLoadState"
    - path: "src/SharpDicom/IO/FragmentParser.cs"
      provides: "Parser for encapsulated pixel data fragments"
      contains: "ParseEncapsulated"
  key_links:
    - from: "src/SharpDicom/IO/FragmentParser.cs"
      to: "src/SharpDicom/Data/DicomFragmentSequence.cs"
      via: "Creates fragment sequence from parsed data"
      pattern: "new DicomFragmentSequence"
    - from: "src/SharpDicom/Data/PixelDataInfo.cs"
      to: "src/SharpDicom/Data/DicomDataset.cs"
      via: "FromDataset static method"
      pattern: "FromDataset.*DicomDataset"
---

<objective>
Create the core pixel data types needed for handling both native and encapsulated pixel data.

Purpose: Establish the data model for pixel data metadata, loading strategies, and fragment sequences. This provides the foundation for lazy loading and integration with DicomFileReader.

Output:
- PixelDataInfo struct with frame size calculation
- PixelDataHandling enum (LoadInMemory, LazyLoad, Skip, Callback)
- PixelDataLoadState enum (NotLoaded, Loading, Loaded, Failed)
- Extended DicomFragmentSequence with offset table parsing
- FragmentParser for encapsulated pixel data
- Unit tests for all new types
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pixel-data/05-CONTEXT.md
@.planning/phases/05-pixel-data/05-RESEARCH.md

# Key existing files
@src/SharpDicom/Data/DicomFragmentSequence.cs
@src/SharpDicom/Data/DicomDataset.cs
@src/SharpDicom/Data/DicomTag.WellKnown.cs
@src/SharpDicom/Data/IDicomElement.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pixel data enums and metadata struct</name>
  <files>
    src/SharpDicom/Data/PixelDataHandling.cs
    src/SharpDicom/Data/PixelDataLoadState.cs
    src/SharpDicom/Data/PixelDataInfo.cs
    src/SharpDicom/Data/DicomTag.WellKnown.cs
  </files>
  <action>
Create three new files for pixel data types:

1. **PixelDataHandling.cs** - Enum for loading strategies:
   - `LoadInMemory` - Load pixel data into memory immediately during file parse
   - `LazyLoad` - Keep stream reference, load on first access (requires seekable stream)
   - `Skip` - Skip pixel data entirely (metadata-only use case)
   - `Callback` - Let callback decide per-instance based on context

2. **PixelDataLoadState.cs** - Enum for tracking load state:
   - `NotLoaded` - Skipped during initial parse
   - `Loading` - Async load in progress
   - `Loaded` - Data available in memory
   - `Failed` - Load failed, error stored

3. **PixelDataInfo.cs** - Readonly struct with:
   - Properties: Rows, Columns, BitsAllocated, BitsStored, HighBit, SamplesPerPixel, NumberOfFrames, PlanarConfiguration, PixelRepresentation (all nullable ushort/int to handle missing tags)
   - Computed properties:
     - `BytesPerSample => (BitsAllocated.GetValueOrDefault(16) + 7) / 8`
     - `FrameSize => Rows * Columns * SamplesPerPixel * BytesPerSample` (returns null if any dimension missing)
     - `TotalSize => FrameSize * NumberOfFrames` (returns null if cannot compute)
   - Static method: `FromDataset(DicomDataset dataset)` that extracts values from dataset
   - Use init properties for creation

4. **Update DicomTag.WellKnown.cs** - Add missing pixel data tags:
   - Rows (0028,0010)
   - Columns (0028,0011)
   - BitsStored (0028,0101)
   - HighBit (0028,0102)
   - SamplesPerPixel (0028,0002)
   - NumberOfFrames (0028,0008)
   - PlanarConfiguration (0028,0006)
   - PhotometricInterpretation (0028,0004)
   - ExtendedOffsetTable (7FE0,0001)
   - ExtendedOffsetTableLengths (7FE0,0002)

Add XML documentation comments to all public members.
  </action>
  <verify>
    - `dotnet build src/SharpDicom/SharpDicom.csproj` succeeds with no warnings
    - New files exist with correct namespaces
    - PixelDataInfo.FromDataset compiles and is callable
  </verify>
  <done>
    - PixelDataHandling enum has 4 values with XML docs
    - PixelDataLoadState enum has 4 values with XML docs
    - PixelDataInfo struct has all properties and computed members
    - DicomTag.WellKnown.cs has all 10 new tag constants
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance DicomFragmentSequence and create FragmentParser</name>
  <files>
    src/SharpDicom/Data/DicomFragmentSequence.cs
    src/SharpDicom/IO/FragmentParser.cs
  </files>
  <action>
1. **Enhance DicomFragmentSequence.cs**:
   - Add `ParsedBasicOffsets` property (`IReadOnlyList<uint>`) - parsed 32-bit offsets from Basic Offset Table
   - Add `ParsedExtendedOffsets` property (`IReadOnlyList<ulong>?`) - parsed 64-bit offsets (null if not present)
   - Add `ParsedExtendedLengths` property (`IReadOnlyList<ulong>?`) - parsed lengths (null if not present)
   - Add `ExtendedOffsetTable` property (`ReadOnlyMemory<byte>`)
   - Add `ExtendedOffsetTableLengths` property (`ReadOnlyMemory<byte>`)
   - Add computed `FragmentCount => Fragments.Count`
   - Add computed `TotalSize => Fragments.Sum(f => (long)f.Length)`
   - Add static `ParseBasicOffsetTable(ReadOnlySpan<byte>)` method returning `uint[]`
   - Add static `ParseExtendedOffsetTable(ReadOnlySpan<byte>)` method returning `ulong[]`
   - Update constructor to accept all new parameters
   - Update ToOwned() to copy all new properties

2. **Create FragmentParser.cs** in `SharpDicom.IO` namespace:
   - Static class with parsing methods
   - `ParseEncapsulated(ReadOnlySpan<byte> data, DicomTag tag, DicomVR vr, bool littleEndian)` method:
     - Expects data starting AFTER the tag/VR/length header (first byte is Item tag of BOT)
     - Parse Item tags (FFFE,E000) and Sequence Delimitation (FFFE,E0DD)
     - First Item is always Basic Offset Table (may be empty with length 0)
     - Remaining Items are fragments
     - Return DicomFragmentSequence
   - Handle both little endian and big endian (use littleEndian parameter)
   - Throw DicomDataException with descriptive message on malformed data
   - Use BinaryPrimitives for safe endian-aware reading

Constants to use:
- Item tag: 0xFFFE_E000
- Sequence Delimitation tag: 0xFFFE_E0DD
- Undefined length marker: 0xFFFFFFFF
  </action>
  <verify>
    - `dotnet build src/SharpDicom/SharpDicom.csproj` succeeds
    - DicomFragmentSequence has all new properties
    - FragmentParser.ParseEncapsulated compiles
  </verify>
  <done>
    - DicomFragmentSequence extended with offset table parsing
    - FragmentParser handles encapsulated pixel data structure
    - Both little endian and big endian supported
    - ToOwned() copies all new properties
  </done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for pixel data types</name>
  <files>
    tests/SharpDicom.Tests/Data/PixelDataInfoTests.cs
    tests/SharpDicom.Tests/IO/FragmentParserTests.cs
  </files>
  <action>
1. **Create PixelDataInfoTests.cs**:
   - Test FrameSize calculation for various image dimensions:
     - 512x512 8-bit grayscale (256 KB)
     - 512x512 16-bit grayscale (512 KB)
     - 512x512 RGB 8-bit (768 KB = 512*512*3)
     - Null dimensions return null FrameSize
   - Test TotalSize calculation for multi-frame:
     - 10 frames of 256 KB each = 2.5 MB
   - Test BytesPerSample calculation:
     - BitsAllocated=8 -> 1
     - BitsAllocated=12 -> 2 (rounds up)
     - BitsAllocated=16 -> 2
   - Test FromDataset extracts values correctly
   - Test FromDataset handles missing tags gracefully (returns null properties)

2. **Create FragmentParserTests.cs**:
   - Test parsing single fragment with empty BOT:
     - BOT Item (length 0) + one data Item + Sequence Delimitation
   - Test parsing multiple fragments with BOT:
     - BOT Item with offsets + multiple data Items + Sequence Delimitation
   - Test empty Basic Offset Table is valid (length 0)
   - Test Basic Offset Table parsing:
     - Parse 4 offsets: 0, 1000, 2000, 3000
   - Test Extended Offset Table parsing:
     - Parse 64-bit offsets
   - Test error case: missing Sequence Delimitation
   - Test error case: unexpected tag in fragment stream

Use NUnit with [Test] and [TestCase] attributes.
Create test data as byte arrays using BinaryPrimitives to write tags/lengths.
  </action>
  <verify>
    - `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~PixelData|FullyQualifiedName~FragmentParser"` passes
    - All test cases cover expected scenarios
    - Tests compile and run without errors
  </verify>
  <done>
    - PixelDataInfoTests covers frame size, total size, and FromDataset
    - FragmentParserTests covers single/multiple fragments, empty BOT, error cases
    - All tests pass across all target frameworks
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `dotnet build` succeeds for entire solution
2. `dotnet test` passes all tests including new ones
3. New types are accessible from test project
4. Frame size calculations are mathematically correct
5. Fragment parsing handles DICOM structure correctly
</verification>

<success_criteria>
- PixelDataInfo.FrameSize correctly calculates: Rows * Columns * SamplesPerPixel * BytesPerSample
- PixelDataInfo.FromDataset extracts all relevant tags from a DicomDataset
- DicomFragmentSequence stores and parses Basic Offset Table
- FragmentParser.ParseEncapsulated correctly identifies fragments and BOT
- All new unit tests pass
- No compiler warnings on any target framework
</success_criteria>

<output>
After completion, create `.planning/phases/05-pixel-data/05-01-SUMMARY.md`
</output>
