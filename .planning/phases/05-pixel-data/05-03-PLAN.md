---
phase: 05-pixel-data
plan: 03
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - src/SharpDicom/IO/DicomFileReader.cs
  - src/SharpDicom/DicomFile.cs
  - src/SharpDicom/Data/DicomDataset.cs
  - tests/SharpDicom.Tests/IO/DicomFileReaderPixelDataTests.cs
  - tests/SharpDicom.Tests/DicomFilePixelDataTests.cs
autonomous: true

must_haves:
  truths:
    - "DicomFileReader respects PixelDataHandling option"
    - "Lazy loading defers pixel data read until accessed"
    - "Skip mode creates DicomPixelDataElement with SkippedPixelDataSource"
    - "Multi-frame datasets load correctly"
    - "DicomFile provides convenient pixel data access"
  artifacts:
    - path: "src/SharpDicom/IO/DicomFileReader.cs"
      provides: "Pixel data handling during file parsing"
      contains: "PixelDataHandling"
    - path: "src/SharpDicom/DicomFile.cs"
      provides: "High-level pixel data access"
      contains: "PixelData"
    - path: "src/SharpDicom/Data/DicomDataset.cs"
      provides: "GetPixelData accessor method"
      contains: "GetPixelData"
  key_links:
    - from: "src/SharpDicom/IO/DicomFileReader.cs"
      to: "src/SharpDicom/IO/FragmentParser.cs"
      via: "Parses encapsulated pixel data"
      pattern: "FragmentParser\\.ParseEncapsulated"
    - from: "src/SharpDicom/IO/DicomFileReader.cs"
      to: "src/SharpDicom/Data/DicomPixelDataElement.cs"
      via: "Creates pixel data element"
      pattern: "new DicomPixelDataElement"
    - from: "src/SharpDicom/DicomFile.cs"
      to: "src/SharpDicom/Data/DicomDataset.cs"
      via: "Accesses pixel data from dataset"
      pattern: "Dataset\\.GetPixelData"
---

<objective>
Integrate pixel data handling into DicomFileReader and DicomFile for seamless file reading.

Purpose: Complete the pixel data implementation by integrating the new types into the existing file reading pipeline. Users should be able to read DICOM files with configurable pixel data loading behavior.

Output:
- DicomFileReader enhanced to handle pixel data based on options
- DicomFile with PixelData property for convenient access
- DicomDataset with GetPixelData method
- Integration tests with real DICOM file structures
- Support for LoadInMemory, LazyLoad, Skip, and Callback modes
</objective>

<execution_context>
@/Users/jas88/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jas88/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-pixel-data/05-CONTEXT.md
@.planning/phases/05-pixel-data/05-RESEARCH.md
@.planning/phases/05-pixel-data/05-01-SUMMARY.md
@.planning/phases/05-pixel-data/05-02-SUMMARY.md

# Key existing files
@src/SharpDicom/IO/DicomFileReader.cs
@src/SharpDicom/DicomFile.cs
@src/SharpDicom/Data/DicomDataset.cs
@src/SharpDicom/IO/DicomReaderOptions.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate pixel data handling into DicomFileReader</name>
  <files>
    src/SharpDicom/IO/DicomFileReader.cs
  </files>
  <action>
Modify DicomFileReader to handle pixel data based on DicomReaderOptions.PixelDataHandling:

1. **Track stream position and pixel data context**:
   - Add private field `long _streamPosition` to track absolute position in file
   - Add private field `DicomDataset? _contextDataset` to accumulate elements before pixel data for VR resolution
   - Update stream position after each read operation

2. **Detect pixel data tag (7FE0,0010)**:
   In `ParseElementsFromBuffer`, when tag == DicomTag.PixelData:
   - Determine if encapsulated: `valueLength == UndefinedLength || TransferSyntax.IsEncapsulated`
   - Build PixelDataContext from accumulated context dataset
   - Determine VR based on BitsAllocated (OB if <= 8, OW if > 8, OB if encapsulated)

3. **Handle based on PixelDataHandling setting**:

   **PixelDataHandling.LoadInMemory** (current behavior):
   - For native: read all bytes into memory, create ImmediatePixelDataSource
   - For encapsulated: parse with FragmentParser.ParseEncapsulated, create DicomFragmentSequence
   - Create DicomPixelDataElement with appropriate source

   **PixelDataHandling.LazyLoad**:
   - Record current stream position (offset)
   - If native: record valueLength, create LazyPixelDataSource with stream, offset, length
   - If encapsulated: read fragments (must read structure to know boundaries), but could defer fragment data loading (SIMPLIFICATION: for v1, load encapsulated immediately)
   - Skip past the data in the stream
   - Create DicomPixelDataElement with LazyPixelDataSource

   **PixelDataHandling.Skip**:
   - Record offset and length metadata
   - Create SkippedPixelDataSource
   - Skip past the data in the stream
   - Create DicomPixelDataElement with SkippedPixelDataSource

   **PixelDataHandling.Callback**:
   - Build PixelDataContext
   - Call _options.PixelDataCallback(context)
   - Handle result using logic above (LoadInMemory, LazyLoad, or Skip)

4. **Build PixelDataInfo**:
   ```csharp
   private PixelDataInfo BuildPixelDataInfo(DicomDataset context)
   {
       return new PixelDataInfo
       {
           Rows = GetUInt16FromDataset(context, DicomTag.Rows),
           Columns = GetUInt16FromDataset(context, DicomTag.Columns),
           BitsAllocated = GetUInt16FromDataset(context, DicomTag.BitsAllocated),
           BitsStored = GetUInt16FromDataset(context, DicomTag.BitsStored),
           HighBit = GetUInt16FromDataset(context, DicomTag.HighBit),
           SamplesPerPixel = GetUInt16FromDataset(context, DicomTag.SamplesPerPixel),
           NumberOfFrames = GetInt32FromDataset(context, DicomTag.NumberOfFrames) ?? 1,
           PlanarConfiguration = GetUInt16FromDataset(context, DicomTag.PlanarConfiguration),
           PixelRepresentation = GetUInt16FromDataset(context, DicomTag.PixelRepresentation)
       };
   }
   ```

5. **Handle undefined length for encapsulated**:
   - For encapsulated pixel data (valueLength == 0xFFFFFFFF), use FindSequenceDelimiter to locate end
   - Pass the encapsulated data buffer to FragmentParser.ParseEncapsulated
   - Store result as DicomFragmentSequence in DicomPixelDataElement

6. **Store stream reference for lazy loading**:
   - Add internal property `Stream? SourceStream` to DicomFileReader
   - Set during construction
   - Used by LazyPixelDataSource

Do NOT change the public API of DicomFileReader. All changes are internal implementation details.
  </action>
  <verify>
    - `dotnet build src/SharpDicom/SharpDicom.csproj` succeeds
    - No public API changes (existing code still compiles)
    - PixelDataHandling is respected during parsing
  </verify>
  <done>
    - DicomFileReader handles all four PixelDataHandling modes
    - Native pixel data creates appropriate source type
    - Encapsulated pixel data parsed with FragmentParser
    - Stream position tracked for lazy loading
    - PixelDataInfo populated from context
  </done>
</task>

<task type="auto">
  <name>Task 2: Add pixel data access to DicomDataset and DicomFile</name>
  <files>
    src/SharpDicom/Data/DicomDataset.cs
    src/SharpDicom/DicomFile.cs
  </files>
  <action>
1. **Add GetPixelData to DicomDataset.cs**:
   ```csharp
   /// <summary>
   /// Get the pixel data element if present.
   /// </summary>
   /// <returns>The pixel data element, or null if not present.</returns>
   public DicomPixelDataElement? GetPixelData()
       => this[DicomTag.PixelData] as DicomPixelDataElement;

   /// <summary>
   /// Get the pixel data element or throw if not present.
   /// </summary>
   /// <returns>The pixel data element.</returns>
   /// <exception cref="DicomDataException">Thrown when pixel data is not present.</exception>
   public DicomPixelDataElement GetPixelDataOrThrow()
       => GetPixelData() ?? throw new DicomDataException("Pixel data (7FE0,0010) not found in dataset");
   ```

   Add using statement for SharpDicom.Data.Exceptions if not present.

2. **Add PixelData property to DicomFile.cs**:
   ```csharp
   /// <summary>
   /// Gets the pixel data element if present in the dataset.
   /// </summary>
   /// <remarks>
   /// Returns null if the file contains no pixel data.
   /// For lazy-loaded pixel data, accessing this property or its data
   /// may trigger loading from the original stream.
   /// </remarks>
   public DicomPixelDataElement? PixelData => Dataset.GetPixelData();

   /// <summary>
   /// Gets a value indicating whether this file contains pixel data.
   /// </summary>
   public bool HasPixelData => Dataset.Contains(DicomTag.PixelData);
   ```

3. **Update DicomFile constructors** (if needed):
   - Ensure pixel data elements are properly transferred when creating DicomFile from reader
   - No changes needed if Dataset is passed through correctly

4. **Consider IDisposable for DicomFile** (OPTIONAL for v1):
   - For lazy loading, the source stream must remain open
   - Add note in XML docs about stream lifetime
   - For v1: document that callers should ensure stream stays open for lazy loading
   - Future: implement IDisposable to clean up lazy sources
  </action>
  <verify>
    - `dotnet build` succeeds for entire solution
    - DicomDataset.GetPixelData() compiles and returns correct type
    - DicomFile.PixelData property compiles
    - XML documentation is complete
  </verify>
  <done>
    - DicomDataset has GetPixelData() and GetPixelDataOrThrow() methods
    - DicomFile has PixelData property and HasPixelData property
    - Pixel data is accessible through clean API
    - Documentation explains lazy loading implications
  </done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests for pixel data reading</name>
  <files>
    tests/SharpDicom.Tests/IO/DicomFileReaderPixelDataTests.cs
    tests/SharpDicom.Tests/DicomFilePixelDataTests.cs
  </files>
  <action>
1. **Create DicomFileReaderPixelDataTests.cs**:
   Tests using synthetic DICOM-like byte arrays:

   - **Test_LoadInMemory_NativePixelData**:
     - Create byte array: preamble + DICM + FMI + image module tags + pixel data (native)
     - Parse with PixelDataHandling.LoadInMemory
     - Verify pixel data element is DicomPixelDataElement
     - Verify LoadState is Loaded
     - Verify GetFrameSpan returns correct data

   - **Test_Skip_NativePixelData**:
     - Same structure
     - Parse with PixelDataHandling.Skip
     - Verify LoadState is NotLoaded
     - Verify GetData throws InvalidOperationException

   - **Test_LazyLoad_NativePixelData**:
     - Create with MemoryStream (seekable)
     - Parse with PixelDataHandling.LazyLoad
     - Verify LoadState is NotLoaded initially
     - Call GetData() or LoadAsync()
     - Verify data is correct after load
     - Verify LoadState becomes Loaded

   - **Test_Callback_DeterminesHandling**:
     - Configure callback that returns Skip for small images, LoadInMemory for large
     - Create two synthetic files (one small, one large)
     - Verify callback decision is respected

   - **Test_EncapsulatedPixelData_Parsed**:
     - Create byte array with encapsulated structure (Item tags, fragments)
     - Verify DicomPixelDataElement.IsEncapsulated is true
     - Verify Fragments property is populated
     - Verify FragmentCount matches

   - **Test_MultiFrame_NativePixelData**:
     - Create 3 frames of 4x4 8-bit data
     - Verify NumberOfFrames in PixelDataInfo is 3
     - Verify GetFrameSpan(0), GetFrameSpan(1), GetFrameSpan(2) return correct slices

   Helper method to build synthetic DICOM structure:
   ```csharp
   private static byte[] BuildSyntheticDicom(
       ushort rows, ushort columns, ushort bitsAllocated,
       int numberOfFrames, byte[] pixelData,
       bool encapsulated = false)
   {
       // Build preamble (128 bytes) + DICM
       // Build FMI with transfer syntax
       // Build image module tags (Rows, Columns, BitsAllocated, etc.)
       // Build pixel data element
       // Return complete byte array
   }
   ```

2. **Create DicomFilePixelDataTests.cs**:
   High-level tests using DicomFile.Open:

   - **Test_OpenFile_WithPixelData_LoadsCorrectly**:
     - Write synthetic DICOM to temp file
     - Open with DicomFile.Open()
     - Verify HasPixelData is true
     - Verify PixelData is not null
     - Verify pixel data bytes match

   - **Test_OpenFile_WithoutPixelData_HasPixelDataFalse**:
     - Create DICOM without pixel data (e.g., SR document)
     - Verify HasPixelData is false
     - Verify PixelData is null

   - **Test_PixelData_FrameAccess**:
     - Open multi-frame file
     - Access individual frames via GetFrameSpan
     - Verify frame data matches expected

   - **Test_PixelData_AsyncLoad**:
     - Open with lazy loading
     - Call LoadAsync() on pixel data
     - Verify data loaded asynchronously

   Use temp files or MemoryStream for all tests.
   Clean up temp files in teardown.
   Use TestContext.CurrentContext.TestDirectory for temp file paths if needed.
  </action>
  <verify>
    - `dotnet test tests/SharpDicom.Tests/SharpDicom.Tests.csproj --filter "FullyQualifiedName~PixelData"` passes
    - All four PixelDataHandling modes tested
    - Both native and encapsulated formats tested
    - Multi-frame access tested
  </verify>
  <done>
    - DicomFileReaderPixelDataTests covers all loading modes
    - DicomFilePixelDataTests covers high-level API
    - Synthetic DICOM generation works correctly
    - All edge cases covered (empty, single-frame, multi-frame, encapsulated)
    - All tests pass across all target frameworks
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `dotnet build` succeeds for entire solution
2. `dotnet test` passes all tests including new ones
3. Phase 5 success criteria from ROADMAP.md verified:
   - Load uncompressed pixel data: tested in DicomFilePixelDataTests
   - Parse encapsulated fragments: tested with FragmentParser
   - Lazy loading skips pixel data: tested in Skip mode
   - Multi-frame datasets work: tested with frame access
4. No regression in existing tests (529 tests from Phase 4 still pass)
</verification>

<success_criteria>
- DicomFileReader creates DicomPixelDataElement for pixel data tag
- PixelDataHandling.LoadInMemory loads data immediately (existing behavior)
- PixelDataHandling.LazyLoad defers loading until accessed
- PixelDataHandling.Skip creates element without loading data
- PixelDataHandling.Callback allows per-instance decisions
- DicomFile.PixelData provides convenient access
- DicomDataset.GetPixelData() returns correctly typed element
- Multi-frame GetFrameSpan returns correct slice per frame
- Encapsulated pixel data parsed into DicomFragmentSequence
- All integration tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-pixel-data/05-03-SUMMARY.md`
</output>
