//HintName: DeidentificationProfiles.Generated.cs
// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using SharpDicom.Data;
#if NET8_0_OR_GREATER
using System.Collections.Frozen;
#endif

namespace SharpDicom.Deidentification
{
    /// <summary>
    /// Action codes from PS3.15 Table E.1-1a for de-identification.
    /// </summary>
    public enum DeidentificationAction
    {
        /// <summary>Keep unchanged (K).</summary>
        Keep,
        /// <summary>Remove attribute (X).</summary>
        Remove,
        /// <summary>Replace with zero-length or dummy (Z).</summary>
        ZeroOrDummy,
        /// <summary>Replace with non-zero dummy (D).</summary>
        Dummy,
        /// <summary>Clean - replace with safe similar meaning (C).</summary>
        Clean,
        /// <summary>Replace with consistent UID (U).</summary>
        RemapUid,
        /// <summary>Z unless D required for Type 2 vs Type 1 (Z/D).</summary>
        ZeroOrDummyConditional,
        /// <summary>X unless Z required for Type 3 vs Type 2 (X/Z).</summary>
        RemoveOrZeroConditional,
        /// <summary>X unless D required for Type 3 vs Type 1 (X/D).</summary>
        RemoveOrDummyConditional,
        /// <summary>X unless Z or D required (X/Z/D).</summary>
        RemoveOrZeroOrDummyConditional,
        /// <summary>X unless Z or U required for UID sequences (X/Z/U*).</summary>
        RemoveOrZeroOrUidConditional
    }

    /// <summary>
    /// Profile options for de-identification from PS3.15.
    /// </summary>
    [Flags]
    public enum DeidentificationProfileOption
    {
        /// <summary>No additional options.</summary>
        None = 0,
        /// <summary>Retain Safe Private Option.</summary>
        RetainSafePrivate = 1 << 0,
        /// <summary>Retain UIDs Option.</summary>
        RetainUIDs = 1 << 1,
        /// <summary>Retain Device Identity Option.</summary>
        RetainDeviceIdentity = 1 << 2,
        /// <summary>Retain Institution Identity Option.</summary>
        RetainInstitutionIdentity = 1 << 3,
        /// <summary>Retain Patient Characteristics Option.</summary>
        RetainPatientCharacteristics = 1 << 4,
        /// <summary>Retain Longitudinal Temporal Information Full Dates Option.</summary>
        RetainLongitudinalFullDates = 1 << 5,
        /// <summary>Retain Longitudinal Temporal Information Modified Dates Option.</summary>
        RetainLongitudinalModifiedDates = 1 << 6,
        /// <summary>Clean Descriptors Option.</summary>
        CleanDescriptors = 1 << 7,
        /// <summary>Clean Structured Content Option.</summary>
        CleanStructuredContent = 1 << 8,
        /// <summary>Clean Graphics Option.</summary>
        CleanGraphics = 1 << 9
    }

    /// <summary>
    /// Entry in the de-identification action table.
    /// </summary>
    internal readonly record struct DeidentificationActionEntry(
        uint TagValue,
        DeidentificationAction BasicProfile,
        DeidentificationAction? RetainSafePrivate,
        DeidentificationAction? RetainUIDs,
        DeidentificationAction? RetainDeviceIdentity,
        DeidentificationAction? RetainInstitutionIdentity,
        DeidentificationAction? RetainPatientChars,
        DeidentificationAction? RetainLongFullDates,
        DeidentificationAction? RetainLongModifiedDates,
        DeidentificationAction? CleanDescriptors,
        DeidentificationAction? CleanStructuredContent,
        DeidentificationAction? CleanGraphics);

    /// <summary>
    /// Generated de-identification profile data from PS3.15 Table E.1-1.
    /// </summary>
    public static partial class DeidentificationProfiles
    {
        private static readonly DeidentificationActionEntry[] s_entries = new[]
        {
            new DeidentificationActionEntry(0x00080050, DeidentificationAction.ZeroOrDummy, null, null, null, null, null, null, null, null, null, null),
        };

#if NET8_0_OR_GREATER
        private static readonly FrozenDictionary<uint, DeidentificationActionEntry> s_byTag =
            s_entries.ToFrozenDictionary(e => e.TagValue);
#else
        private static readonly Dictionary<uint, DeidentificationActionEntry> s_byTag =
            new Dictionary<uint, DeidentificationActionEntry>();

        static DeidentificationProfiles()
        {
            foreach (var entry in s_entries)
            {
                s_byTag[entry.TagValue] = entry;
            }
        }
#endif

        /// <summary>
        /// Gets the number of tags with defined de-identification actions.
        /// </summary>
        public static int Count => 1;

        /// <summary>
        /// Gets the de-identification action for a tag.
        /// </summary>
        /// <param name="tag">The DICOM tag.</param>
        /// <param name="options">Profile options to apply.</param>
        /// <returns>The action to apply, or Remove for unknown tags.</returns>
        public static DeidentificationAction GetAction(DicomTag tag, DeidentificationProfileOption options = DeidentificationProfileOption.None)
        {
            if (!s_byTag.TryGetValue(tag.Value, out var entry))
            {
                return DeidentificationAction.Remove; // Unknown tags removed by default
            }

            // Check options in order - first matching option wins
            if ((options & DeidentificationProfileOption.RetainSafePrivate) != 0 && entry.RetainSafePrivate.HasValue)
                return entry.RetainSafePrivate.Value;
            if ((options & DeidentificationProfileOption.RetainUIDs) != 0 && entry.RetainUIDs.HasValue)
                return entry.RetainUIDs.Value;
            if ((options & DeidentificationProfileOption.RetainDeviceIdentity) != 0 && entry.RetainDeviceIdentity.HasValue)
                return entry.RetainDeviceIdentity.Value;
            if ((options & DeidentificationProfileOption.RetainInstitutionIdentity) != 0 && entry.RetainInstitutionIdentity.HasValue)
                return entry.RetainInstitutionIdentity.Value;
            if ((options & DeidentificationProfileOption.RetainPatientCharacteristics) != 0 && entry.RetainPatientChars.HasValue)
                return entry.RetainPatientChars.Value;
            if ((options & DeidentificationProfileOption.RetainLongitudinalFullDates) != 0 && entry.RetainLongFullDates.HasValue)
                return entry.RetainLongFullDates.Value;
            if ((options & DeidentificationProfileOption.RetainLongitudinalModifiedDates) != 0 && entry.RetainLongModifiedDates.HasValue)
                return entry.RetainLongModifiedDates.Value;
            if ((options & DeidentificationProfileOption.CleanDescriptors) != 0 && entry.CleanDescriptors.HasValue)
                return entry.CleanDescriptors.Value;
            if ((options & DeidentificationProfileOption.CleanStructuredContent) != 0 && entry.CleanStructuredContent.HasValue)
                return entry.CleanStructuredContent.Value;
            if ((options & DeidentificationProfileOption.CleanGraphics) != 0 && entry.CleanGraphics.HasValue)
                return entry.CleanGraphics.Value;

            return entry.BasicProfile;
        }

        /// <summary>
        /// Tries to get the de-identification entry for a tag.
        /// </summary>
        internal static bool TryGetEntry(DicomTag tag, out DeidentificationActionEntry entry)
        {
            return s_byTag.TryGetValue(tag.Value, out entry);
        }
    }
}
